#pragma  once

#include "Core/Compile/TypeList.h"


/************************************************************************/
/* 
Performance:
Debug:3 times slower than normal Func*
Release: 1.5 times slower than normal Func*

Occupy:
12 bytes vs 4/8 bytes of Func*

It's so fast!
Why?
Because we want to support more amazing features, it can bind everything!

*/
/************************************************************************/

MEDUSA_BEGIN;
//#define  MEDUSA_DELEGATE_OPTIMZE_ENABLED			//Enable this means only support single inherit,or support multiple inherit
namespace Pattern
{
	template<typename FuncSignature>
	class Delegate;

	namespace Private 
	{
		class _UndefinedClass_t;
		typedef double (_UndefinedClass_t::*MaxMemberFunctionPointer)();
#ifdef MEDUSA_DELEGATE_OPTIMZE_ENABLED
#define MAX_MEMBER_FUNCTION_POINTER_SIZE 4
#else
#define MAX_MEMBER_FUNCTION_POINTER_SIZE sizeof(MaxMemberFunctionPointer)
#endif
		struct MemberFunctionPointer
		{
			MemberFunctionPointer()
			{
				//why not memset? this is more fast!
				int* p=(int*)&mMemberFunctionPointer;
				switch (MAX_MEMBER_FUNCTION_POINTER_SIZE)
				{
				case 4:
					*p=0;
					break;
				case 8:
					*p++=0;
					*p=0;
					break;
				case 12:
					*p++=0;
					*p++=0;
					*p=0;
					break;
				case 16:
					*p++=0;
					*p++=0;
					*p++=0;
					*p=0;
					break;
				default:
					memset(p,0,MAX_MEMBER_FUNCTION_POINTER_SIZE);
					break;
				}
			}

			~MemberFunctionPointer()
			{
			}
			MemberFunctionPointer(const MemberFunctionPointer& pointer)
			{
				memcpy(mMemberFunctionPointer,pointer.mMemberFunctionPointer,sizeof(mMemberFunctionPointer));
			}

			MemberFunctionPointer& operator=(const MemberFunctionPointer& pointer)
			{
				memcpy(mMemberFunctionPointer,pointer.mMemberFunctionPointer,sizeof(mMemberFunctionPointer));
				return *this;
			}


			bool operator==(const MemberFunctionPointer& pointer)const
			{
				return memcmp(this,&pointer,sizeof(MemberFunctionPointer))==0;
			}

			bool operator!=(const MemberFunctionPointer& pointer)const
			{
				return memcmp(this,&pointer,sizeof(MemberFunctionPointer))!=0;
			}

			char mMemberFunctionPointer[MAX_MEMBER_FUNCTION_POINTER_SIZE];
		};
	}

	


#define DEFINE_TEMPLATE_TYPENAME_1(N, T)			MACRO_COMMA_IF(MACRO_INT_DEC(N)) typename T##N
#define DEFINE_TEMPLATE_TYPENAME(N, T)			MACRO_IF_ELSE(N,DEFINE_TEMPLATE_TYPENAME_1(N,T),MACRO_EMPTY)


#define DEFINE_PARAMETER_TYPE_NAME_1(N, T)			MACRO_COMMA_IF(MACRO_INT_DEC(N)) T##N  p##N
#define DEFINE_PARAMETER_TYPE_NAME(N, T)			MACRO_IF_ELSE(N,DEFINE_PARAMETER_TYPE_NAME_1(N,T),MACRO_EMPTY)

#define DEFINE_DELGATE_CLASS(N,P)																															\
	template<typename R MACRO_COMMA_IF(N)  MACRO_REPEAT(N, DEFINE_TEMPLATE_TYPENAME, T)>															\
	class Delegate<R (MACRO_REPEAT_PARAM(N, T))>																									\
	{																																				\
	public:																																			 \
	const static Delegate<R (MACRO_REPEAT_PARAM(N, T))>	Empty;																						\
	void* GetObject()const{return mObj;}																											 \
	void SetObject(void* obj){mObj=obj;}																											 \
	private:																																		\
	typedef R (*HelperWrapperType)(void*,void* MACRO_COMMA_IF(N) MACRO_REPEAT_PARAM(N, T));																		\
	void* mObj;																																	\
	HelperWrapperType mHelperFunc;																												\
	Private::MemberFunctionPointer mMemberFunctionPointer;																						\
	public:																																			\
	typedef R (*FunctionType)(MACRO_REPEAT_PARAM(N, T));																						\
	Delegate(FunctionType func=NULL):mObj((void*)func),mHelperFunc(GlobalWrapper){}																	\
	template<typename TFunc>																													\
	Delegate(TFunc* func):mObj((void*)func),mHelperFunc(FunctorWrapper<TFunc>){}													\
	template<typename TObj>																													   \
	Delegate(TObj* obj,R (TObj::*func)(MACRO_REPEAT_PARAM(N, T))):mObj(obj),mHelperFunc(MemberWrapper<TObj>)								   \
	{																																		   \
	typedef void (TObj::*large_pointer_to_method)(MACRO_REPEAT_PARAM(N, T));												   \
	reinterpret_cast<large_pointer_to_method&>(mMemberFunctionPointer) = reinterpret_cast<large_pointer_to_method&>(func);				   \
	}																																		   \
	template<typename TObj>																													   \
	Delegate(TObj* obj,R (TObj::*func)(MACRO_REPEAT_PARAM(N, T))const):mObj(obj),mHelperFunc(ConstMemberWrapper<TObj>)						   \
	{																																		   \
	typedef void (TObj::*large_pointer_to_method)(MACRO_REPEAT_PARAM(N, T))const;										   \
	reinterpret_cast<large_pointer_to_method&>(mMemberFunctionPointer) = reinterpret_cast<large_pointer_to_method&>(func);				   \
	}																																		   \
	~Delegate(){mObj=NULL;mHelperFunc=NULL;}\
	Delegate(const Delegate& otherDelegate){mObj=otherDelegate.mObj;mHelperFunc=otherDelegate.mHelperFunc;mMemberFunctionPointer=otherDelegate.mMemberFunctionPointer;}\
	Delegate& operator=(const Delegate& otherDelegate)																						   \
	{																																		   \
	mObj=otherDelegate.mObj;																											   \
	mHelperFunc=otherDelegate.mHelperFunc;																								   \
	mMemberFunctionPointer=otherDelegate.mMemberFunctionPointer;																		   \
	return *this;																															\
	}																																		   \
	bool EqualsTo(const Delegate& otherDelegate)const																							   \
	{																																		   \
	return mObj==otherDelegate.mObj																										   \
	&&mHelperFunc==otherDelegate.mHelperFunc																						   \
	&&mMemberFunctionPointer==otherDelegate.mMemberFunctionPointer;																				\
	}																																		   \
	R Invoke(MACRO_REPEAT(N, DEFINE_PARAMETER_TYPE_NAME, T))const																			   \
	{																																		   \
	return (*mHelperFunc)(mObj,(void*)&mMemberFunctionPointer MACRO_COMMA_IF(N) MACRO_REPEAT_PARAM(N, p));												   \
	}																																		   \
	bool IsNull()const{return mObj==NULL||mHelperFunc==NULL;}																					\
	bool IsValid()const{return mObj!=NULL&&mHelperFunc!=NULL;}																					\
	public:																																		   \
	R operator()(MACRO_REPEAT(N, DEFINE_PARAMETER_TYPE_NAME, T))const																		   \
	{																																		   \
	return (*mHelperFunc)(mObj,(void*)&mMemberFunctionPointer MACRO_COMMA_IF(N) MACRO_REPEAT_PARAM(N, p));												   \
	}																																		   \
	bool operator==(const Delegate& otherDelegate)const																							   \
	{																																		   \
	return EqualsTo(otherDelegate);																										   \
	}																																		   \
	bool operator!=(const Delegate& otherDelegate)const																							   \
	{																																		   \
	return !EqualsTo(otherDelegate);																									   \
	} 																																		   \
	bool operator!()const{return !IsNull();}																									\
	private:																																	   \
	template<typename TFunc>																												   \
	static R FunctorWrapper(void * obj,void* func MACRO_COMMA_IF(N) MACRO_REPEAT(N, DEFINE_PARAMETER_TYPE_NAME, T))									   \
	{																																		   \
	return (*(TFunc*)obj)(MACRO_REPEAT_PARAM(N, p));																					   \
	}																																		   \
	static R GlobalWrapper(void * obj,void* func MACRO_COMMA_IF(N) MACRO_REPEAT(N, DEFINE_PARAMETER_TYPE_NAME, T))											   \
	{																																		   \
	return ((FunctionType)obj)(MACRO_REPEAT_PARAM(N, p));																				   \
	}																																		  \
	template<typename TObj>																														\
	static R MemberWrapper(void * obj,void* func MACRO_COMMA_IF(N) MACRO_REPEAT(N, DEFINE_PARAMETER_TYPE_NAME, T))											   \
	{																																		   \
	typedef R (TObj::*large_pointer_to_method)(MACRO_REPEAT_PARAM(N, T));											   \
	return ((TObj*)obj->*(*((large_pointer_to_method*)func)))(MACRO_REPEAT_PARAM(N, p));									   \
	}																																		   \
	template<typename TObj>																													   \
	static R ConstMemberWrapper(void * obj,void* func MACRO_COMMA_IF(N) MACRO_REPEAT(N, DEFINE_PARAMETER_TYPE_NAME, T))										   \
	{																																		   \
	typedef R (TObj::*large_pointer_to_method)(MACRO_REPEAT_PARAM(N, T))const;										   \
	return ((TObj*)obj->*(*((large_pointer_to_method*)func)))(MACRO_REPEAT_PARAM(N, p));									   \
	}																																		   \
	};																																		\
	template<typename R MACRO_COMMA_IF(N)  MACRO_REPEAT(N, DEFINE_TEMPLATE_TYPENAME, T)>															\
	WEAK_MULTIPLE_DEFINE const Delegate<R (MACRO_REPEAT_PARAM(N, T))>	Delegate<R (MACRO_REPEAT_PARAM(N, T))>::Empty(NULL);	

#ifdef WIN32
	MACRO_REPEAT2(MACRO_MAX_LIMIT,DEFINE_DELGATE_CLASS,MACRO_EMPTY);	
#else
	
//BEGIN_AUTO_GENERATE_DELEGATE
template<typename R  > class Delegate<R ()> { public: const static Delegate<R ()> Empty; void* GetObjectW()const{return mObj;} void SetObject(void* obj){mObj=obj;} private: typedef R (*HelperWrapperType)(void*,void*  ); void* mObj; HelperWrapperType mHelperFunc; Private::MemberFunctionPointer mMemberFunctionPointer; public: typedef R (*FunctionType)(); Delegate(FunctionType func=0):mObj((void*)func),mHelperFunc(GlobalWrapper){} template<typename TFunc> Delegate(TFunc* func):mObj((void*)func),mHelperFunc(FunctorWrapper<TFunc>){} template<typename TObj> Delegate(TObj* obj,R (TObj::*func)()):mObj(obj),mHelperFunc(MemberWrapper<TObj>) { typedef void (TObj::*large_pointer_to_method)(); reinterpret_cast<large_pointer_to_method&>(mMemberFunctionPointer) = reinterpret_cast<large_pointer_to_method&>(func); } template<typename TObj> Delegate(TObj* obj,R (TObj::*func)()const):mObj(obj),mHelperFunc(ConstMemberWrapper<TObj>) { typedef void (TObj::*large_pointer_to_method)()const; reinterpret_cast<large_pointer_to_method&>(mMemberFunctionPointer) = reinterpret_cast<large_pointer_to_method&>(func); } ~Delegate(){mObj=0;mHelperFunc=0;} Delegate(const Delegate& otherDelegate){mObj=otherDelegate.mObj;mHelperFunc=otherDelegate.mHelperFunc;mMemberFunctionPointer=otherDelegate.mMemberFunctionPointer;} Delegate& operator=(const Delegate& otherDelegate) { mObj=otherDelegate.mObj; mHelperFunc=otherDelegate.mHelperFunc; mMemberFunctionPointer=otherDelegate.mMemberFunctionPointer; return *this; } bool EqualsTo(const Delegate& otherDelegate)const { return mObj==otherDelegate.mObj &&mHelperFunc==otherDelegate.mHelperFunc &&mMemberFunctionPointer==otherDelegate.mMemberFunctionPointer; } R Invoke()const { return (*mHelperFunc)(mObj,(void*)&mMemberFunctionPointer  ); } bool IsNull()const{return mObj==0||mHelperFunc==0;} bool IsValid()const{return mObj!=0&&mHelperFunc!=0;} public: R operator()()const { return (*mHelperFunc)(mObj,(void*)&mMemberFunctionPointer  ); } bool operator==(const Delegate& otherDelegate)const { return EqualsTo(otherDelegate); } bool operator!=(const Delegate& otherDelegate)const { return !EqualsTo(otherDelegate); } bool operator!()const{return !IsNull();} private: template<typename TFunc> static R FunctorWrapper(void * obj,void* func  ) { return (*(TFunc*)obj)(); } static R GlobalWrapper(void * obj,void* func  ) { return ((FunctionType)obj)(); } template<typename TObj> static R MemberWrapper(void * obj,void* func  ) { typedef R (TObj::*large_pointer_to_method)(); return ((TObj*)obj->*(*((large_pointer_to_method*)func)))(); } template<typename TObj> static R ConstMemberWrapper(void * obj,void* func  ) { typedef R (TObj::*large_pointer_to_method)()const; return ((TObj*)obj->*(*((large_pointer_to_method*)func)))(); } }; template<typename R  > WEAK_MULTIPLE_DEFINE const Delegate<R ()> Delegate<R ()>::Empty(0);
template<typename R ,  typename T1> class Delegate<R ( T1)> { public: const static Delegate<R ( T1)> Empty; void* GetObjectW()const{return mObj;} void SetObject(void* obj){mObj=obj;} private: typedef R (*HelperWrapperType)(void*,void* ,  T1); void* mObj; HelperWrapperType mHelperFunc; Private::MemberFunctionPointer mMemberFunctionPointer; public: typedef R (*FunctionType)( T1); Delegate(FunctionType func=0):mObj((void*)func),mHelperFunc(GlobalWrapper){} template<typename TFunc> Delegate(TFunc* func):mObj((void*)func),mHelperFunc(FunctorWrapper<TFunc>){} template<typename TObj> Delegate(TObj* obj,R (TObj::*func)( T1)):mObj(obj),mHelperFunc(MemberWrapper<TObj>) { typedef void (TObj::*large_pointer_to_method)( T1); reinterpret_cast<large_pointer_to_method&>(mMemberFunctionPointer) = reinterpret_cast<large_pointer_to_method&>(func); } template<typename TObj> Delegate(TObj* obj,R (TObj::*func)( T1)const):mObj(obj),mHelperFunc(ConstMemberWrapper<TObj>) { typedef void (TObj::*large_pointer_to_method)( T1)const; reinterpret_cast<large_pointer_to_method&>(mMemberFunctionPointer) = reinterpret_cast<large_pointer_to_method&>(func); } ~Delegate(){mObj=0;mHelperFunc=0;} Delegate(const Delegate& otherDelegate){mObj=otherDelegate.mObj;mHelperFunc=otherDelegate.mHelperFunc;mMemberFunctionPointer=otherDelegate.mMemberFunctionPointer;} Delegate& operator=(const Delegate& otherDelegate) { mObj=otherDelegate.mObj; mHelperFunc=otherDelegate.mHelperFunc; mMemberFunctionPointer=otherDelegate.mMemberFunctionPointer; return *this; } bool EqualsTo(const Delegate& otherDelegate)const { return mObj==otherDelegate.mObj &&mHelperFunc==otherDelegate.mHelperFunc &&mMemberFunctionPointer==otherDelegate.mMemberFunctionPointer; } R Invoke( T1 p1)const { return (*mHelperFunc)(mObj,(void*)&mMemberFunctionPointer ,  p1); } bool IsNull()const{return mObj==0||mHelperFunc==0;} bool IsValid()const{return mObj!=0&&mHelperFunc!=0;} public: R operator()( T1 p1)const { return (*mHelperFunc)(mObj,(void*)&mMemberFunctionPointer ,  p1); } bool operator==(const Delegate& otherDelegate)const { return EqualsTo(otherDelegate); } bool operator!=(const Delegate& otherDelegate)const { return !EqualsTo(otherDelegate); } bool operator!()const{return !IsNull();} private: template<typename TFunc> static R FunctorWrapper(void * obj,void* func ,  T1 p1) { return (*(TFunc*)obj)( p1); } static R GlobalWrapper(void * obj,void* func ,  T1 p1) { return ((FunctionType)obj)( p1); } template<typename TObj> static R MemberWrapper(void * obj,void* func ,  T1 p1) { typedef R (TObj::*large_pointer_to_method)( T1); return ((TObj*)obj->*(*((large_pointer_to_method*)func)))( p1); } template<typename TObj> static R ConstMemberWrapper(void * obj,void* func ,  T1 p1) { typedef R (TObj::*large_pointer_to_method)( T1)const; return ((TObj*)obj->*(*((large_pointer_to_method*)func)))( p1); } }; template<typename R ,  typename T1> WEAK_MULTIPLE_DEFINE const Delegate<R ( T1)> Delegate<R ( T1)>::Empty(0);
template<typename R ,  typename T1, typename T2> class Delegate<R ( T1, T2)> { public: const static Delegate<R ( T1, T2)> Empty; void* GetObjectW()const{return mObj;} void SetObject(void* obj){mObj=obj;} private: typedef R (*HelperWrapperType)(void*,void* ,  T1, T2); void* mObj; HelperWrapperType mHelperFunc; Private::MemberFunctionPointer mMemberFunctionPointer; public: typedef R (*FunctionType)( T1, T2); Delegate(FunctionType func=0):mObj((void*)func),mHelperFunc(GlobalWrapper){} template<typename TFunc> Delegate(TFunc* func):mObj((void*)func),mHelperFunc(FunctorWrapper<TFunc>){} template<typename TObj> Delegate(TObj* obj,R (TObj::*func)( T1, T2)):mObj(obj),mHelperFunc(MemberWrapper<TObj>) { typedef void (TObj::*large_pointer_to_method)( T1, T2); reinterpret_cast<large_pointer_to_method&>(mMemberFunctionPointer) = reinterpret_cast<large_pointer_to_method&>(func); } template<typename TObj> Delegate(TObj* obj,R (TObj::*func)( T1, T2)const):mObj(obj),mHelperFunc(ConstMemberWrapper<TObj>) { typedef void (TObj::*large_pointer_to_method)( T1, T2)const; reinterpret_cast<large_pointer_to_method&>(mMemberFunctionPointer) = reinterpret_cast<large_pointer_to_method&>(func); } ~Delegate(){mObj=0;mHelperFunc=0;} Delegate(const Delegate& otherDelegate){mObj=otherDelegate.mObj;mHelperFunc=otherDelegate.mHelperFunc;mMemberFunctionPointer=otherDelegate.mMemberFunctionPointer;} Delegate& operator=(const Delegate& otherDelegate) { mObj=otherDelegate.mObj; mHelperFunc=otherDelegate.mHelperFunc; mMemberFunctionPointer=otherDelegate.mMemberFunctionPointer; return *this; } bool EqualsTo(const Delegate& otherDelegate)const { return mObj==otherDelegate.mObj &&mHelperFunc==otherDelegate.mHelperFunc &&mMemberFunctionPointer==otherDelegate.mMemberFunctionPointer; } R Invoke( T1 p1, T2 p2)const { return (*mHelperFunc)(mObj,(void*)&mMemberFunctionPointer ,  p1, p2); } bool IsNull()const{return mObj==0||mHelperFunc==0;} bool IsValid()const{return mObj!=0&&mHelperFunc!=0;} public: R operator()( T1 p1, T2 p2)const { return (*mHelperFunc)(mObj,(void*)&mMemberFunctionPointer ,  p1, p2); } bool operator==(const Delegate& otherDelegate)const { return EqualsTo(otherDelegate); } bool operator!=(const Delegate& otherDelegate)const { return !EqualsTo(otherDelegate); } bool operator!()const{return !IsNull();} private: template<typename TFunc> static R FunctorWrapper(void * obj,void* func ,  T1 p1, T2 p2) { return (*(TFunc*)obj)( p1, p2); } static R GlobalWrapper(void * obj,void* func ,  T1 p1, T2 p2) { return ((FunctionType)obj)( p1, p2); } template<typename TObj> static R MemberWrapper(void * obj,void* func ,  T1 p1, T2 p2) { typedef R (TObj::*large_pointer_to_method)( T1, T2); return ((TObj*)obj->*(*((large_pointer_to_method*)func)))( p1, p2); } template<typename TObj> static R ConstMemberWrapper(void * obj,void* func ,  T1 p1, T2 p2) { typedef R (TObj::*large_pointer_to_method)( T1, T2)const; return ((TObj*)obj->*(*((large_pointer_to_method*)func)))( p1, p2); } }; template<typename R ,  typename T1, typename T2> WEAK_MULTIPLE_DEFINE const Delegate<R ( T1, T2)> Delegate<R ( T1, T2)>::Empty(0);
template<typename R ,  typename T1, typename T2, typename T3> class Delegate<R ( T1, T2, T3)> { public: const static Delegate<R ( T1, T2, T3)> Empty; void* GetObjectW()const{return mObj;} void SetObject(void* obj){mObj=obj;} private: typedef R (*HelperWrapperType)(void*,void* ,  T1, T2, T3); void* mObj; HelperWrapperType mHelperFunc; Private::MemberFunctionPointer mMemberFunctionPointer; public: typedef R (*FunctionType)( T1, T2, T3); Delegate(FunctionType func=0):mObj((void*)func),mHelperFunc(GlobalWrapper){} template<typename TFunc> Delegate(TFunc* func):mObj((void*)func),mHelperFunc(FunctorWrapper<TFunc>){} template<typename TObj> Delegate(TObj* obj,R (TObj::*func)( T1, T2, T3)):mObj(obj),mHelperFunc(MemberWrapper<TObj>) { typedef void (TObj::*large_pointer_to_method)( T1, T2, T3); reinterpret_cast<large_pointer_to_method&>(mMemberFunctionPointer) = reinterpret_cast<large_pointer_to_method&>(func); } template<typename TObj> Delegate(TObj* obj,R (TObj::*func)( T1, T2, T3)const):mObj(obj),mHelperFunc(ConstMemberWrapper<TObj>) { typedef void (TObj::*large_pointer_to_method)( T1, T2, T3)const; reinterpret_cast<large_pointer_to_method&>(mMemberFunctionPointer) = reinterpret_cast<large_pointer_to_method&>(func); } ~Delegate(){mObj=0;mHelperFunc=0;} Delegate(const Delegate& otherDelegate){mObj=otherDelegate.mObj;mHelperFunc=otherDelegate.mHelperFunc;mMemberFunctionPointer=otherDelegate.mMemberFunctionPointer;} Delegate& operator=(const Delegate& otherDelegate) { mObj=otherDelegate.mObj; mHelperFunc=otherDelegate.mHelperFunc; mMemberFunctionPointer=otherDelegate.mMemberFunctionPointer; return *this; } bool EqualsTo(const Delegate& otherDelegate)const { return mObj==otherDelegate.mObj &&mHelperFunc==otherDelegate.mHelperFunc &&mMemberFunctionPointer==otherDelegate.mMemberFunctionPointer; } R Invoke( T1 p1, T2 p2, T3 p3)const { return (*mHelperFunc)(mObj,(void*)&mMemberFunctionPointer ,  p1, p2, p3); } bool IsNull()const{return mObj==0||mHelperFunc==0;} bool IsValid()const{return mObj!=0&&mHelperFunc!=0;} public: R operator()( T1 p1, T2 p2, T3 p3)const { return (*mHelperFunc)(mObj,(void*)&mMemberFunctionPointer ,  p1, p2, p3); } bool operator==(const Delegate& otherDelegate)const { return EqualsTo(otherDelegate); } bool operator!=(const Delegate& otherDelegate)const { return !EqualsTo(otherDelegate); } bool operator!()const{return !IsNull();} private: template<typename TFunc> static R FunctorWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3) { return (*(TFunc*)obj)( p1, p2, p3); } static R GlobalWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3) { return ((FunctionType)obj)( p1, p2, p3); } template<typename TObj> static R MemberWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3) { typedef R (TObj::*large_pointer_to_method)( T1, T2, T3); return ((TObj*)obj->*(*((large_pointer_to_method*)func)))( p1, p2, p3); } template<typename TObj> static R ConstMemberWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3) { typedef R (TObj::*large_pointer_to_method)( T1, T2, T3)const; return ((TObj*)obj->*(*((large_pointer_to_method*)func)))( p1, p2, p3); } }; template<typename R ,  typename T1, typename T2, typename T3> WEAK_MULTIPLE_DEFINE const Delegate<R ( T1, T2, T3)> Delegate<R ( T1, T2, T3)>::Empty(0);
template<typename R ,  typename T1, typename T2, typename T3, typename T4> class Delegate<R ( T1, T2, T3, T4)> { public: const static Delegate<R ( T1, T2, T3, T4)> Empty; void* GetObjectW()const{return mObj;} void SetObject(void* obj){mObj=obj;} private: typedef R (*HelperWrapperType)(void*,void* ,  T1, T2, T3, T4); void* mObj; HelperWrapperType mHelperFunc; Private::MemberFunctionPointer mMemberFunctionPointer; public: typedef R (*FunctionType)( T1, T2, T3, T4); Delegate(FunctionType func=0):mObj((void*)func),mHelperFunc(GlobalWrapper){} template<typename TFunc> Delegate(TFunc* func):mObj((void*)func),mHelperFunc(FunctorWrapper<TFunc>){} template<typename TObj> Delegate(TObj* obj,R (TObj::*func)( T1, T2, T3, T4)):mObj(obj),mHelperFunc(MemberWrapper<TObj>) { typedef void (TObj::*large_pointer_to_method)( T1, T2, T3, T4); reinterpret_cast<large_pointer_to_method&>(mMemberFunctionPointer) = reinterpret_cast<large_pointer_to_method&>(func); } template<typename TObj> Delegate(TObj* obj,R (TObj::*func)( T1, T2, T3, T4)const):mObj(obj),mHelperFunc(ConstMemberWrapper<TObj>) { typedef void (TObj::*large_pointer_to_method)( T1, T2, T3, T4)const; reinterpret_cast<large_pointer_to_method&>(mMemberFunctionPointer) = reinterpret_cast<large_pointer_to_method&>(func); } ~Delegate(){mObj=0;mHelperFunc=0;} Delegate(const Delegate& otherDelegate){mObj=otherDelegate.mObj;mHelperFunc=otherDelegate.mHelperFunc;mMemberFunctionPointer=otherDelegate.mMemberFunctionPointer;} Delegate& operator=(const Delegate& otherDelegate) { mObj=otherDelegate.mObj; mHelperFunc=otherDelegate.mHelperFunc; mMemberFunctionPointer=otherDelegate.mMemberFunctionPointer; return *this; } bool EqualsTo(const Delegate& otherDelegate)const { return mObj==otherDelegate.mObj &&mHelperFunc==otherDelegate.mHelperFunc &&mMemberFunctionPointer==otherDelegate.mMemberFunctionPointer; } R Invoke( T1 p1, T2 p2, T3 p3, T4 p4)const { return (*mHelperFunc)(mObj,(void*)&mMemberFunctionPointer ,  p1, p2, p3, p4); } bool IsNull()const{return mObj==0||mHelperFunc==0;} bool IsValid()const{return mObj!=0&&mHelperFunc!=0;} public: R operator()( T1 p1, T2 p2, T3 p3, T4 p4)const { return (*mHelperFunc)(mObj,(void*)&mMemberFunctionPointer ,  p1, p2, p3, p4); } bool operator==(const Delegate& otherDelegate)const { return EqualsTo(otherDelegate); } bool operator!=(const Delegate& otherDelegate)const { return !EqualsTo(otherDelegate); } bool operator!()const{return !IsNull();} private: template<typename TFunc> static R FunctorWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4) { return (*(TFunc*)obj)( p1, p2, p3, p4); } static R GlobalWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4) { return ((FunctionType)obj)( p1, p2, p3, p4); } template<typename TObj> static R MemberWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4) { typedef R (TObj::*large_pointer_to_method)( T1, T2, T3, T4); return ((TObj*)obj->*(*((large_pointer_to_method*)func)))( p1, p2, p3, p4); } template<typename TObj> static R ConstMemberWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4) { typedef R (TObj::*large_pointer_to_method)( T1, T2, T3, T4)const; return ((TObj*)obj->*(*((large_pointer_to_method*)func)))( p1, p2, p3, p4); } }; template<typename R ,  typename T1, typename T2, typename T3, typename T4> WEAK_MULTIPLE_DEFINE const Delegate<R ( T1, T2, T3, T4)> Delegate<R ( T1, T2, T3, T4)>::Empty(0);
template<typename R ,  typename T1, typename T2, typename T3, typename T4, typename T5> class Delegate<R ( T1, T2, T3, T4, T5)> { public: const static Delegate<R ( T1, T2, T3, T4, T5)> Empty; void* GetObjectW()const{return mObj;} void SetObject(void* obj){mObj=obj;} private: typedef R (*HelperWrapperType)(void*,void* ,  T1, T2, T3, T4, T5); void* mObj; HelperWrapperType mHelperFunc; Private::MemberFunctionPointer mMemberFunctionPointer; public: typedef R (*FunctionType)( T1, T2, T3, T4, T5); Delegate(FunctionType func=0):mObj((void*)func),mHelperFunc(GlobalWrapper){} template<typename TFunc> Delegate(TFunc* func):mObj((void*)func),mHelperFunc(FunctorWrapper<TFunc>){} template<typename TObj> Delegate(TObj* obj,R (TObj::*func)( T1, T2, T3, T4, T5)):mObj(obj),mHelperFunc(MemberWrapper<TObj>) { typedef void (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5); reinterpret_cast<large_pointer_to_method&>(mMemberFunctionPointer) = reinterpret_cast<large_pointer_to_method&>(func); } template<typename TObj> Delegate(TObj* obj,R (TObj::*func)( T1, T2, T3, T4, T5)const):mObj(obj),mHelperFunc(ConstMemberWrapper<TObj>) { typedef void (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5)const; reinterpret_cast<large_pointer_to_method&>(mMemberFunctionPointer) = reinterpret_cast<large_pointer_to_method&>(func); } ~Delegate(){mObj=0;mHelperFunc=0;} Delegate(const Delegate& otherDelegate){mObj=otherDelegate.mObj;mHelperFunc=otherDelegate.mHelperFunc;mMemberFunctionPointer=otherDelegate.mMemberFunctionPointer;} Delegate& operator=(const Delegate& otherDelegate) { mObj=otherDelegate.mObj; mHelperFunc=otherDelegate.mHelperFunc; mMemberFunctionPointer=otherDelegate.mMemberFunctionPointer; return *this; } bool EqualsTo(const Delegate& otherDelegate)const { return mObj==otherDelegate.mObj &&mHelperFunc==otherDelegate.mHelperFunc &&mMemberFunctionPointer==otherDelegate.mMemberFunctionPointer; } R Invoke( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5)const { return (*mHelperFunc)(mObj,(void*)&mMemberFunctionPointer ,  p1, p2, p3, p4, p5); } bool IsNull()const{return mObj==0||mHelperFunc==0;} bool IsValid()const{return mObj!=0&&mHelperFunc!=0;} public: R operator()( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5)const { return (*mHelperFunc)(mObj,(void*)&mMemberFunctionPointer ,  p1, p2, p3, p4, p5); } bool operator==(const Delegate& otherDelegate)const { return EqualsTo(otherDelegate); } bool operator!=(const Delegate& otherDelegate)const { return !EqualsTo(otherDelegate); } bool operator!()const{return !IsNull();} private: template<typename TFunc> static R FunctorWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5) { return (*(TFunc*)obj)( p1, p2, p3, p4, p5); } static R GlobalWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5) { return ((FunctionType)obj)( p1, p2, p3, p4, p5); } template<typename TObj> static R MemberWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5) { typedef R (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5); return ((TObj*)obj->*(*((large_pointer_to_method*)func)))( p1, p2, p3, p4, p5); } template<typename TObj> static R ConstMemberWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5) { typedef R (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5)const; return ((TObj*)obj->*(*((large_pointer_to_method*)func)))( p1, p2, p3, p4, p5); } }; template<typename R ,  typename T1, typename T2, typename T3, typename T4, typename T5> WEAK_MULTIPLE_DEFINE const Delegate<R ( T1, T2, T3, T4, T5)> Delegate<R ( T1, T2, T3, T4, T5)>::Empty(0);
template<typename R ,  typename T1, typename T2, typename T3, typename T4, typename T5, typename T6> class Delegate<R ( T1, T2, T3, T4, T5, T6)> { public: const static Delegate<R ( T1, T2, T3, T4, T5, T6)> Empty; void* GetObjectW()const{return mObj;} void SetObject(void* obj){mObj=obj;} private: typedef R (*HelperWrapperType)(void*,void* ,  T1, T2, T3, T4, T5, T6); void* mObj; HelperWrapperType mHelperFunc; Private::MemberFunctionPointer mMemberFunctionPointer; public: typedef R (*FunctionType)( T1, T2, T3, T4, T5, T6); Delegate(FunctionType func=0):mObj((void*)func),mHelperFunc(GlobalWrapper){} template<typename TFunc> Delegate(TFunc* func):mObj((void*)func),mHelperFunc(FunctorWrapper<TFunc>){} template<typename TObj> Delegate(TObj* obj,R (TObj::*func)( T1, T2, T3, T4, T5, T6)):mObj(obj),mHelperFunc(MemberWrapper<TObj>) { typedef void (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6); reinterpret_cast<large_pointer_to_method&>(mMemberFunctionPointer) = reinterpret_cast<large_pointer_to_method&>(func); } template<typename TObj> Delegate(TObj* obj,R (TObj::*func)( T1, T2, T3, T4, T5, T6)const):mObj(obj),mHelperFunc(ConstMemberWrapper<TObj>) { typedef void (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6)const; reinterpret_cast<large_pointer_to_method&>(mMemberFunctionPointer) = reinterpret_cast<large_pointer_to_method&>(func); } ~Delegate(){mObj=0;mHelperFunc=0;} Delegate(const Delegate& otherDelegate){mObj=otherDelegate.mObj;mHelperFunc=otherDelegate.mHelperFunc;mMemberFunctionPointer=otherDelegate.mMemberFunctionPointer;} Delegate& operator=(const Delegate& otherDelegate) { mObj=otherDelegate.mObj; mHelperFunc=otherDelegate.mHelperFunc; mMemberFunctionPointer=otherDelegate.mMemberFunctionPointer; return *this; } bool EqualsTo(const Delegate& otherDelegate)const { return mObj==otherDelegate.mObj &&mHelperFunc==otherDelegate.mHelperFunc &&mMemberFunctionPointer==otherDelegate.mMemberFunctionPointer; } R Invoke( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6)const { return (*mHelperFunc)(mObj,(void*)&mMemberFunctionPointer ,  p1, p2, p3, p4, p5, p6); } bool IsNull()const{return mObj==0||mHelperFunc==0;} bool IsValid()const{return mObj!=0&&mHelperFunc!=0;} public: R operator()( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6)const { return (*mHelperFunc)(mObj,(void*)&mMemberFunctionPointer ,  p1, p2, p3, p4, p5, p6); } bool operator==(const Delegate& otherDelegate)const { return EqualsTo(otherDelegate); } bool operator!=(const Delegate& otherDelegate)const { return !EqualsTo(otherDelegate); } bool operator!()const{return !IsNull();} private: template<typename TFunc> static R FunctorWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6) { return (*(TFunc*)obj)( p1, p2, p3, p4, p5, p6); } static R GlobalWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6) { return ((FunctionType)obj)( p1, p2, p3, p4, p5, p6); } template<typename TObj> static R MemberWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6) { typedef R (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6); return ((TObj*)obj->*(*((large_pointer_to_method*)func)))( p1, p2, p3, p4, p5, p6); } template<typename TObj> static R ConstMemberWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6) { typedef R (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6)const; return ((TObj*)obj->*(*((large_pointer_to_method*)func)))( p1, p2, p3, p4, p5, p6); } }; template<typename R ,  typename T1, typename T2, typename T3, typename T4, typename T5, typename T6> WEAK_MULTIPLE_DEFINE const Delegate<R ( T1, T2, T3, T4, T5, T6)> Delegate<R ( T1, T2, T3, T4, T5, T6)>::Empty(0);
template<typename R ,  typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7> class Delegate<R ( T1, T2, T3, T4, T5, T6, T7)> { public: const static Delegate<R ( T1, T2, T3, T4, T5, T6, T7)> Empty; void* GetObjectW()const{return mObj;} void SetObject(void* obj){mObj=obj;} private: typedef R (*HelperWrapperType)(void*,void* ,  T1, T2, T3, T4, T5, T6, T7); void* mObj; HelperWrapperType mHelperFunc; Private::MemberFunctionPointer mMemberFunctionPointer; public: typedef R (*FunctionType)( T1, T2, T3, T4, T5, T6, T7); Delegate(FunctionType func=0):mObj((void*)func),mHelperFunc(GlobalWrapper){} template<typename TFunc> Delegate(TFunc* func):mObj((void*)func),mHelperFunc(FunctorWrapper<TFunc>){} template<typename TObj> Delegate(TObj* obj,R (TObj::*func)( T1, T2, T3, T4, T5, T6, T7)):mObj(obj),mHelperFunc(MemberWrapper<TObj>) { typedef void (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7); reinterpret_cast<large_pointer_to_method&>(mMemberFunctionPointer) = reinterpret_cast<large_pointer_to_method&>(func); } template<typename TObj> Delegate(TObj* obj,R (TObj::*func)( T1, T2, T3, T4, T5, T6, T7)const):mObj(obj),mHelperFunc(ConstMemberWrapper<TObj>) { typedef void (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7)const; reinterpret_cast<large_pointer_to_method&>(mMemberFunctionPointer) = reinterpret_cast<large_pointer_to_method&>(func); } ~Delegate(){mObj=0;mHelperFunc=0;} Delegate(const Delegate& otherDelegate){mObj=otherDelegate.mObj;mHelperFunc=otherDelegate.mHelperFunc;mMemberFunctionPointer=otherDelegate.mMemberFunctionPointer;} Delegate& operator=(const Delegate& otherDelegate) { mObj=otherDelegate.mObj; mHelperFunc=otherDelegate.mHelperFunc; mMemberFunctionPointer=otherDelegate.mMemberFunctionPointer; return *this; } bool EqualsTo(const Delegate& otherDelegate)const { return mObj==otherDelegate.mObj &&mHelperFunc==otherDelegate.mHelperFunc &&mMemberFunctionPointer==otherDelegate.mMemberFunctionPointer; } R Invoke( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7)const { return (*mHelperFunc)(mObj,(void*)&mMemberFunctionPointer ,  p1, p2, p3, p4, p5, p6, p7); } bool IsNull()const{return mObj==0||mHelperFunc==0;} bool IsValid()const{return mObj!=0&&mHelperFunc!=0;} public: R operator()( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7)const { return (*mHelperFunc)(mObj,(void*)&mMemberFunctionPointer ,  p1, p2, p3, p4, p5, p6, p7); } bool operator==(const Delegate& otherDelegate)const { return EqualsTo(otherDelegate); } bool operator!=(const Delegate& otherDelegate)const { return !EqualsTo(otherDelegate); } bool operator!()const{return !IsNull();} private: template<typename TFunc> static R FunctorWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7) { return (*(TFunc*)obj)( p1, p2, p3, p4, p5, p6, p7); } static R GlobalWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7) { return ((FunctionType)obj)( p1, p2, p3, p4, p5, p6, p7); } template<typename TObj> static R MemberWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7) { typedef R (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7); return ((TObj*)obj->*(*((large_pointer_to_method*)func)))( p1, p2, p3, p4, p5, p6, p7); } template<typename TObj> static R ConstMemberWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7) { typedef R (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7)const; return ((TObj*)obj->*(*((large_pointer_to_method*)func)))( p1, p2, p3, p4, p5, p6, p7); } }; template<typename R ,  typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7> WEAK_MULTIPLE_DEFINE const Delegate<R ( T1, T2, T3, T4, T5, T6, T7)> Delegate<R ( T1, T2, T3, T4, T5, T6, T7)>::Empty(0);
template<typename R ,  typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8> class Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8)> { public: const static Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8)> Empty; void* GetObjectW()const{return mObj;} void SetObject(void* obj){mObj=obj;} private: typedef R (*HelperWrapperType)(void*,void* ,  T1, T2, T3, T4, T5, T6, T7, T8); void* mObj; HelperWrapperType mHelperFunc; Private::MemberFunctionPointer mMemberFunctionPointer; public: typedef R (*FunctionType)( T1, T2, T3, T4, T5, T6, T7, T8); Delegate(FunctionType func=0):mObj((void*)func),mHelperFunc(GlobalWrapper){} template<typename TFunc> Delegate(TFunc* func):mObj((void*)func),mHelperFunc(FunctorWrapper<TFunc>){} template<typename TObj> Delegate(TObj* obj,R (TObj::*func)( T1, T2, T3, T4, T5, T6, T7, T8)):mObj(obj),mHelperFunc(MemberWrapper<TObj>) { typedef void (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8); reinterpret_cast<large_pointer_to_method&>(mMemberFunctionPointer) = reinterpret_cast<large_pointer_to_method&>(func); } template<typename TObj> Delegate(TObj* obj,R (TObj::*func)( T1, T2, T3, T4, T5, T6, T7, T8)const):mObj(obj),mHelperFunc(ConstMemberWrapper<TObj>) { typedef void (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8)const; reinterpret_cast<large_pointer_to_method&>(mMemberFunctionPointer) = reinterpret_cast<large_pointer_to_method&>(func); } ~Delegate(){mObj=0;mHelperFunc=0;} Delegate(const Delegate& otherDelegate){mObj=otherDelegate.mObj;mHelperFunc=otherDelegate.mHelperFunc;mMemberFunctionPointer=otherDelegate.mMemberFunctionPointer;} Delegate& operator=(const Delegate& otherDelegate) { mObj=otherDelegate.mObj; mHelperFunc=otherDelegate.mHelperFunc; mMemberFunctionPointer=otherDelegate.mMemberFunctionPointer; return *this; } bool EqualsTo(const Delegate& otherDelegate)const { return mObj==otherDelegate.mObj &&mHelperFunc==otherDelegate.mHelperFunc &&mMemberFunctionPointer==otherDelegate.mMemberFunctionPointer; } R Invoke( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8)const { return (*mHelperFunc)(mObj,(void*)&mMemberFunctionPointer ,  p1, p2, p3, p4, p5, p6, p7, p8); } bool IsNull()const{return mObj==0||mHelperFunc==0;} bool IsValid()const{return mObj!=0&&mHelperFunc!=0;} public: R operator()( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8)const { return (*mHelperFunc)(mObj,(void*)&mMemberFunctionPointer ,  p1, p2, p3, p4, p5, p6, p7, p8); } bool operator==(const Delegate& otherDelegate)const { return EqualsTo(otherDelegate); } bool operator!=(const Delegate& otherDelegate)const { return !EqualsTo(otherDelegate); } bool operator!()const{return !IsNull();} private: template<typename TFunc> static R FunctorWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8) { return (*(TFunc*)obj)( p1, p2, p3, p4, p5, p6, p7, p8); } static R GlobalWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8) { return ((FunctionType)obj)( p1, p2, p3, p4, p5, p6, p7, p8); } template<typename TObj> static R MemberWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8) { typedef R (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8); return ((TObj*)obj->*(*((large_pointer_to_method*)func)))( p1, p2, p3, p4, p5, p6, p7, p8); } template<typename TObj> static R ConstMemberWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8) { typedef R (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8)const; return ((TObj*)obj->*(*((large_pointer_to_method*)func)))( p1, p2, p3, p4, p5, p6, p7, p8); } }; template<typename R ,  typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8> WEAK_MULTIPLE_DEFINE const Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8)> Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8)>::Empty(0);
template<typename R ,  typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9> class Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9)> { public: const static Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9)> Empty; void* GetObjectW()const{return mObj;} void SetObject(void* obj){mObj=obj;} private: typedef R (*HelperWrapperType)(void*,void* ,  T1, T2, T3, T4, T5, T6, T7, T8, T9); void* mObj; HelperWrapperType mHelperFunc; Private::MemberFunctionPointer mMemberFunctionPointer; public: typedef R (*FunctionType)( T1, T2, T3, T4, T5, T6, T7, T8, T9); Delegate(FunctionType func=0):mObj((void*)func),mHelperFunc(GlobalWrapper){} template<typename TFunc> Delegate(TFunc* func):mObj((void*)func),mHelperFunc(FunctorWrapper<TFunc>){} template<typename TObj> Delegate(TObj* obj,R (TObj::*func)( T1, T2, T3, T4, T5, T6, T7, T8, T9)):mObj(obj),mHelperFunc(MemberWrapper<TObj>) { typedef void (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9); reinterpret_cast<large_pointer_to_method&>(mMemberFunctionPointer) = reinterpret_cast<large_pointer_to_method&>(func); } template<typename TObj> Delegate(TObj* obj,R (TObj::*func)( T1, T2, T3, T4, T5, T6, T7, T8, T9)const):mObj(obj),mHelperFunc(ConstMemberWrapper<TObj>) { typedef void (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9)const; reinterpret_cast<large_pointer_to_method&>(mMemberFunctionPointer) = reinterpret_cast<large_pointer_to_method&>(func); } ~Delegate(){mObj=0;mHelperFunc=0;} Delegate(const Delegate& otherDelegate){mObj=otherDelegate.mObj;mHelperFunc=otherDelegate.mHelperFunc;mMemberFunctionPointer=otherDelegate.mMemberFunctionPointer;} Delegate& operator=(const Delegate& otherDelegate) { mObj=otherDelegate.mObj; mHelperFunc=otherDelegate.mHelperFunc; mMemberFunctionPointer=otherDelegate.mMemberFunctionPointer; return *this; } bool EqualsTo(const Delegate& otherDelegate)const { return mObj==otherDelegate.mObj &&mHelperFunc==otherDelegate.mHelperFunc &&mMemberFunctionPointer==otherDelegate.mMemberFunctionPointer; } R Invoke( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9)const { return (*mHelperFunc)(mObj,(void*)&mMemberFunctionPointer ,  p1, p2, p3, p4, p5, p6, p7, p8, p9); } bool IsNull()const{return mObj==0||mHelperFunc==0;} bool IsValid()const{return mObj!=0&&mHelperFunc!=0;} public: R operator()( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9)const { return (*mHelperFunc)(mObj,(void*)&mMemberFunctionPointer ,  p1, p2, p3, p4, p5, p6, p7, p8, p9); } bool operator==(const Delegate& otherDelegate)const { return EqualsTo(otherDelegate); } bool operator!=(const Delegate& otherDelegate)const { return !EqualsTo(otherDelegate); } bool operator!()const{return !IsNull();} private: template<typename TFunc> static R FunctorWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9) { return (*(TFunc*)obj)( p1, p2, p3, p4, p5, p6, p7, p8, p9); } static R GlobalWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9) { return ((FunctionType)obj)( p1, p2, p3, p4, p5, p6, p7, p8, p9); } template<typename TObj> static R MemberWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9) { typedef R (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9); return ((TObj*)obj->*(*((large_pointer_to_method*)func)))( p1, p2, p3, p4, p5, p6, p7, p8, p9); } template<typename TObj> static R ConstMemberWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9) { typedef R (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9)const; return ((TObj*)obj->*(*((large_pointer_to_method*)func)))( p1, p2, p3, p4, p5, p6, p7, p8, p9); } }; template<typename R ,  typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9> WEAK_MULTIPLE_DEFINE const Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9)> Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9)>::Empty(0);
template<typename R ,  typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10> class Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)> { public: const static Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)> Empty; void* GetObjectW()const{return mObj;} void SetObject(void* obj){mObj=obj;} private: typedef R (*HelperWrapperType)(void*,void* ,  T1, T2, T3, T4, T5, T6, T7, T8, T9, T10); void* mObj; HelperWrapperType mHelperFunc; Private::MemberFunctionPointer mMemberFunctionPointer; public: typedef R (*FunctionType)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10); Delegate(FunctionType func=0):mObj((void*)func),mHelperFunc(GlobalWrapper){} template<typename TFunc> Delegate(TFunc* func):mObj((void*)func),mHelperFunc(FunctorWrapper<TFunc>){} template<typename TObj> Delegate(TObj* obj,R (TObj::*func)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)):mObj(obj),mHelperFunc(MemberWrapper<TObj>) { typedef void (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10); reinterpret_cast<large_pointer_to_method&>(mMemberFunctionPointer) = reinterpret_cast<large_pointer_to_method&>(func); } template<typename TObj> Delegate(TObj* obj,R (TObj::*func)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)const):mObj(obj),mHelperFunc(ConstMemberWrapper<TObj>) { typedef void (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)const; reinterpret_cast<large_pointer_to_method&>(mMemberFunctionPointer) = reinterpret_cast<large_pointer_to_method&>(func); } ~Delegate(){mObj=0;mHelperFunc=0;} Delegate(const Delegate& otherDelegate){mObj=otherDelegate.mObj;mHelperFunc=otherDelegate.mHelperFunc;mMemberFunctionPointer=otherDelegate.mMemberFunctionPointer;} Delegate& operator=(const Delegate& otherDelegate) { mObj=otherDelegate.mObj; mHelperFunc=otherDelegate.mHelperFunc; mMemberFunctionPointer=otherDelegate.mMemberFunctionPointer; return *this; } bool EqualsTo(const Delegate& otherDelegate)const { return mObj==otherDelegate.mObj &&mHelperFunc==otherDelegate.mHelperFunc &&mMemberFunctionPointer==otherDelegate.mMemberFunctionPointer; } R Invoke( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10)const { return (*mHelperFunc)(mObj,(void*)&mMemberFunctionPointer ,  p1, p2, p3, p4, p5, p6, p7, p8, p9, p10); } bool IsNull()const{return mObj==0||mHelperFunc==0;} bool IsValid()const{return mObj!=0&&mHelperFunc!=0;} public: R operator()( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10)const { return (*mHelperFunc)(mObj,(void*)&mMemberFunctionPointer ,  p1, p2, p3, p4, p5, p6, p7, p8, p9, p10); } bool operator==(const Delegate& otherDelegate)const { return EqualsTo(otherDelegate); } bool operator!=(const Delegate& otherDelegate)const { return !EqualsTo(otherDelegate); } bool operator!()const{return !IsNull();} private: template<typename TFunc> static R FunctorWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10) { return (*(TFunc*)obj)( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10); } static R GlobalWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10) { return ((FunctionType)obj)( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10); } template<typename TObj> static R MemberWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10) { typedef R (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10); return ((TObj*)obj->*(*((large_pointer_to_method*)func)))( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10); } template<typename TObj> static R ConstMemberWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10) { typedef R (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)const; return ((TObj*)obj->*(*((large_pointer_to_method*)func)))( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10); } }; template<typename R ,  typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10> WEAK_MULTIPLE_DEFINE const Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)> Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)>::Empty(0);
template<typename R ,  typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11> class Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11)> { public: const static Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11)> Empty; void* GetObjectW()const{return mObj;} void SetObject(void* obj){mObj=obj;} private: typedef R (*HelperWrapperType)(void*,void* ,  T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11); void* mObj; HelperWrapperType mHelperFunc; Private::MemberFunctionPointer mMemberFunctionPointer; public: typedef R (*FunctionType)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11); Delegate(FunctionType func=0):mObj((void*)func),mHelperFunc(GlobalWrapper){} template<typename TFunc> Delegate(TFunc* func):mObj((void*)func),mHelperFunc(FunctorWrapper<TFunc>){} template<typename TObj> Delegate(TObj* obj,R (TObj::*func)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11)):mObj(obj),mHelperFunc(MemberWrapper<TObj>) { typedef void (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11); reinterpret_cast<large_pointer_to_method&>(mMemberFunctionPointer) = reinterpret_cast<large_pointer_to_method&>(func); } template<typename TObj> Delegate(TObj* obj,R (TObj::*func)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11)const):mObj(obj),mHelperFunc(ConstMemberWrapper<TObj>) { typedef void (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11)const; reinterpret_cast<large_pointer_to_method&>(mMemberFunctionPointer) = reinterpret_cast<large_pointer_to_method&>(func); } ~Delegate(){mObj=0;mHelperFunc=0;} Delegate(const Delegate& otherDelegate){mObj=otherDelegate.mObj;mHelperFunc=otherDelegate.mHelperFunc;mMemberFunctionPointer=otherDelegate.mMemberFunctionPointer;} Delegate& operator=(const Delegate& otherDelegate) { mObj=otherDelegate.mObj; mHelperFunc=otherDelegate.mHelperFunc; mMemberFunctionPointer=otherDelegate.mMemberFunctionPointer; return *this; } bool EqualsTo(const Delegate& otherDelegate)const { return mObj==otherDelegate.mObj &&mHelperFunc==otherDelegate.mHelperFunc &&mMemberFunctionPointer==otherDelegate.mMemberFunctionPointer; } R Invoke( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11)const { return (*mHelperFunc)(mObj,(void*)&mMemberFunctionPointer ,  p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11); } bool IsNull()const{return mObj==0||mHelperFunc==0;} bool IsValid()const{return mObj!=0&&mHelperFunc!=0;} public: R operator()( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11)const { return (*mHelperFunc)(mObj,(void*)&mMemberFunctionPointer ,  p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11); } bool operator==(const Delegate& otherDelegate)const { return EqualsTo(otherDelegate); } bool operator!=(const Delegate& otherDelegate)const { return !EqualsTo(otherDelegate); } bool operator!()const{return !IsNull();} private: template<typename TFunc> static R FunctorWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11) { return (*(TFunc*)obj)( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11); } static R GlobalWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11) { return ((FunctionType)obj)( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11); } template<typename TObj> static R MemberWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11) { typedef R (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11); return ((TObj*)obj->*(*((large_pointer_to_method*)func)))( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11); } template<typename TObj> static R ConstMemberWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11) { typedef R (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11)const; return ((TObj*)obj->*(*((large_pointer_to_method*)func)))( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11); } }; template<typename R ,  typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11> WEAK_MULTIPLE_DEFINE const Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11)> Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11)>::Empty(0);
template<typename R ,  typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12> class Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)> { public: const static Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)> Empty; void* GetObjectW()const{return mObj;} void SetObject(void* obj){mObj=obj;} private: typedef R (*HelperWrapperType)(void*,void* ,  T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12); void* mObj; HelperWrapperType mHelperFunc; Private::MemberFunctionPointer mMemberFunctionPointer; public: typedef R (*FunctionType)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12); Delegate(FunctionType func=0):mObj((void*)func),mHelperFunc(GlobalWrapper){} template<typename TFunc> Delegate(TFunc* func):mObj((void*)func),mHelperFunc(FunctorWrapper<TFunc>){} template<typename TObj> Delegate(TObj* obj,R (TObj::*func)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)):mObj(obj),mHelperFunc(MemberWrapper<TObj>) { typedef void (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12); reinterpret_cast<large_pointer_to_method&>(mMemberFunctionPointer) = reinterpret_cast<large_pointer_to_method&>(func); } template<typename TObj> Delegate(TObj* obj,R (TObj::*func)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)const):mObj(obj),mHelperFunc(ConstMemberWrapper<TObj>) { typedef void (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)const; reinterpret_cast<large_pointer_to_method&>(mMemberFunctionPointer) = reinterpret_cast<large_pointer_to_method&>(func); } ~Delegate(){mObj=0;mHelperFunc=0;} Delegate(const Delegate& otherDelegate){mObj=otherDelegate.mObj;mHelperFunc=otherDelegate.mHelperFunc;mMemberFunctionPointer=otherDelegate.mMemberFunctionPointer;} Delegate& operator=(const Delegate& otherDelegate) { mObj=otherDelegate.mObj; mHelperFunc=otherDelegate.mHelperFunc; mMemberFunctionPointer=otherDelegate.mMemberFunctionPointer; return *this; } bool EqualsTo(const Delegate& otherDelegate)const { return mObj==otherDelegate.mObj &&mHelperFunc==otherDelegate.mHelperFunc &&mMemberFunctionPointer==otherDelegate.mMemberFunctionPointer; } R Invoke( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12)const { return (*mHelperFunc)(mObj,(void*)&mMemberFunctionPointer ,  p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12); } bool IsNull()const{return mObj==0||mHelperFunc==0;} bool IsValid()const{return mObj!=0&&mHelperFunc!=0;} public: R operator()( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12)const { return (*mHelperFunc)(mObj,(void*)&mMemberFunctionPointer ,  p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12); } bool operator==(const Delegate& otherDelegate)const { return EqualsTo(otherDelegate); } bool operator!=(const Delegate& otherDelegate)const { return !EqualsTo(otherDelegate); } bool operator!()const{return !IsNull();} private: template<typename TFunc> static R FunctorWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12) { return (*(TFunc*)obj)( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12); } static R GlobalWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12) { return ((FunctionType)obj)( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12); } template<typename TObj> static R MemberWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12) { typedef R (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12); return ((TObj*)obj->*(*((large_pointer_to_method*)func)))( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12); } template<typename TObj> static R ConstMemberWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12) { typedef R (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)const; return ((TObj*)obj->*(*((large_pointer_to_method*)func)))( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12); } }; template<typename R ,  typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12> WEAK_MULTIPLE_DEFINE const Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)> Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)>::Empty(0);
template<typename R ,  typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13> class Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13)> { public: const static Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13)> Empty; void* GetObjectW()const{return mObj;} void SetObject(void* obj){mObj=obj;} private: typedef R (*HelperWrapperType)(void*,void* ,  T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13); void* mObj; HelperWrapperType mHelperFunc; Private::MemberFunctionPointer mMemberFunctionPointer; public: typedef R (*FunctionType)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13); Delegate(FunctionType func=0):mObj((void*)func),mHelperFunc(GlobalWrapper){} template<typename TFunc> Delegate(TFunc* func):mObj((void*)func),mHelperFunc(FunctorWrapper<TFunc>){} template<typename TObj> Delegate(TObj* obj,R (TObj::*func)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13)):mObj(obj),mHelperFunc(MemberWrapper<TObj>) { typedef void (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13); reinterpret_cast<large_pointer_to_method&>(mMemberFunctionPointer) = reinterpret_cast<large_pointer_to_method&>(func); } template<typename TObj> Delegate(TObj* obj,R (TObj::*func)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13)const):mObj(obj),mHelperFunc(ConstMemberWrapper<TObj>) { typedef void (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13)const; reinterpret_cast<large_pointer_to_method&>(mMemberFunctionPointer) = reinterpret_cast<large_pointer_to_method&>(func); } ~Delegate(){mObj=0;mHelperFunc=0;} Delegate(const Delegate& otherDelegate){mObj=otherDelegate.mObj;mHelperFunc=otherDelegate.mHelperFunc;mMemberFunctionPointer=otherDelegate.mMemberFunctionPointer;} Delegate& operator=(const Delegate& otherDelegate) { mObj=otherDelegate.mObj; mHelperFunc=otherDelegate.mHelperFunc; mMemberFunctionPointer=otherDelegate.mMemberFunctionPointer; return *this; } bool EqualsTo(const Delegate& otherDelegate)const { return mObj==otherDelegate.mObj &&mHelperFunc==otherDelegate.mHelperFunc &&mMemberFunctionPointer==otherDelegate.mMemberFunctionPointer; } R Invoke( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13)const { return (*mHelperFunc)(mObj,(void*)&mMemberFunctionPointer ,  p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13); } bool IsNull()const{return mObj==0||mHelperFunc==0;} bool IsValid()const{return mObj!=0&&mHelperFunc!=0;} public: R operator()( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13)const { return (*mHelperFunc)(mObj,(void*)&mMemberFunctionPointer ,  p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13); } bool operator==(const Delegate& otherDelegate)const { return EqualsTo(otherDelegate); } bool operator!=(const Delegate& otherDelegate)const { return !EqualsTo(otherDelegate); } bool operator!()const{return !IsNull();} private: template<typename TFunc> static R FunctorWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13) { return (*(TFunc*)obj)( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13); } static R GlobalWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13) { return ((FunctionType)obj)( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13); } template<typename TObj> static R MemberWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13) { typedef R (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13); return ((TObj*)obj->*(*((large_pointer_to_method*)func)))( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13); } template<typename TObj> static R ConstMemberWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13) { typedef R (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13)const; return ((TObj*)obj->*(*((large_pointer_to_method*)func)))( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13); } }; template<typename R ,  typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13> WEAK_MULTIPLE_DEFINE const Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13)> Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13)>::Empty(0);
template<typename R ,  typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14> class Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14)> { public: const static Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14)> Empty; void* GetObjectW()const{return mObj;} void SetObject(void* obj){mObj=obj;} private: typedef R (*HelperWrapperType)(void*,void* ,  T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14); void* mObj; HelperWrapperType mHelperFunc; Private::MemberFunctionPointer mMemberFunctionPointer; public: typedef R (*FunctionType)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14); Delegate(FunctionType func=0):mObj((void*)func),mHelperFunc(GlobalWrapper){} template<typename TFunc> Delegate(TFunc* func):mObj((void*)func),mHelperFunc(FunctorWrapper<TFunc>){} template<typename TObj> Delegate(TObj* obj,R (TObj::*func)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14)):mObj(obj),mHelperFunc(MemberWrapper<TObj>) { typedef void (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14); reinterpret_cast<large_pointer_to_method&>(mMemberFunctionPointer) = reinterpret_cast<large_pointer_to_method&>(func); } template<typename TObj> Delegate(TObj* obj,R (TObj::*func)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14)const):mObj(obj),mHelperFunc(ConstMemberWrapper<TObj>) { typedef void (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14)const; reinterpret_cast<large_pointer_to_method&>(mMemberFunctionPointer) = reinterpret_cast<large_pointer_to_method&>(func); } ~Delegate(){mObj=0;mHelperFunc=0;} Delegate(const Delegate& otherDelegate){mObj=otherDelegate.mObj;mHelperFunc=otherDelegate.mHelperFunc;mMemberFunctionPointer=otherDelegate.mMemberFunctionPointer;} Delegate& operator=(const Delegate& otherDelegate) { mObj=otherDelegate.mObj; mHelperFunc=otherDelegate.mHelperFunc; mMemberFunctionPointer=otherDelegate.mMemberFunctionPointer; return *this; } bool EqualsTo(const Delegate& otherDelegate)const { return mObj==otherDelegate.mObj &&mHelperFunc==otherDelegate.mHelperFunc &&mMemberFunctionPointer==otherDelegate.mMemberFunctionPointer; } R Invoke( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14)const { return (*mHelperFunc)(mObj,(void*)&mMemberFunctionPointer ,  p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14); } bool IsNull()const{return mObj==0||mHelperFunc==0;} bool IsValid()const{return mObj!=0&&mHelperFunc!=0;} public: R operator()( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14)const { return (*mHelperFunc)(mObj,(void*)&mMemberFunctionPointer ,  p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14); } bool operator==(const Delegate& otherDelegate)const { return EqualsTo(otherDelegate); } bool operator!=(const Delegate& otherDelegate)const { return !EqualsTo(otherDelegate); } bool operator!()const{return !IsNull();} private: template<typename TFunc> static R FunctorWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14) { return (*(TFunc*)obj)( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14); } static R GlobalWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14) { return ((FunctionType)obj)( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14); } template<typename TObj> static R MemberWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14) { typedef R (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14); return ((TObj*)obj->*(*((large_pointer_to_method*)func)))( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14); } template<typename TObj> static R ConstMemberWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14) { typedef R (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14)const; return ((TObj*)obj->*(*((large_pointer_to_method*)func)))( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14); } }; template<typename R ,  typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14> WEAK_MULTIPLE_DEFINE const Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14)> Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14)>::Empty(0);
template<typename R ,  typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15> class Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15)> { public: const static Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15)> Empty; void* GetObjectW()const{return mObj;} void SetObject(void* obj){mObj=obj;} private: typedef R (*HelperWrapperType)(void*,void* ,  T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15); void* mObj; HelperWrapperType mHelperFunc; Private::MemberFunctionPointer mMemberFunctionPointer; public: typedef R (*FunctionType)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15); Delegate(FunctionType func=0):mObj((void*)func),mHelperFunc(GlobalWrapper){} template<typename TFunc> Delegate(TFunc* func):mObj((void*)func),mHelperFunc(FunctorWrapper<TFunc>){} template<typename TObj> Delegate(TObj* obj,R (TObj::*func)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15)):mObj(obj),mHelperFunc(MemberWrapper<TObj>) { typedef void (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15); reinterpret_cast<large_pointer_to_method&>(mMemberFunctionPointer) = reinterpret_cast<large_pointer_to_method&>(func); } template<typename TObj> Delegate(TObj* obj,R (TObj::*func)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15)const):mObj(obj),mHelperFunc(ConstMemberWrapper<TObj>) { typedef void (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15)const; reinterpret_cast<large_pointer_to_method&>(mMemberFunctionPointer) = reinterpret_cast<large_pointer_to_method&>(func); } ~Delegate(){mObj=0;mHelperFunc=0;} Delegate(const Delegate& otherDelegate){mObj=otherDelegate.mObj;mHelperFunc=otherDelegate.mHelperFunc;mMemberFunctionPointer=otherDelegate.mMemberFunctionPointer;} Delegate& operator=(const Delegate& otherDelegate) { mObj=otherDelegate.mObj; mHelperFunc=otherDelegate.mHelperFunc; mMemberFunctionPointer=otherDelegate.mMemberFunctionPointer; return *this; } bool EqualsTo(const Delegate& otherDelegate)const { return mObj==otherDelegate.mObj &&mHelperFunc==otherDelegate.mHelperFunc &&mMemberFunctionPointer==otherDelegate.mMemberFunctionPointer; } R Invoke( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15)const { return (*mHelperFunc)(mObj,(void*)&mMemberFunctionPointer ,  p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15); } bool IsNull()const{return mObj==0||mHelperFunc==0;} bool IsValid()const{return mObj!=0&&mHelperFunc!=0;} public: R operator()( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15)const { return (*mHelperFunc)(mObj,(void*)&mMemberFunctionPointer ,  p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15); } bool operator==(const Delegate& otherDelegate)const { return EqualsTo(otherDelegate); } bool operator!=(const Delegate& otherDelegate)const { return !EqualsTo(otherDelegate); } bool operator!()const{return !IsNull();} private: template<typename TFunc> static R FunctorWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15) { return (*(TFunc*)obj)( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15); } static R GlobalWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15) { return ((FunctionType)obj)( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15); } template<typename TObj> static R MemberWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15) { typedef R (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15); return ((TObj*)obj->*(*((large_pointer_to_method*)func)))( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15); } template<typename TObj> static R ConstMemberWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15) { typedef R (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15)const; return ((TObj*)obj->*(*((large_pointer_to_method*)func)))( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15); } }; template<typename R ,  typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15> WEAK_MULTIPLE_DEFINE const Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15)> Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15)>::Empty(0);
template<typename R ,  typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16> class Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16)> { public: const static Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16)> Empty; void* GetObjectW()const{return mObj;} void SetObject(void* obj){mObj=obj;} private: typedef R (*HelperWrapperType)(void*,void* ,  T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16); void* mObj; HelperWrapperType mHelperFunc; Private::MemberFunctionPointer mMemberFunctionPointer; public: typedef R (*FunctionType)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16); Delegate(FunctionType func=0):mObj((void*)func),mHelperFunc(GlobalWrapper){} template<typename TFunc> Delegate(TFunc* func):mObj((void*)func),mHelperFunc(FunctorWrapper<TFunc>){} template<typename TObj> Delegate(TObj* obj,R (TObj::*func)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16)):mObj(obj),mHelperFunc(MemberWrapper<TObj>) { typedef void (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16); reinterpret_cast<large_pointer_to_method&>(mMemberFunctionPointer) = reinterpret_cast<large_pointer_to_method&>(func); } template<typename TObj> Delegate(TObj* obj,R (TObj::*func)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16)const):mObj(obj),mHelperFunc(ConstMemberWrapper<TObj>) { typedef void (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16)const; reinterpret_cast<large_pointer_to_method&>(mMemberFunctionPointer) = reinterpret_cast<large_pointer_to_method&>(func); } ~Delegate(){mObj=0;mHelperFunc=0;} Delegate(const Delegate& otherDelegate){mObj=otherDelegate.mObj;mHelperFunc=otherDelegate.mHelperFunc;mMemberFunctionPointer=otherDelegate.mMemberFunctionPointer;} Delegate& operator=(const Delegate& otherDelegate) { mObj=otherDelegate.mObj; mHelperFunc=otherDelegate.mHelperFunc; mMemberFunctionPointer=otherDelegate.mMemberFunctionPointer; return *this; } bool EqualsTo(const Delegate& otherDelegate)const { return mObj==otherDelegate.mObj &&mHelperFunc==otherDelegate.mHelperFunc &&mMemberFunctionPointer==otherDelegate.mMemberFunctionPointer; } R Invoke( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15, T16 p16)const { return (*mHelperFunc)(mObj,(void*)&mMemberFunctionPointer ,  p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16); } bool IsNull()const{return mObj==0||mHelperFunc==0;} bool IsValid()const{return mObj!=0&&mHelperFunc!=0;} public: R operator()( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15, T16 p16)const { return (*mHelperFunc)(mObj,(void*)&mMemberFunctionPointer ,  p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16); } bool operator==(const Delegate& otherDelegate)const { return EqualsTo(otherDelegate); } bool operator!=(const Delegate& otherDelegate)const { return !EqualsTo(otherDelegate); } bool operator!()const{return !IsNull();} private: template<typename TFunc> static R FunctorWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15, T16 p16) { return (*(TFunc*)obj)( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16); } static R GlobalWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15, T16 p16) { return ((FunctionType)obj)( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16); } template<typename TObj> static R MemberWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15, T16 p16) { typedef R (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16); return ((TObj*)obj->*(*((large_pointer_to_method*)func)))( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16); } template<typename TObj> static R ConstMemberWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15, T16 p16) { typedef R (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16)const; return ((TObj*)obj->*(*((large_pointer_to_method*)func)))( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16); } }; template<typename R ,  typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16> WEAK_MULTIPLE_DEFINE const Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16)> Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16)>::Empty(0);
template<typename R ,  typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17> class Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17)> { public: const static Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17)> Empty; void* GetObjectW()const{return mObj;} void SetObject(void* obj){mObj=obj;} private: typedef R (*HelperWrapperType)(void*,void* ,  T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17); void* mObj; HelperWrapperType mHelperFunc; Private::MemberFunctionPointer mMemberFunctionPointer; public: typedef R (*FunctionType)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17); Delegate(FunctionType func=0):mObj((void*)func),mHelperFunc(GlobalWrapper){} template<typename TFunc> Delegate(TFunc* func):mObj((void*)func),mHelperFunc(FunctorWrapper<TFunc>){} template<typename TObj> Delegate(TObj* obj,R (TObj::*func)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17)):mObj(obj),mHelperFunc(MemberWrapper<TObj>) { typedef void (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17); reinterpret_cast<large_pointer_to_method&>(mMemberFunctionPointer) = reinterpret_cast<large_pointer_to_method&>(func); } template<typename TObj> Delegate(TObj* obj,R (TObj::*func)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17)const):mObj(obj),mHelperFunc(ConstMemberWrapper<TObj>) { typedef void (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17)const; reinterpret_cast<large_pointer_to_method&>(mMemberFunctionPointer) = reinterpret_cast<large_pointer_to_method&>(func); } ~Delegate(){mObj=0;mHelperFunc=0;} Delegate(const Delegate& otherDelegate){mObj=otherDelegate.mObj;mHelperFunc=otherDelegate.mHelperFunc;mMemberFunctionPointer=otherDelegate.mMemberFunctionPointer;} Delegate& operator=(const Delegate& otherDelegate) { mObj=otherDelegate.mObj; mHelperFunc=otherDelegate.mHelperFunc; mMemberFunctionPointer=otherDelegate.mMemberFunctionPointer; return *this; } bool EqualsTo(const Delegate& otherDelegate)const { return mObj==otherDelegate.mObj &&mHelperFunc==otherDelegate.mHelperFunc &&mMemberFunctionPointer==otherDelegate.mMemberFunctionPointer; } R Invoke( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15, T16 p16, T17 p17)const { return (*mHelperFunc)(mObj,(void*)&mMemberFunctionPointer ,  p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17); } bool IsNull()const{return mObj==0||mHelperFunc==0;} bool IsValid()const{return mObj!=0&&mHelperFunc!=0;} public: R operator()( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15, T16 p16, T17 p17)const { return (*mHelperFunc)(mObj,(void*)&mMemberFunctionPointer ,  p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17); } bool operator==(const Delegate& otherDelegate)const { return EqualsTo(otherDelegate); } bool operator!=(const Delegate& otherDelegate)const { return !EqualsTo(otherDelegate); } bool operator!()const{return !IsNull();} private: template<typename TFunc> static R FunctorWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15, T16 p16, T17 p17) { return (*(TFunc*)obj)( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17); } static R GlobalWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15, T16 p16, T17 p17) { return ((FunctionType)obj)( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17); } template<typename TObj> static R MemberWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15, T16 p16, T17 p17) { typedef R (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17); return ((TObj*)obj->*(*((large_pointer_to_method*)func)))( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17); } template<typename TObj> static R ConstMemberWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15, T16 p16, T17 p17) { typedef R (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17)const; return ((TObj*)obj->*(*((large_pointer_to_method*)func)))( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17); } }; template<typename R ,  typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17> WEAK_MULTIPLE_DEFINE const Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17)> Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17)>::Empty(0);
template<typename R ,  typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18> class Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18)> { public: const static Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18)> Empty; void* GetObjectW()const{return mObj;} void SetObject(void* obj){mObj=obj;} private: typedef R (*HelperWrapperType)(void*,void* ,  T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18); void* mObj; HelperWrapperType mHelperFunc; Private::MemberFunctionPointer mMemberFunctionPointer; public: typedef R (*FunctionType)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18); Delegate(FunctionType func=0):mObj((void*)func),mHelperFunc(GlobalWrapper){} template<typename TFunc> Delegate(TFunc* func):mObj((void*)func),mHelperFunc(FunctorWrapper<TFunc>){} template<typename TObj> Delegate(TObj* obj,R (TObj::*func)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18)):mObj(obj),mHelperFunc(MemberWrapper<TObj>) { typedef void (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18); reinterpret_cast<large_pointer_to_method&>(mMemberFunctionPointer) = reinterpret_cast<large_pointer_to_method&>(func); } template<typename TObj> Delegate(TObj* obj,R (TObj::*func)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18)const):mObj(obj),mHelperFunc(ConstMemberWrapper<TObj>) { typedef void (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18)const; reinterpret_cast<large_pointer_to_method&>(mMemberFunctionPointer) = reinterpret_cast<large_pointer_to_method&>(func); } ~Delegate(){mObj=0;mHelperFunc=0;} Delegate(const Delegate& otherDelegate){mObj=otherDelegate.mObj;mHelperFunc=otherDelegate.mHelperFunc;mMemberFunctionPointer=otherDelegate.mMemberFunctionPointer;} Delegate& operator=(const Delegate& otherDelegate) { mObj=otherDelegate.mObj; mHelperFunc=otherDelegate.mHelperFunc; mMemberFunctionPointer=otherDelegate.mMemberFunctionPointer; return *this; } bool EqualsTo(const Delegate& otherDelegate)const { return mObj==otherDelegate.mObj &&mHelperFunc==otherDelegate.mHelperFunc &&mMemberFunctionPointer==otherDelegate.mMemberFunctionPointer; } R Invoke( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15, T16 p16, T17 p17, T18 p18)const { return (*mHelperFunc)(mObj,(void*)&mMemberFunctionPointer ,  p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18); } bool IsNull()const{return mObj==0||mHelperFunc==0;} bool IsValid()const{return mObj!=0&&mHelperFunc!=0;} public: R operator()( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15, T16 p16, T17 p17, T18 p18)const { return (*mHelperFunc)(mObj,(void*)&mMemberFunctionPointer ,  p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18); } bool operator==(const Delegate& otherDelegate)const { return EqualsTo(otherDelegate); } bool operator!=(const Delegate& otherDelegate)const { return !EqualsTo(otherDelegate); } bool operator!()const{return !IsNull();} private: template<typename TFunc> static R FunctorWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15, T16 p16, T17 p17, T18 p18) { return (*(TFunc*)obj)( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18); } static R GlobalWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15, T16 p16, T17 p17, T18 p18) { return ((FunctionType)obj)( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18); } template<typename TObj> static R MemberWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15, T16 p16, T17 p17, T18 p18) { typedef R (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18); return ((TObj*)obj->*(*((large_pointer_to_method*)func)))( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18); } template<typename TObj> static R ConstMemberWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15, T16 p16, T17 p17, T18 p18) { typedef R (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18)const; return ((TObj*)obj->*(*((large_pointer_to_method*)func)))( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18); } }; template<typename R ,  typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18> WEAK_MULTIPLE_DEFINE const Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18)> Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18)>::Empty(0);
template<typename R ,  typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19> class Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19)> { public: const static Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19)> Empty; void* GetObjectW()const{return mObj;} void SetObject(void* obj){mObj=obj;} private: typedef R (*HelperWrapperType)(void*,void* ,  T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19); void* mObj; HelperWrapperType mHelperFunc; Private::MemberFunctionPointer mMemberFunctionPointer; public: typedef R (*FunctionType)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19); Delegate(FunctionType func=0):mObj((void*)func),mHelperFunc(GlobalWrapper){} template<typename TFunc> Delegate(TFunc* func):mObj((void*)func),mHelperFunc(FunctorWrapper<TFunc>){} template<typename TObj> Delegate(TObj* obj,R (TObj::*func)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19)):mObj(obj),mHelperFunc(MemberWrapper<TObj>) { typedef void (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19); reinterpret_cast<large_pointer_to_method&>(mMemberFunctionPointer) = reinterpret_cast<large_pointer_to_method&>(func); } template<typename TObj> Delegate(TObj* obj,R (TObj::*func)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19)const):mObj(obj),mHelperFunc(ConstMemberWrapper<TObj>) { typedef void (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19)const; reinterpret_cast<large_pointer_to_method&>(mMemberFunctionPointer) = reinterpret_cast<large_pointer_to_method&>(func); } ~Delegate(){mObj=0;mHelperFunc=0;} Delegate(const Delegate& otherDelegate){mObj=otherDelegate.mObj;mHelperFunc=otherDelegate.mHelperFunc;mMemberFunctionPointer=otherDelegate.mMemberFunctionPointer;} Delegate& operator=(const Delegate& otherDelegate) { mObj=otherDelegate.mObj; mHelperFunc=otherDelegate.mHelperFunc; mMemberFunctionPointer=otherDelegate.mMemberFunctionPointer; return *this; } bool EqualsTo(const Delegate& otherDelegate)const { return mObj==otherDelegate.mObj &&mHelperFunc==otherDelegate.mHelperFunc &&mMemberFunctionPointer==otherDelegate.mMemberFunctionPointer; } R Invoke( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15, T16 p16, T17 p17, T18 p18, T19 p19)const { return (*mHelperFunc)(mObj,(void*)&mMemberFunctionPointer ,  p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19); } bool IsNull()const{return mObj==0||mHelperFunc==0;} bool IsValid()const{return mObj!=0&&mHelperFunc!=0;} public: R operator()( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15, T16 p16, T17 p17, T18 p18, T19 p19)const { return (*mHelperFunc)(mObj,(void*)&mMemberFunctionPointer ,  p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19); } bool operator==(const Delegate& otherDelegate)const { return EqualsTo(otherDelegate); } bool operator!=(const Delegate& otherDelegate)const { return !EqualsTo(otherDelegate); } bool operator!()const{return !IsNull();} private: template<typename TFunc> static R FunctorWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15, T16 p16, T17 p17, T18 p18, T19 p19) { return (*(TFunc*)obj)( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19); } static R GlobalWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15, T16 p16, T17 p17, T18 p18, T19 p19) { return ((FunctionType)obj)( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19); } template<typename TObj> static R MemberWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15, T16 p16, T17 p17, T18 p18, T19 p19) { typedef R (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19); return ((TObj*)obj->*(*((large_pointer_to_method*)func)))( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19); } template<typename TObj> static R ConstMemberWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15, T16 p16, T17 p17, T18 p18, T19 p19) { typedef R (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19)const; return ((TObj*)obj->*(*((large_pointer_to_method*)func)))( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19); } }; template<typename R ,  typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19> WEAK_MULTIPLE_DEFINE const Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19)> Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19)>::Empty(0);
template<typename R ,  typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20> class Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20)> { public: const static Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20)> Empty; void* GetObjectW()const{return mObj;} void SetObject(void* obj){mObj=obj;} private: typedef R (*HelperWrapperType)(void*,void* ,  T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20); void* mObj; HelperWrapperType mHelperFunc; Private::MemberFunctionPointer mMemberFunctionPointer; public: typedef R (*FunctionType)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20); Delegate(FunctionType func=0):mObj((void*)func),mHelperFunc(GlobalWrapper){} template<typename TFunc> Delegate(TFunc* func):mObj((void*)func),mHelperFunc(FunctorWrapper<TFunc>){} template<typename TObj> Delegate(TObj* obj,R (TObj::*func)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20)):mObj(obj),mHelperFunc(MemberWrapper<TObj>) { typedef void (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20); reinterpret_cast<large_pointer_to_method&>(mMemberFunctionPointer) = reinterpret_cast<large_pointer_to_method&>(func); } template<typename TObj> Delegate(TObj* obj,R (TObj::*func)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20)const):mObj(obj),mHelperFunc(ConstMemberWrapper<TObj>) { typedef void (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20)const; reinterpret_cast<large_pointer_to_method&>(mMemberFunctionPointer) = reinterpret_cast<large_pointer_to_method&>(func); } ~Delegate(){mObj=0;mHelperFunc=0;} Delegate(const Delegate& otherDelegate){mObj=otherDelegate.mObj;mHelperFunc=otherDelegate.mHelperFunc;mMemberFunctionPointer=otherDelegate.mMemberFunctionPointer;} Delegate& operator=(const Delegate& otherDelegate) { mObj=otherDelegate.mObj; mHelperFunc=otherDelegate.mHelperFunc; mMemberFunctionPointer=otherDelegate.mMemberFunctionPointer; return *this; } bool EqualsTo(const Delegate& otherDelegate)const { return mObj==otherDelegate.mObj &&mHelperFunc==otherDelegate.mHelperFunc &&mMemberFunctionPointer==otherDelegate.mMemberFunctionPointer; } R Invoke( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15, T16 p16, T17 p17, T18 p18, T19 p19, T20 p20)const { return (*mHelperFunc)(mObj,(void*)&mMemberFunctionPointer ,  p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, p20); } bool IsNull()const{return mObj==0||mHelperFunc==0;} bool IsValid()const{return mObj!=0&&mHelperFunc!=0;} public: R operator()( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15, T16 p16, T17 p17, T18 p18, T19 p19, T20 p20)const { return (*mHelperFunc)(mObj,(void*)&mMemberFunctionPointer ,  p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, p20); } bool operator==(const Delegate& otherDelegate)const { return EqualsTo(otherDelegate); } bool operator!=(const Delegate& otherDelegate)const { return !EqualsTo(otherDelegate); } bool operator!()const{return !IsNull();} private: template<typename TFunc> static R FunctorWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15, T16 p16, T17 p17, T18 p18, T19 p19, T20 p20) { return (*(TFunc*)obj)( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, p20); } static R GlobalWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15, T16 p16, T17 p17, T18 p18, T19 p19, T20 p20) { return ((FunctionType)obj)( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, p20); } template<typename TObj> static R MemberWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15, T16 p16, T17 p17, T18 p18, T19 p19, T20 p20) { typedef R (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20); return ((TObj*)obj->*(*((large_pointer_to_method*)func)))( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, p20); } template<typename TObj> static R ConstMemberWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15, T16 p16, T17 p17, T18 p18, T19 p19, T20 p20) { typedef R (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20)const; return ((TObj*)obj->*(*((large_pointer_to_method*)func)))( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, p20); } }; template<typename R ,  typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20> WEAK_MULTIPLE_DEFINE const Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20)> Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20)>::Empty(0);
template<typename R ,  typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21> class Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21)> { public: const static Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21)> Empty; void* GetObjectW()const{return mObj;} void SetObject(void* obj){mObj=obj;} private: typedef R (*HelperWrapperType)(void*,void* ,  T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21); void* mObj; HelperWrapperType mHelperFunc; Private::MemberFunctionPointer mMemberFunctionPointer; public: typedef R (*FunctionType)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21); Delegate(FunctionType func=0):mObj((void*)func),mHelperFunc(GlobalWrapper){} template<typename TFunc> Delegate(TFunc* func):mObj((void*)func),mHelperFunc(FunctorWrapper<TFunc>){} template<typename TObj> Delegate(TObj* obj,R (TObj::*func)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21)):mObj(obj),mHelperFunc(MemberWrapper<TObj>) { typedef void (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21); reinterpret_cast<large_pointer_to_method&>(mMemberFunctionPointer) = reinterpret_cast<large_pointer_to_method&>(func); } template<typename TObj> Delegate(TObj* obj,R (TObj::*func)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21)const):mObj(obj),mHelperFunc(ConstMemberWrapper<TObj>) { typedef void (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21)const; reinterpret_cast<large_pointer_to_method&>(mMemberFunctionPointer) = reinterpret_cast<large_pointer_to_method&>(func); } ~Delegate(){mObj=0;mHelperFunc=0;} Delegate(const Delegate& otherDelegate){mObj=otherDelegate.mObj;mHelperFunc=otherDelegate.mHelperFunc;mMemberFunctionPointer=otherDelegate.mMemberFunctionPointer;} Delegate& operator=(const Delegate& otherDelegate) { mObj=otherDelegate.mObj; mHelperFunc=otherDelegate.mHelperFunc; mMemberFunctionPointer=otherDelegate.mMemberFunctionPointer; return *this; } bool EqualsTo(const Delegate& otherDelegate)const { return mObj==otherDelegate.mObj &&mHelperFunc==otherDelegate.mHelperFunc &&mMemberFunctionPointer==otherDelegate.mMemberFunctionPointer; } R Invoke( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15, T16 p16, T17 p17, T18 p18, T19 p19, T20 p20, T21 p21)const { return (*mHelperFunc)(mObj,(void*)&mMemberFunctionPointer ,  p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, p20, p21); } bool IsNull()const{return mObj==0||mHelperFunc==0;} bool IsValid()const{return mObj!=0&&mHelperFunc!=0;} public: R operator()( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15, T16 p16, T17 p17, T18 p18, T19 p19, T20 p20, T21 p21)const { return (*mHelperFunc)(mObj,(void*)&mMemberFunctionPointer ,  p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, p20, p21); } bool operator==(const Delegate& otherDelegate)const { return EqualsTo(otherDelegate); } bool operator!=(const Delegate& otherDelegate)const { return !EqualsTo(otherDelegate); } bool operator!()const{return !IsNull();} private: template<typename TFunc> static R FunctorWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15, T16 p16, T17 p17, T18 p18, T19 p19, T20 p20, T21 p21) { return (*(TFunc*)obj)( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, p20, p21); } static R GlobalWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15, T16 p16, T17 p17, T18 p18, T19 p19, T20 p20, T21 p21) { return ((FunctionType)obj)( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, p20, p21); } template<typename TObj> static R MemberWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15, T16 p16, T17 p17, T18 p18, T19 p19, T20 p20, T21 p21) { typedef R (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21); return ((TObj*)obj->*(*((large_pointer_to_method*)func)))( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, p20, p21); } template<typename TObj> static R ConstMemberWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15, T16 p16, T17 p17, T18 p18, T19 p19, T20 p20, T21 p21) { typedef R (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21)const; return ((TObj*)obj->*(*((large_pointer_to_method*)func)))( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, p20, p21); } }; template<typename R ,  typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21> WEAK_MULTIPLE_DEFINE const Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21)> Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21)>::Empty(0);
template<typename R ,  typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22> class Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22)> { public: const static Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22)> Empty; void* GetObjectW()const{return mObj;} void SetObject(void* obj){mObj=obj;} private: typedef R (*HelperWrapperType)(void*,void* ,  T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22); void* mObj; HelperWrapperType mHelperFunc; Private::MemberFunctionPointer mMemberFunctionPointer; public: typedef R (*FunctionType)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22); Delegate(FunctionType func=0):mObj((void*)func),mHelperFunc(GlobalWrapper){} template<typename TFunc> Delegate(TFunc* func):mObj((void*)func),mHelperFunc(FunctorWrapper<TFunc>){} template<typename TObj> Delegate(TObj* obj,R (TObj::*func)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22)):mObj(obj),mHelperFunc(MemberWrapper<TObj>) { typedef void (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22); reinterpret_cast<large_pointer_to_method&>(mMemberFunctionPointer) = reinterpret_cast<large_pointer_to_method&>(func); } template<typename TObj> Delegate(TObj* obj,R (TObj::*func)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22)const):mObj(obj),mHelperFunc(ConstMemberWrapper<TObj>) { typedef void (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22)const; reinterpret_cast<large_pointer_to_method&>(mMemberFunctionPointer) = reinterpret_cast<large_pointer_to_method&>(func); } ~Delegate(){mObj=0;mHelperFunc=0;} Delegate(const Delegate& otherDelegate){mObj=otherDelegate.mObj;mHelperFunc=otherDelegate.mHelperFunc;mMemberFunctionPointer=otherDelegate.mMemberFunctionPointer;} Delegate& operator=(const Delegate& otherDelegate) { mObj=otherDelegate.mObj; mHelperFunc=otherDelegate.mHelperFunc; mMemberFunctionPointer=otherDelegate.mMemberFunctionPointer; return *this; } bool EqualsTo(const Delegate& otherDelegate)const { return mObj==otherDelegate.mObj &&mHelperFunc==otherDelegate.mHelperFunc &&mMemberFunctionPointer==otherDelegate.mMemberFunctionPointer; } R Invoke( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15, T16 p16, T17 p17, T18 p18, T19 p19, T20 p20, T21 p21, T22 p22)const { return (*mHelperFunc)(mObj,(void*)&mMemberFunctionPointer ,  p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, p20, p21, p22); } bool IsNull()const{return mObj==0||mHelperFunc==0;} bool IsValid()const{return mObj!=0&&mHelperFunc!=0;} public: R operator()( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15, T16 p16, T17 p17, T18 p18, T19 p19, T20 p20, T21 p21, T22 p22)const { return (*mHelperFunc)(mObj,(void*)&mMemberFunctionPointer ,  p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, p20, p21, p22); } bool operator==(const Delegate& otherDelegate)const { return EqualsTo(otherDelegate); } bool operator!=(const Delegate& otherDelegate)const { return !EqualsTo(otherDelegate); } bool operator!()const{return !IsNull();} private: template<typename TFunc> static R FunctorWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15, T16 p16, T17 p17, T18 p18, T19 p19, T20 p20, T21 p21, T22 p22) { return (*(TFunc*)obj)( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, p20, p21, p22); } static R GlobalWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15, T16 p16, T17 p17, T18 p18, T19 p19, T20 p20, T21 p21, T22 p22) { return ((FunctionType)obj)( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, p20, p21, p22); } template<typename TObj> static R MemberWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15, T16 p16, T17 p17, T18 p18, T19 p19, T20 p20, T21 p21, T22 p22) { typedef R (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22); return ((TObj*)obj->*(*((large_pointer_to_method*)func)))( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, p20, p21, p22); } template<typename TObj> static R ConstMemberWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15, T16 p16, T17 p17, T18 p18, T19 p19, T20 p20, T21 p21, T22 p22) { typedef R (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22)const; return ((TObj*)obj->*(*((large_pointer_to_method*)func)))( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, p20, p21, p22); } }; template<typename R ,  typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22> WEAK_MULTIPLE_DEFINE const Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22)> Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22)>::Empty(0);
template<typename R ,  typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23> class Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23)> { public: const static Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23)> Empty; void* GetObjectW()const{return mObj;} void SetObject(void* obj){mObj=obj;} private: typedef R (*HelperWrapperType)(void*,void* ,  T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23); void* mObj; HelperWrapperType mHelperFunc; Private::MemberFunctionPointer mMemberFunctionPointer; public: typedef R (*FunctionType)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23); Delegate(FunctionType func=0):mObj((void*)func),mHelperFunc(GlobalWrapper){} template<typename TFunc> Delegate(TFunc* func):mObj((void*)func),mHelperFunc(FunctorWrapper<TFunc>){} template<typename TObj> Delegate(TObj* obj,R (TObj::*func)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23)):mObj(obj),mHelperFunc(MemberWrapper<TObj>) { typedef void (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23); reinterpret_cast<large_pointer_to_method&>(mMemberFunctionPointer) = reinterpret_cast<large_pointer_to_method&>(func); } template<typename TObj> Delegate(TObj* obj,R (TObj::*func)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23)const):mObj(obj),mHelperFunc(ConstMemberWrapper<TObj>) { typedef void (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23)const; reinterpret_cast<large_pointer_to_method&>(mMemberFunctionPointer) = reinterpret_cast<large_pointer_to_method&>(func); } ~Delegate(){mObj=0;mHelperFunc=0;} Delegate(const Delegate& otherDelegate){mObj=otherDelegate.mObj;mHelperFunc=otherDelegate.mHelperFunc;mMemberFunctionPointer=otherDelegate.mMemberFunctionPointer;} Delegate& operator=(const Delegate& otherDelegate) { mObj=otherDelegate.mObj; mHelperFunc=otherDelegate.mHelperFunc; mMemberFunctionPointer=otherDelegate.mMemberFunctionPointer; return *this; } bool EqualsTo(const Delegate& otherDelegate)const { return mObj==otherDelegate.mObj &&mHelperFunc==otherDelegate.mHelperFunc &&mMemberFunctionPointer==otherDelegate.mMemberFunctionPointer; } R Invoke( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15, T16 p16, T17 p17, T18 p18, T19 p19, T20 p20, T21 p21, T22 p22, T23 p23)const { return (*mHelperFunc)(mObj,(void*)&mMemberFunctionPointer ,  p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, p20, p21, p22, p23); } bool IsNull()const{return mObj==0||mHelperFunc==0;} bool IsValid()const{return mObj!=0&&mHelperFunc!=0;} public: R operator()( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15, T16 p16, T17 p17, T18 p18, T19 p19, T20 p20, T21 p21, T22 p22, T23 p23)const { return (*mHelperFunc)(mObj,(void*)&mMemberFunctionPointer ,  p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, p20, p21, p22, p23); } bool operator==(const Delegate& otherDelegate)const { return EqualsTo(otherDelegate); } bool operator!=(const Delegate& otherDelegate)const { return !EqualsTo(otherDelegate); } bool operator!()const{return !IsNull();} private: template<typename TFunc> static R FunctorWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15, T16 p16, T17 p17, T18 p18, T19 p19, T20 p20, T21 p21, T22 p22, T23 p23) { return (*(TFunc*)obj)( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, p20, p21, p22, p23); } static R GlobalWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15, T16 p16, T17 p17, T18 p18, T19 p19, T20 p20, T21 p21, T22 p22, T23 p23) { return ((FunctionType)obj)( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, p20, p21, p22, p23); } template<typename TObj> static R MemberWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15, T16 p16, T17 p17, T18 p18, T19 p19, T20 p20, T21 p21, T22 p22, T23 p23) { typedef R (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23); return ((TObj*)obj->*(*((large_pointer_to_method*)func)))( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, p20, p21, p22, p23); } template<typename TObj> static R ConstMemberWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15, T16 p16, T17 p17, T18 p18, T19 p19, T20 p20, T21 p21, T22 p22, T23 p23) { typedef R (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23)const; return ((TObj*)obj->*(*((large_pointer_to_method*)func)))( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, p20, p21, p22, p23); } }; template<typename R ,  typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23> WEAK_MULTIPLE_DEFINE const Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23)> Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23)>::Empty(0);
template<typename R ,  typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24> class Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24)> { public: const static Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24)> Empty; void* GetObjectW()const{return mObj;} void SetObject(void* obj){mObj=obj;} private: typedef R (*HelperWrapperType)(void*,void* ,  T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24); void* mObj; HelperWrapperType mHelperFunc; Private::MemberFunctionPointer mMemberFunctionPointer; public: typedef R (*FunctionType)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24); Delegate(FunctionType func=0):mObj((void*)func),mHelperFunc(GlobalWrapper){} template<typename TFunc> Delegate(TFunc* func):mObj((void*)func),mHelperFunc(FunctorWrapper<TFunc>){} template<typename TObj> Delegate(TObj* obj,R (TObj::*func)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24)):mObj(obj),mHelperFunc(MemberWrapper<TObj>) { typedef void (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24); reinterpret_cast<large_pointer_to_method&>(mMemberFunctionPointer) = reinterpret_cast<large_pointer_to_method&>(func); } template<typename TObj> Delegate(TObj* obj,R (TObj::*func)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24)const):mObj(obj),mHelperFunc(ConstMemberWrapper<TObj>) { typedef void (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24)const; reinterpret_cast<large_pointer_to_method&>(mMemberFunctionPointer) = reinterpret_cast<large_pointer_to_method&>(func); } ~Delegate(){mObj=0;mHelperFunc=0;} Delegate(const Delegate& otherDelegate){mObj=otherDelegate.mObj;mHelperFunc=otherDelegate.mHelperFunc;mMemberFunctionPointer=otherDelegate.mMemberFunctionPointer;} Delegate& operator=(const Delegate& otherDelegate) { mObj=otherDelegate.mObj; mHelperFunc=otherDelegate.mHelperFunc; mMemberFunctionPointer=otherDelegate.mMemberFunctionPointer; return *this; } bool EqualsTo(const Delegate& otherDelegate)const { return mObj==otherDelegate.mObj &&mHelperFunc==otherDelegate.mHelperFunc &&mMemberFunctionPointer==otherDelegate.mMemberFunctionPointer; } R Invoke( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15, T16 p16, T17 p17, T18 p18, T19 p19, T20 p20, T21 p21, T22 p22, T23 p23, T24 p24)const { return (*mHelperFunc)(mObj,(void*)&mMemberFunctionPointer ,  p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, p20, p21, p22, p23, p24); } bool IsNull()const{return mObj==0||mHelperFunc==0;} bool IsValid()const{return mObj!=0&&mHelperFunc!=0;} public: R operator()( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15, T16 p16, T17 p17, T18 p18, T19 p19, T20 p20, T21 p21, T22 p22, T23 p23, T24 p24)const { return (*mHelperFunc)(mObj,(void*)&mMemberFunctionPointer ,  p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, p20, p21, p22, p23, p24); } bool operator==(const Delegate& otherDelegate)const { return EqualsTo(otherDelegate); } bool operator!=(const Delegate& otherDelegate)const { return !EqualsTo(otherDelegate); } bool operator!()const{return !IsNull();} private: template<typename TFunc> static R FunctorWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15, T16 p16, T17 p17, T18 p18, T19 p19, T20 p20, T21 p21, T22 p22, T23 p23, T24 p24) { return (*(TFunc*)obj)( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, p20, p21, p22, p23, p24); } static R GlobalWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15, T16 p16, T17 p17, T18 p18, T19 p19, T20 p20, T21 p21, T22 p22, T23 p23, T24 p24) { return ((FunctionType)obj)( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, p20, p21, p22, p23, p24); } template<typename TObj> static R MemberWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15, T16 p16, T17 p17, T18 p18, T19 p19, T20 p20, T21 p21, T22 p22, T23 p23, T24 p24) { typedef R (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24); return ((TObj*)obj->*(*((large_pointer_to_method*)func)))( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, p20, p21, p22, p23, p24); } template<typename TObj> static R ConstMemberWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15, T16 p16, T17 p17, T18 p18, T19 p19, T20 p20, T21 p21, T22 p22, T23 p23, T24 p24) { typedef R (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24)const; return ((TObj*)obj->*(*((large_pointer_to_method*)func)))( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, p20, p21, p22, p23, p24); } }; template<typename R ,  typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24> WEAK_MULTIPLE_DEFINE const Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24)> Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24)>::Empty(0);
template<typename R ,  typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25> class Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25)> { public: const static Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25)> Empty; void* GetObjectW()const{return mObj;} void SetObject(void* obj){mObj=obj;} private: typedef R (*HelperWrapperType)(void*,void* ,  T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25); void* mObj; HelperWrapperType mHelperFunc; Private::MemberFunctionPointer mMemberFunctionPointer; public: typedef R (*FunctionType)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25); Delegate(FunctionType func=0):mObj((void*)func),mHelperFunc(GlobalWrapper){} template<typename TFunc> Delegate(TFunc* func):mObj((void*)func),mHelperFunc(FunctorWrapper<TFunc>){} template<typename TObj> Delegate(TObj* obj,R (TObj::*func)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25)):mObj(obj),mHelperFunc(MemberWrapper<TObj>) { typedef void (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25); reinterpret_cast<large_pointer_to_method&>(mMemberFunctionPointer) = reinterpret_cast<large_pointer_to_method&>(func); } template<typename TObj> Delegate(TObj* obj,R (TObj::*func)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25)const):mObj(obj),mHelperFunc(ConstMemberWrapper<TObj>) { typedef void (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25)const; reinterpret_cast<large_pointer_to_method&>(mMemberFunctionPointer) = reinterpret_cast<large_pointer_to_method&>(func); } ~Delegate(){mObj=0;mHelperFunc=0;} Delegate(const Delegate& otherDelegate){mObj=otherDelegate.mObj;mHelperFunc=otherDelegate.mHelperFunc;mMemberFunctionPointer=otherDelegate.mMemberFunctionPointer;} Delegate& operator=(const Delegate& otherDelegate) { mObj=otherDelegate.mObj; mHelperFunc=otherDelegate.mHelperFunc; mMemberFunctionPointer=otherDelegate.mMemberFunctionPointer; return *this; } bool EqualsTo(const Delegate& otherDelegate)const { return mObj==otherDelegate.mObj &&mHelperFunc==otherDelegate.mHelperFunc &&mMemberFunctionPointer==otherDelegate.mMemberFunctionPointer; } R Invoke( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15, T16 p16, T17 p17, T18 p18, T19 p19, T20 p20, T21 p21, T22 p22, T23 p23, T24 p24, T25 p25)const { return (*mHelperFunc)(mObj,(void*)&mMemberFunctionPointer ,  p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, p20, p21, p22, p23, p24, p25); } bool IsNull()const{return mObj==0||mHelperFunc==0;} bool IsValid()const{return mObj!=0&&mHelperFunc!=0;} public: R operator()( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15, T16 p16, T17 p17, T18 p18, T19 p19, T20 p20, T21 p21, T22 p22, T23 p23, T24 p24, T25 p25)const { return (*mHelperFunc)(mObj,(void*)&mMemberFunctionPointer ,  p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, p20, p21, p22, p23, p24, p25); } bool operator==(const Delegate& otherDelegate)const { return EqualsTo(otherDelegate); } bool operator!=(const Delegate& otherDelegate)const { return !EqualsTo(otherDelegate); } bool operator!()const{return !IsNull();} private: template<typename TFunc> static R FunctorWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15, T16 p16, T17 p17, T18 p18, T19 p19, T20 p20, T21 p21, T22 p22, T23 p23, T24 p24, T25 p25) { return (*(TFunc*)obj)( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, p20, p21, p22, p23, p24, p25); } static R GlobalWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15, T16 p16, T17 p17, T18 p18, T19 p19, T20 p20, T21 p21, T22 p22, T23 p23, T24 p24, T25 p25) { return ((FunctionType)obj)( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, p20, p21, p22, p23, p24, p25); } template<typename TObj> static R MemberWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15, T16 p16, T17 p17, T18 p18, T19 p19, T20 p20, T21 p21, T22 p22, T23 p23, T24 p24, T25 p25) { typedef R (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25); return ((TObj*)obj->*(*((large_pointer_to_method*)func)))( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, p20, p21, p22, p23, p24, p25); } template<typename TObj> static R ConstMemberWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15, T16 p16, T17 p17, T18 p18, T19 p19, T20 p20, T21 p21, T22 p22, T23 p23, T24 p24, T25 p25) { typedef R (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25)const; return ((TObj*)obj->*(*((large_pointer_to_method*)func)))( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, p20, p21, p22, p23, p24, p25); } }; template<typename R ,  typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25> WEAK_MULTIPLE_DEFINE const Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25)> Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25)>::Empty(0);
template<typename R ,  typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26> class Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26)> { public: const static Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26)> Empty; void* GetObjectW()const{return mObj;} void SetObject(void* obj){mObj=obj;} private: typedef R (*HelperWrapperType)(void*,void* ,  T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26); void* mObj; HelperWrapperType mHelperFunc; Private::MemberFunctionPointer mMemberFunctionPointer; public: typedef R (*FunctionType)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26); Delegate(FunctionType func=0):mObj((void*)func),mHelperFunc(GlobalWrapper){} template<typename TFunc> Delegate(TFunc* func):mObj((void*)func),mHelperFunc(FunctorWrapper<TFunc>){} template<typename TObj> Delegate(TObj* obj,R (TObj::*func)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26)):mObj(obj),mHelperFunc(MemberWrapper<TObj>) { typedef void (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26); reinterpret_cast<large_pointer_to_method&>(mMemberFunctionPointer) = reinterpret_cast<large_pointer_to_method&>(func); } template<typename TObj> Delegate(TObj* obj,R (TObj::*func)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26)const):mObj(obj),mHelperFunc(ConstMemberWrapper<TObj>) { typedef void (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26)const; reinterpret_cast<large_pointer_to_method&>(mMemberFunctionPointer) = reinterpret_cast<large_pointer_to_method&>(func); } ~Delegate(){mObj=0;mHelperFunc=0;} Delegate(const Delegate& otherDelegate){mObj=otherDelegate.mObj;mHelperFunc=otherDelegate.mHelperFunc;mMemberFunctionPointer=otherDelegate.mMemberFunctionPointer;} Delegate& operator=(const Delegate& otherDelegate) { mObj=otherDelegate.mObj; mHelperFunc=otherDelegate.mHelperFunc; mMemberFunctionPointer=otherDelegate.mMemberFunctionPointer; return *this; } bool EqualsTo(const Delegate& otherDelegate)const { return mObj==otherDelegate.mObj &&mHelperFunc==otherDelegate.mHelperFunc &&mMemberFunctionPointer==otherDelegate.mMemberFunctionPointer; } R Invoke( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15, T16 p16, T17 p17, T18 p18, T19 p19, T20 p20, T21 p21, T22 p22, T23 p23, T24 p24, T25 p25, T26 p26)const { return (*mHelperFunc)(mObj,(void*)&mMemberFunctionPointer ,  p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, p20, p21, p22, p23, p24, p25, p26); } bool IsNull()const{return mObj==0||mHelperFunc==0;} bool IsValid()const{return mObj!=0&&mHelperFunc!=0;} public: R operator()( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15, T16 p16, T17 p17, T18 p18, T19 p19, T20 p20, T21 p21, T22 p22, T23 p23, T24 p24, T25 p25, T26 p26)const { return (*mHelperFunc)(mObj,(void*)&mMemberFunctionPointer ,  p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, p20, p21, p22, p23, p24, p25, p26); } bool operator==(const Delegate& otherDelegate)const { return EqualsTo(otherDelegate); } bool operator!=(const Delegate& otherDelegate)const { return !EqualsTo(otherDelegate); } bool operator!()const{return !IsNull();} private: template<typename TFunc> static R FunctorWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15, T16 p16, T17 p17, T18 p18, T19 p19, T20 p20, T21 p21, T22 p22, T23 p23, T24 p24, T25 p25, T26 p26) { return (*(TFunc*)obj)( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, p20, p21, p22, p23, p24, p25, p26); } static R GlobalWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15, T16 p16, T17 p17, T18 p18, T19 p19, T20 p20, T21 p21, T22 p22, T23 p23, T24 p24, T25 p25, T26 p26) { return ((FunctionType)obj)( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, p20, p21, p22, p23, p24, p25, p26); } template<typename TObj> static R MemberWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15, T16 p16, T17 p17, T18 p18, T19 p19, T20 p20, T21 p21, T22 p22, T23 p23, T24 p24, T25 p25, T26 p26) { typedef R (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26); return ((TObj*)obj->*(*((large_pointer_to_method*)func)))( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, p20, p21, p22, p23, p24, p25, p26); } template<typename TObj> static R ConstMemberWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15, T16 p16, T17 p17, T18 p18, T19 p19, T20 p20, T21 p21, T22 p22, T23 p23, T24 p24, T25 p25, T26 p26) { typedef R (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26)const; return ((TObj*)obj->*(*((large_pointer_to_method*)func)))( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, p20, p21, p22, p23, p24, p25, p26); } }; template<typename R ,  typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26> WEAK_MULTIPLE_DEFINE const Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26)> Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26)>::Empty(0);
template<typename R ,  typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27> class Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27)> { public: const static Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27)> Empty; void* GetObjectW()const{return mObj;} void SetObject(void* obj){mObj=obj;} private: typedef R (*HelperWrapperType)(void*,void* ,  T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27); void* mObj; HelperWrapperType mHelperFunc; Private::MemberFunctionPointer mMemberFunctionPointer; public: typedef R (*FunctionType)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27); Delegate(FunctionType func=0):mObj((void*)func),mHelperFunc(GlobalWrapper){} template<typename TFunc> Delegate(TFunc* func):mObj((void*)func),mHelperFunc(FunctorWrapper<TFunc>){} template<typename TObj> Delegate(TObj* obj,R (TObj::*func)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27)):mObj(obj),mHelperFunc(MemberWrapper<TObj>) { typedef void (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27); reinterpret_cast<large_pointer_to_method&>(mMemberFunctionPointer) = reinterpret_cast<large_pointer_to_method&>(func); } template<typename TObj> Delegate(TObj* obj,R (TObj::*func)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27)const):mObj(obj),mHelperFunc(ConstMemberWrapper<TObj>) { typedef void (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27)const; reinterpret_cast<large_pointer_to_method&>(mMemberFunctionPointer) = reinterpret_cast<large_pointer_to_method&>(func); } ~Delegate(){mObj=0;mHelperFunc=0;} Delegate(const Delegate& otherDelegate){mObj=otherDelegate.mObj;mHelperFunc=otherDelegate.mHelperFunc;mMemberFunctionPointer=otherDelegate.mMemberFunctionPointer;} Delegate& operator=(const Delegate& otherDelegate) { mObj=otherDelegate.mObj; mHelperFunc=otherDelegate.mHelperFunc; mMemberFunctionPointer=otherDelegate.mMemberFunctionPointer; return *this; } bool EqualsTo(const Delegate& otherDelegate)const { return mObj==otherDelegate.mObj &&mHelperFunc==otherDelegate.mHelperFunc &&mMemberFunctionPointer==otherDelegate.mMemberFunctionPointer; } R Invoke( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15, T16 p16, T17 p17, T18 p18, T19 p19, T20 p20, T21 p21, T22 p22, T23 p23, T24 p24, T25 p25, T26 p26, T27 p27)const { return (*mHelperFunc)(mObj,(void*)&mMemberFunctionPointer ,  p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, p20, p21, p22, p23, p24, p25, p26, p27); } bool IsNull()const{return mObj==0||mHelperFunc==0;} bool IsValid()const{return mObj!=0&&mHelperFunc!=0;} public: R operator()( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15, T16 p16, T17 p17, T18 p18, T19 p19, T20 p20, T21 p21, T22 p22, T23 p23, T24 p24, T25 p25, T26 p26, T27 p27)const { return (*mHelperFunc)(mObj,(void*)&mMemberFunctionPointer ,  p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, p20, p21, p22, p23, p24, p25, p26, p27); } bool operator==(const Delegate& otherDelegate)const { return EqualsTo(otherDelegate); } bool operator!=(const Delegate& otherDelegate)const { return !EqualsTo(otherDelegate); } bool operator!()const{return !IsNull();} private: template<typename TFunc> static R FunctorWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15, T16 p16, T17 p17, T18 p18, T19 p19, T20 p20, T21 p21, T22 p22, T23 p23, T24 p24, T25 p25, T26 p26, T27 p27) { return (*(TFunc*)obj)( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, p20, p21, p22, p23, p24, p25, p26, p27); } static R GlobalWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15, T16 p16, T17 p17, T18 p18, T19 p19, T20 p20, T21 p21, T22 p22, T23 p23, T24 p24, T25 p25, T26 p26, T27 p27) { return ((FunctionType)obj)( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, p20, p21, p22, p23, p24, p25, p26, p27); } template<typename TObj> static R MemberWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15, T16 p16, T17 p17, T18 p18, T19 p19, T20 p20, T21 p21, T22 p22, T23 p23, T24 p24, T25 p25, T26 p26, T27 p27) { typedef R (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27); return ((TObj*)obj->*(*((large_pointer_to_method*)func)))( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, p20, p21, p22, p23, p24, p25, p26, p27); } template<typename TObj> static R ConstMemberWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15, T16 p16, T17 p17, T18 p18, T19 p19, T20 p20, T21 p21, T22 p22, T23 p23, T24 p24, T25 p25, T26 p26, T27 p27) { typedef R (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27)const; return ((TObj*)obj->*(*((large_pointer_to_method*)func)))( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, p20, p21, p22, p23, p24, p25, p26, p27); } }; template<typename R ,  typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27> WEAK_MULTIPLE_DEFINE const Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27)> Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27)>::Empty(0);
template<typename R ,  typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27, typename T28> class Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28)> { public: const static Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28)> Empty; void* GetObjectW()const{return mObj;} void SetObject(void* obj){mObj=obj;} private: typedef R (*HelperWrapperType)(void*,void* ,  T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28); void* mObj; HelperWrapperType mHelperFunc; Private::MemberFunctionPointer mMemberFunctionPointer; public: typedef R (*FunctionType)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28); Delegate(FunctionType func=0):mObj((void*)func),mHelperFunc(GlobalWrapper){} template<typename TFunc> Delegate(TFunc* func):mObj((void*)func),mHelperFunc(FunctorWrapper<TFunc>){} template<typename TObj> Delegate(TObj* obj,R (TObj::*func)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28)):mObj(obj),mHelperFunc(MemberWrapper<TObj>) { typedef void (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28); reinterpret_cast<large_pointer_to_method&>(mMemberFunctionPointer) = reinterpret_cast<large_pointer_to_method&>(func); } template<typename TObj> Delegate(TObj* obj,R (TObj::*func)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28)const):mObj(obj),mHelperFunc(ConstMemberWrapper<TObj>) { typedef void (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28)const; reinterpret_cast<large_pointer_to_method&>(mMemberFunctionPointer) = reinterpret_cast<large_pointer_to_method&>(func); } ~Delegate(){mObj=0;mHelperFunc=0;} Delegate(const Delegate& otherDelegate){mObj=otherDelegate.mObj;mHelperFunc=otherDelegate.mHelperFunc;mMemberFunctionPointer=otherDelegate.mMemberFunctionPointer;} Delegate& operator=(const Delegate& otherDelegate) { mObj=otherDelegate.mObj; mHelperFunc=otherDelegate.mHelperFunc; mMemberFunctionPointer=otherDelegate.mMemberFunctionPointer; return *this; } bool EqualsTo(const Delegate& otherDelegate)const { return mObj==otherDelegate.mObj &&mHelperFunc==otherDelegate.mHelperFunc &&mMemberFunctionPointer==otherDelegate.mMemberFunctionPointer; } R Invoke( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15, T16 p16, T17 p17, T18 p18, T19 p19, T20 p20, T21 p21, T22 p22, T23 p23, T24 p24, T25 p25, T26 p26, T27 p27, T28 p28)const { return (*mHelperFunc)(mObj,(void*)&mMemberFunctionPointer ,  p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, p20, p21, p22, p23, p24, p25, p26, p27, p28); } bool IsNull()const{return mObj==0||mHelperFunc==0;} bool IsValid()const{return mObj!=0&&mHelperFunc!=0;} public: R operator()( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15, T16 p16, T17 p17, T18 p18, T19 p19, T20 p20, T21 p21, T22 p22, T23 p23, T24 p24, T25 p25, T26 p26, T27 p27, T28 p28)const { return (*mHelperFunc)(mObj,(void*)&mMemberFunctionPointer ,  p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, p20, p21, p22, p23, p24, p25, p26, p27, p28); } bool operator==(const Delegate& otherDelegate)const { return EqualsTo(otherDelegate); } bool operator!=(const Delegate& otherDelegate)const { return !EqualsTo(otherDelegate); } bool operator!()const{return !IsNull();} private: template<typename TFunc> static R FunctorWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15, T16 p16, T17 p17, T18 p18, T19 p19, T20 p20, T21 p21, T22 p22, T23 p23, T24 p24, T25 p25, T26 p26, T27 p27, T28 p28) { return (*(TFunc*)obj)( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, p20, p21, p22, p23, p24, p25, p26, p27, p28); } static R GlobalWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15, T16 p16, T17 p17, T18 p18, T19 p19, T20 p20, T21 p21, T22 p22, T23 p23, T24 p24, T25 p25, T26 p26, T27 p27, T28 p28) { return ((FunctionType)obj)( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, p20, p21, p22, p23, p24, p25, p26, p27, p28); } template<typename TObj> static R MemberWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15, T16 p16, T17 p17, T18 p18, T19 p19, T20 p20, T21 p21, T22 p22, T23 p23, T24 p24, T25 p25, T26 p26, T27 p27, T28 p28) { typedef R (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28); return ((TObj*)obj->*(*((large_pointer_to_method*)func)))( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, p20, p21, p22, p23, p24, p25, p26, p27, p28); } template<typename TObj> static R ConstMemberWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15, T16 p16, T17 p17, T18 p18, T19 p19, T20 p20, T21 p21, T22 p22, T23 p23, T24 p24, T25 p25, T26 p26, T27 p27, T28 p28) { typedef R (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28)const; return ((TObj*)obj->*(*((large_pointer_to_method*)func)))( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, p20, p21, p22, p23, p24, p25, p26, p27, p28); } }; template<typename R ,  typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27, typename T28> WEAK_MULTIPLE_DEFINE const Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28)> Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28)>::Empty(0);
template<typename R ,  typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27, typename T28, typename T29> class Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29)> { public: const static Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29)> Empty; void* GetObjectW()const{return mObj;} void SetObject(void* obj){mObj=obj;} private: typedef R (*HelperWrapperType)(void*,void* ,  T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29); void* mObj; HelperWrapperType mHelperFunc; Private::MemberFunctionPointer mMemberFunctionPointer; public: typedef R (*FunctionType)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29); Delegate(FunctionType func=0):mObj((void*)func),mHelperFunc(GlobalWrapper){} template<typename TFunc> Delegate(TFunc* func):mObj((void*)func),mHelperFunc(FunctorWrapper<TFunc>){} template<typename TObj> Delegate(TObj* obj,R (TObj::*func)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29)):mObj(obj),mHelperFunc(MemberWrapper<TObj>) { typedef void (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29); reinterpret_cast<large_pointer_to_method&>(mMemberFunctionPointer) = reinterpret_cast<large_pointer_to_method&>(func); } template<typename TObj> Delegate(TObj* obj,R (TObj::*func)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29)const):mObj(obj),mHelperFunc(ConstMemberWrapper<TObj>) { typedef void (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29)const; reinterpret_cast<large_pointer_to_method&>(mMemberFunctionPointer) = reinterpret_cast<large_pointer_to_method&>(func); } ~Delegate(){mObj=0;mHelperFunc=0;} Delegate(const Delegate& otherDelegate){mObj=otherDelegate.mObj;mHelperFunc=otherDelegate.mHelperFunc;mMemberFunctionPointer=otherDelegate.mMemberFunctionPointer;} Delegate& operator=(const Delegate& otherDelegate) { mObj=otherDelegate.mObj; mHelperFunc=otherDelegate.mHelperFunc; mMemberFunctionPointer=otherDelegate.mMemberFunctionPointer; return *this; } bool EqualsTo(const Delegate& otherDelegate)const { return mObj==otherDelegate.mObj &&mHelperFunc==otherDelegate.mHelperFunc &&mMemberFunctionPointer==otherDelegate.mMemberFunctionPointer; } R Invoke( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15, T16 p16, T17 p17, T18 p18, T19 p19, T20 p20, T21 p21, T22 p22, T23 p23, T24 p24, T25 p25, T26 p26, T27 p27, T28 p28, T29 p29)const { return (*mHelperFunc)(mObj,(void*)&mMemberFunctionPointer ,  p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, p20, p21, p22, p23, p24, p25, p26, p27, p28, p29); } bool IsNull()const{return mObj==0||mHelperFunc==0;} bool IsValid()const{return mObj!=0&&mHelperFunc!=0;} public: R operator()( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15, T16 p16, T17 p17, T18 p18, T19 p19, T20 p20, T21 p21, T22 p22, T23 p23, T24 p24, T25 p25, T26 p26, T27 p27, T28 p28, T29 p29)const { return (*mHelperFunc)(mObj,(void*)&mMemberFunctionPointer ,  p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, p20, p21, p22, p23, p24, p25, p26, p27, p28, p29); } bool operator==(const Delegate& otherDelegate)const { return EqualsTo(otherDelegate); } bool operator!=(const Delegate& otherDelegate)const { return !EqualsTo(otherDelegate); } bool operator!()const{return !IsNull();} private: template<typename TFunc> static R FunctorWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15, T16 p16, T17 p17, T18 p18, T19 p19, T20 p20, T21 p21, T22 p22, T23 p23, T24 p24, T25 p25, T26 p26, T27 p27, T28 p28, T29 p29) { return (*(TFunc*)obj)( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, p20, p21, p22, p23, p24, p25, p26, p27, p28, p29); } static R GlobalWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15, T16 p16, T17 p17, T18 p18, T19 p19, T20 p20, T21 p21, T22 p22, T23 p23, T24 p24, T25 p25, T26 p26, T27 p27, T28 p28, T29 p29) { return ((FunctionType)obj)( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, p20, p21, p22, p23, p24, p25, p26, p27, p28, p29); } template<typename TObj> static R MemberWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15, T16 p16, T17 p17, T18 p18, T19 p19, T20 p20, T21 p21, T22 p22, T23 p23, T24 p24, T25 p25, T26 p26, T27 p27, T28 p28, T29 p29) { typedef R (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29); return ((TObj*)obj->*(*((large_pointer_to_method*)func)))( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, p20, p21, p22, p23, p24, p25, p26, p27, p28, p29); } template<typename TObj> static R ConstMemberWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15, T16 p16, T17 p17, T18 p18, T19 p19, T20 p20, T21 p21, T22 p22, T23 p23, T24 p24, T25 p25, T26 p26, T27 p27, T28 p28, T29 p29) { typedef R (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29)const; return ((TObj*)obj->*(*((large_pointer_to_method*)func)))( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, p20, p21, p22, p23, p24, p25, p26, p27, p28, p29); } }; template<typename R ,  typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27, typename T28, typename T29> WEAK_MULTIPLE_DEFINE const Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29)> Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29)>::Empty(0);
template<typename R ,  typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27, typename T28, typename T29, typename T30> class Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30)> { public: const static Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30)> Empty; void* GetObjectW()const{return mObj;} void SetObject(void* obj){mObj=obj;} private: typedef R (*HelperWrapperType)(void*,void* ,  T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30); void* mObj; HelperWrapperType mHelperFunc; Private::MemberFunctionPointer mMemberFunctionPointer; public: typedef R (*FunctionType)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30); Delegate(FunctionType func=0):mObj((void*)func),mHelperFunc(GlobalWrapper){} template<typename TFunc> Delegate(TFunc* func):mObj((void*)func),mHelperFunc(FunctorWrapper<TFunc>){} template<typename TObj> Delegate(TObj* obj,R (TObj::*func)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30)):mObj(obj),mHelperFunc(MemberWrapper<TObj>) { typedef void (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30); reinterpret_cast<large_pointer_to_method&>(mMemberFunctionPointer) = reinterpret_cast<large_pointer_to_method&>(func); } template<typename TObj> Delegate(TObj* obj,R (TObj::*func)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30)const):mObj(obj),mHelperFunc(ConstMemberWrapper<TObj>) { typedef void (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30)const; reinterpret_cast<large_pointer_to_method&>(mMemberFunctionPointer) = reinterpret_cast<large_pointer_to_method&>(func); } ~Delegate(){mObj=0;mHelperFunc=0;} Delegate(const Delegate& otherDelegate){mObj=otherDelegate.mObj;mHelperFunc=otherDelegate.mHelperFunc;mMemberFunctionPointer=otherDelegate.mMemberFunctionPointer;} Delegate& operator=(const Delegate& otherDelegate) { mObj=otherDelegate.mObj; mHelperFunc=otherDelegate.mHelperFunc; mMemberFunctionPointer=otherDelegate.mMemberFunctionPointer; return *this; } bool EqualsTo(const Delegate& otherDelegate)const { return mObj==otherDelegate.mObj &&mHelperFunc==otherDelegate.mHelperFunc &&mMemberFunctionPointer==otherDelegate.mMemberFunctionPointer; } R Invoke( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15, T16 p16, T17 p17, T18 p18, T19 p19, T20 p20, T21 p21, T22 p22, T23 p23, T24 p24, T25 p25, T26 p26, T27 p27, T28 p28, T29 p29, T30 p30)const { return (*mHelperFunc)(mObj,(void*)&mMemberFunctionPointer ,  p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, p20, p21, p22, p23, p24, p25, p26, p27, p28, p29, p30); } bool IsNull()const{return mObj==0||mHelperFunc==0;} bool IsValid()const{return mObj!=0&&mHelperFunc!=0;} public: R operator()( T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15, T16 p16, T17 p17, T18 p18, T19 p19, T20 p20, T21 p21, T22 p22, T23 p23, T24 p24, T25 p25, T26 p26, T27 p27, T28 p28, T29 p29, T30 p30)const { return (*mHelperFunc)(mObj,(void*)&mMemberFunctionPointer ,  p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, p20, p21, p22, p23, p24, p25, p26, p27, p28, p29, p30); } bool operator==(const Delegate& otherDelegate)const { return EqualsTo(otherDelegate); } bool operator!=(const Delegate& otherDelegate)const { return !EqualsTo(otherDelegate); } bool operator!()const{return !IsNull();} private: template<typename TFunc> static R FunctorWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15, T16 p16, T17 p17, T18 p18, T19 p19, T20 p20, T21 p21, T22 p22, T23 p23, T24 p24, T25 p25, T26 p26, T27 p27, T28 p28, T29 p29, T30 p30) { return (*(TFunc*)obj)( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, p20, p21, p22, p23, p24, p25, p26, p27, p28, p29, p30); } static R GlobalWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15, T16 p16, T17 p17, T18 p18, T19 p19, T20 p20, T21 p21, T22 p22, T23 p23, T24 p24, T25 p25, T26 p26, T27 p27, T28 p28, T29 p29, T30 p30) { return ((FunctionType)obj)( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, p20, p21, p22, p23, p24, p25, p26, p27, p28, p29, p30); } template<typename TObj> static R MemberWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15, T16 p16, T17 p17, T18 p18, T19 p19, T20 p20, T21 p21, T22 p22, T23 p23, T24 p24, T25 p25, T26 p26, T27 p27, T28 p28, T29 p29, T30 p30) { typedef R (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30); return ((TObj*)obj->*(*((large_pointer_to_method*)func)))( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, p20, p21, p22, p23, p24, p25, p26, p27, p28, p29, p30); } template<typename TObj> static R ConstMemberWrapper(void * obj,void* func ,  T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15, T16 p16, T17 p17, T18 p18, T19 p19, T20 p20, T21 p21, T22 p22, T23 p23, T24 p24, T25 p25, T26 p26, T27 p27, T28 p28, T29 p29, T30 p30) { typedef R (TObj::*large_pointer_to_method)( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30)const; return ((TObj*)obj->*(*((large_pointer_to_method*)func)))( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, p20, p21, p22, p23, p24, p25, p26, p27, p28, p29, p30); } }; template<typename R ,  typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27, typename T28, typename T29, typename T30> WEAK_MULTIPLE_DEFINE const Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30)> Delegate<R ( T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30)>::Empty(0);
//END_AUTO_GENERATE_DELEGATE
#endif


#undef DEFINE_TEMPLATE_TYPENAME
#undef DEFINE_TEMPLATE_TYPENAME_1

#undef DEFINE_PARAMETER_TYPE_NAME
#undef DEFINE_PARAMETER_TYPE_NAME_1

	//#undef DEFINE_DELGATE_CLASS

//[PRE_DECLARE_BEGIN]
typedef Pattern::Delegate<void()> Action0;
//[PRE_DECLARE_END]
}

MEDUSA_END