// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: AnimationModel.proto

#ifndef PROTOBUF_AnimationModel_2eproto__INCLUDED
#define PROTOBUF_AnimationModel_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "Geometry.pb.h"
#include "FileSystem.pb.h"
// @@protoc_insertion_point(includes)

namespace Medusa {
namespace CoreProto {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_AnimationModel_2eproto();
void protobuf_AssignDesc_AnimationModel_2eproto();
void protobuf_ShutdownFile_AnimationModel_2eproto();

class ComponentInfo;
class ConditionParameter;
class TriggerCondition;
class BlockInfo;
class BlockModel;
class FrameModel;
class AnimationModel;

enum FrameType {
  KeyFrame = 1,
  TweenFrame = 2,
  EmptyFrame = 3
};
bool FrameType_IsValid(int value);
const FrameType FrameType_MIN = KeyFrame;
const FrameType FrameType_MAX = EmptyFrame;
const int FrameType_ARRAYSIZE = FrameType_MAX + 1;

const ::google::protobuf::EnumDescriptor* FrameType_descriptor();
inline const ::std::string& FrameType_Name(FrameType value) {
  return ::google::protobuf::internal::NameOfEnum(
    FrameType_descriptor(), value);
}
inline bool FrameType_Parse(
    const ::std::string& name, FrameType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FrameType>(
    FrameType_descriptor(), name, value);
}
// ===================================================================

class ComponentInfo : public ::google::protobuf::Message {
 public:
  ComponentInfo();
  virtual ~ComponentInfo();

  ComponentInfo(const ComponentInfo& from);

  inline ComponentInfo& operator=(const ComponentInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ComponentInfo& default_instance();

  void Swap(ComponentInfo* other);

  // implements Message ----------------------------------------------

  ComponentInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ComponentInfo& from);
  void MergeFrom(const ComponentInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Medusa.CoreProto.FileId FileID = 1;
  inline bool has_fileid() const;
  inline void clear_fileid();
  static const int kFileIDFieldNumber = 1;
  inline const ::Medusa::CoreProto::FileId& fileid() const;
  inline ::Medusa::CoreProto::FileId* mutable_fileid();
  inline ::Medusa::CoreProto::FileId* release_fileid();
  inline void set_allocated_fileid(::Medusa::CoreProto::FileId* fileid);

  // optional .Medusa.CoreProto.TriggerCondition TriggerCondition = 2;
  inline bool has_triggercondition() const;
  inline void clear_triggercondition();
  static const int kTriggerConditionFieldNumber = 2;
  inline const ::Medusa::CoreProto::TriggerCondition& triggercondition() const;
  inline ::Medusa::CoreProto::TriggerCondition* mutable_triggercondition();
  inline ::Medusa::CoreProto::TriggerCondition* release_triggercondition();
  inline void set_allocated_triggercondition(::Medusa::CoreProto::TriggerCondition* triggercondition);

  // @@protoc_insertion_point(class_scope:Medusa.CoreProto.ComponentInfo)
 private:
  inline void set_has_fileid();
  inline void clear_has_fileid();
  inline void set_has_triggercondition();
  inline void clear_has_triggercondition();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Medusa::CoreProto::FileId* fileid_;
  ::Medusa::CoreProto::TriggerCondition* triggercondition_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_AnimationModel_2eproto();
  friend void protobuf_AssignDesc_AnimationModel_2eproto();
  friend void protobuf_ShutdownFile_AnimationModel_2eproto();

  void InitAsDefaultInstance();
  static ComponentInfo* default_instance_;
};
// -------------------------------------------------------------------

class ConditionParameter : public ::google::protobuf::Message {
 public:
  ConditionParameter();
  virtual ~ConditionParameter();

  ConditionParameter(const ConditionParameter& from);

  inline ConditionParameter& operator=(const ConditionParameter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConditionParameter& default_instance();

  void Swap(ConditionParameter* other);

  // implements Message ----------------------------------------------

  ConditionParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConditionParameter& from);
  void MergeFrom(const ConditionParameter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string Key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // required string Value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:Medusa.CoreProto.ConditionParameter)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* key_;
  ::std::string* value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_AnimationModel_2eproto();
  friend void protobuf_AssignDesc_AnimationModel_2eproto();
  friend void protobuf_ShutdownFile_AnimationModel_2eproto();

  void InitAsDefaultInstance();
  static ConditionParameter* default_instance_;
};
// -------------------------------------------------------------------

class TriggerCondition : public ::google::protobuf::Message {
 public:
  TriggerCondition();
  virtual ~TriggerCondition();

  TriggerCondition(const TriggerCondition& from);

  inline TriggerCondition& operator=(const TriggerCondition& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TriggerCondition& default_instance();

  void Swap(TriggerCondition* other);

  // implements Message ----------------------------------------------

  TriggerCondition* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TriggerCondition& from);
  void MergeFrom(const TriggerCondition& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string EventName = 1;
  inline bool has_eventname() const;
  inline void clear_eventname();
  static const int kEventNameFieldNumber = 1;
  inline const ::std::string& eventname() const;
  inline void set_eventname(const ::std::string& value);
  inline void set_eventname(const char* value);
  inline void set_eventname(const char* value, size_t size);
  inline ::std::string* mutable_eventname();
  inline ::std::string* release_eventname();
  inline void set_allocated_eventname(::std::string* eventname);

  // repeated .Medusa.CoreProto.ConditionParameter Parameters = 2;
  inline int parameters_size() const;
  inline void clear_parameters();
  static const int kParametersFieldNumber = 2;
  inline const ::Medusa::CoreProto::ConditionParameter& parameters(int index) const;
  inline ::Medusa::CoreProto::ConditionParameter* mutable_parameters(int index);
  inline ::Medusa::CoreProto::ConditionParameter* add_parameters();
  inline const ::google::protobuf::RepeatedPtrField< ::Medusa::CoreProto::ConditionParameter >&
      parameters() const;
  inline ::google::protobuf::RepeatedPtrField< ::Medusa::CoreProto::ConditionParameter >*
      mutable_parameters();

  // @@protoc_insertion_point(class_scope:Medusa.CoreProto.TriggerCondition)
 private:
  inline void set_has_eventname();
  inline void clear_has_eventname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* eventname_;
  ::google::protobuf::RepeatedPtrField< ::Medusa::CoreProto::ConditionParameter > parameters_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_AnimationModel_2eproto();
  friend void protobuf_AssignDesc_AnimationModel_2eproto();
  friend void protobuf_ShutdownFile_AnimationModel_2eproto();

  void InitAsDefaultInstance();
  static TriggerCondition* default_instance_;
};
// -------------------------------------------------------------------

class BlockInfo : public ::google::protobuf::Message {
 public:
  BlockInfo();
  virtual ~BlockInfo();

  BlockInfo(const BlockInfo& from);

  inline BlockInfo& operator=(const BlockInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BlockInfo& default_instance();

  void Swap(BlockInfo* other);

  // implements Message ----------------------------------------------

  BlockInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BlockInfo& from);
  void MergeFrom(const BlockInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 ZOrder = 1;
  inline bool has_zorder() const;
  inline void clear_zorder();
  static const int kZOrderFieldNumber = 1;
  inline ::google::protobuf::int32 zorder() const;
  inline void set_zorder(::google::protobuf::int32 value);

  // required .Medusa.CoreProto.PointF Anchor = 2;
  inline bool has_anchor() const;
  inline void clear_anchor();
  static const int kAnchorFieldNumber = 2;
  inline const ::Medusa::CoreProto::PointF& anchor() const;
  inline ::Medusa::CoreProto::PointF* mutable_anchor();
  inline ::Medusa::CoreProto::PointF* release_anchor();
  inline void set_allocated_anchor(::Medusa::CoreProto::PointF* anchor);

  // required .Medusa.CoreProto.PointF Pos = 4;
  inline bool has_pos() const;
  inline void clear_pos();
  static const int kPosFieldNumber = 4;
  inline const ::Medusa::CoreProto::PointF& pos() const;
  inline ::Medusa::CoreProto::PointF* mutable_pos();
  inline ::Medusa::CoreProto::PointF* release_pos();
  inline void set_allocated_pos(::Medusa::CoreProto::PointF* pos);

  // required .Medusa.CoreProto.ScaleF Scale = 6;
  inline bool has_scale() const;
  inline void clear_scale();
  static const int kScaleFieldNumber = 6;
  inline const ::Medusa::CoreProto::ScaleF& scale() const;
  inline ::Medusa::CoreProto::ScaleF* mutable_scale();
  inline ::Medusa::CoreProto::ScaleF* release_scale();
  inline void set_allocated_scale(::Medusa::CoreProto::ScaleF* scale);

  // required .Medusa.CoreProto.PointF Skew = 8;
  inline bool has_skew() const;
  inline void clear_skew();
  static const int kSkewFieldNumber = 8;
  inline const ::Medusa::CoreProto::PointF& skew() const;
  inline ::Medusa::CoreProto::PointF* mutable_skew();
  inline ::Medusa::CoreProto::PointF* release_skew();
  inline void set_allocated_skew(::Medusa::CoreProto::PointF* skew);

  // optional .Medusa.CoreProto.ColorF ColorMultiplier = 10;
  inline bool has_colormultiplier() const;
  inline void clear_colormultiplier();
  static const int kColorMultiplierFieldNumber = 10;
  inline const ::Medusa::CoreProto::ColorF& colormultiplier() const;
  inline ::Medusa::CoreProto::ColorF* mutable_colormultiplier();
  inline ::Medusa::CoreProto::ColorF* release_colormultiplier();
  inline void set_allocated_colormultiplier(::Medusa::CoreProto::ColorF* colormultiplier);

  // optional .Medusa.CoreProto.ColorF ColorOffset = 11;
  inline bool has_coloroffset() const;
  inline void clear_coloroffset();
  static const int kColorOffsetFieldNumber = 11;
  inline const ::Medusa::CoreProto::ColorF& coloroffset() const;
  inline ::Medusa::CoreProto::ColorF* mutable_coloroffset();
  inline ::Medusa::CoreProto::ColorF* release_coloroffset();
  inline void set_allocated_coloroffset(::Medusa::CoreProto::ColorF* coloroffset);

  // optional int32 RenderFlag = 50;
  inline bool has_renderflag() const;
  inline void clear_renderflag();
  static const int kRenderFlagFieldNumber = 50;
  inline ::google::protobuf::int32 renderflag() const;
  inline void set_renderflag(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Medusa.CoreProto.BlockInfo)
 private:
  inline void set_has_zorder();
  inline void clear_has_zorder();
  inline void set_has_anchor();
  inline void clear_has_anchor();
  inline void set_has_pos();
  inline void clear_has_pos();
  inline void set_has_scale();
  inline void clear_has_scale();
  inline void set_has_skew();
  inline void clear_has_skew();
  inline void set_has_colormultiplier();
  inline void clear_has_colormultiplier();
  inline void set_has_coloroffset();
  inline void clear_has_coloroffset();
  inline void set_has_renderflag();
  inline void clear_has_renderflag();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Medusa::CoreProto::PointF* anchor_;
  ::Medusa::CoreProto::PointF* pos_;
  ::Medusa::CoreProto::ScaleF* scale_;
  ::google::protobuf::int32 zorder_;
  ::google::protobuf::int32 renderflag_;
  ::Medusa::CoreProto::PointF* skew_;
  ::Medusa::CoreProto::ColorF* colormultiplier_;
  ::Medusa::CoreProto::ColorF* coloroffset_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_AnimationModel_2eproto();
  friend void protobuf_AssignDesc_AnimationModel_2eproto();
  friend void protobuf_ShutdownFile_AnimationModel_2eproto();

  void InitAsDefaultInstance();
  static BlockInfo* default_instance_;
};
// -------------------------------------------------------------------

class BlockModel : public ::google::protobuf::Message {
 public:
  BlockModel();
  virtual ~BlockModel();

  BlockModel(const BlockModel& from);

  inline BlockModel& operator=(const BlockModel& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BlockModel& default_instance();

  void Swap(BlockModel* other);

  // implements Message ----------------------------------------------

  BlockModel* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BlockModel& from);
  void MergeFrom(const BlockModel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Medusa.CoreProto.FrameType FrameValue = 1;
  inline bool has_framevalue() const;
  inline void clear_framevalue();
  static const int kFrameValueFieldNumber = 1;
  inline ::Medusa::CoreProto::FrameType framevalue() const;
  inline void set_framevalue(::Medusa::CoreProto::FrameType value);

  // optional .Medusa.CoreProto.BlockInfo Info = 2;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 2;
  inline const ::Medusa::CoreProto::BlockInfo& info() const;
  inline ::Medusa::CoreProto::BlockInfo* mutable_info();
  inline ::Medusa::CoreProto::BlockInfo* release_info();
  inline void set_allocated_info(::Medusa::CoreProto::BlockInfo* info);

  // optional uint32 ImageIndex = 3;
  inline bool has_imageindex() const;
  inline void clear_imageindex();
  static const int kImageIndexFieldNumber = 3;
  inline ::google::protobuf::uint32 imageindex() const;
  inline void set_imageindex(::google::protobuf::uint32 value);

  // optional uint32 BlockId = 4;
  inline bool has_blockid() const;
  inline void clear_blockid();
  static const int kBlockIdFieldNumber = 4;
  inline ::google::protobuf::uint32 blockid() const;
  inline void set_blockid(::google::protobuf::uint32 value);

  // optional uint32 PrevKeyFrameIndex = 5;
  inline bool has_prevkeyframeindex() const;
  inline void clear_prevkeyframeindex();
  static const int kPrevKeyFrameIndexFieldNumber = 5;
  inline ::google::protobuf::uint32 prevkeyframeindex() const;
  inline void set_prevkeyframeindex(::google::protobuf::uint32 value);

  // optional uint32 NextKeyFrameIndex = 6;
  inline bool has_nextkeyframeindex() const;
  inline void clear_nextkeyframeindex();
  static const int kNextKeyFrameIndexFieldNumber = 6;
  inline ::google::protobuf::uint32 nextkeyframeindex() const;
  inline void set_nextkeyframeindex(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Medusa.CoreProto.BlockModel)
 private:
  inline void set_has_framevalue();
  inline void clear_has_framevalue();
  inline void set_has_info();
  inline void clear_has_info();
  inline void set_has_imageindex();
  inline void clear_has_imageindex();
  inline void set_has_blockid();
  inline void clear_has_blockid();
  inline void set_has_prevkeyframeindex();
  inline void clear_has_prevkeyframeindex();
  inline void set_has_nextkeyframeindex();
  inline void clear_has_nextkeyframeindex();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Medusa::CoreProto::BlockInfo* info_;
  int framevalue_;
  ::google::protobuf::uint32 imageindex_;
  ::google::protobuf::uint32 blockid_;
  ::google::protobuf::uint32 prevkeyframeindex_;
  ::google::protobuf::uint32 nextkeyframeindex_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_AnimationModel_2eproto();
  friend void protobuf_AssignDesc_AnimationModel_2eproto();
  friend void protobuf_ShutdownFile_AnimationModel_2eproto();

  void InitAsDefaultInstance();
  static BlockModel* default_instance_;
};
// -------------------------------------------------------------------

class FrameModel : public ::google::protobuf::Message {
 public:
  FrameModel();
  virtual ~FrameModel();

  FrameModel(const FrameModel& from);

  inline FrameModel& operator=(const FrameModel& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FrameModel& default_instance();

  void Swap(FrameModel* other);

  // implements Message ----------------------------------------------

  FrameModel* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FrameModel& from);
  void MergeFrom(const FrameModel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Medusa.CoreProto.BlockModel Blocks = 1;
  inline int blocks_size() const;
  inline void clear_blocks();
  static const int kBlocksFieldNumber = 1;
  inline const ::Medusa::CoreProto::BlockModel& blocks(int index) const;
  inline ::Medusa::CoreProto::BlockModel* mutable_blocks(int index);
  inline ::Medusa::CoreProto::BlockModel* add_blocks();
  inline const ::google::protobuf::RepeatedPtrField< ::Medusa::CoreProto::BlockModel >&
      blocks() const;
  inline ::google::protobuf::RepeatedPtrField< ::Medusa::CoreProto::BlockModel >*
      mutable_blocks();

  // @@protoc_insertion_point(class_scope:Medusa.CoreProto.FrameModel)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::Medusa::CoreProto::BlockModel > blocks_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_AnimationModel_2eproto();
  friend void protobuf_AssignDesc_AnimationModel_2eproto();
  friend void protobuf_ShutdownFile_AnimationModel_2eproto();

  void InitAsDefaultInstance();
  static FrameModel* default_instance_;
};
// -------------------------------------------------------------------

class AnimationModel : public ::google::protobuf::Message {
 public:
  AnimationModel();
  virtual ~AnimationModel();

  AnimationModel(const AnimationModel& from);

  inline AnimationModel& operator=(const AnimationModel& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AnimationModel& default_instance();

  void Swap(AnimationModel* other);

  // implements Message ----------------------------------------------

  AnimationModel* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AnimationModel& from);
  void MergeFrom(const AnimationModel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 FrameRate = 1;
  inline bool has_framerate() const;
  inline void clear_framerate();
  static const int kFrameRateFieldNumber = 1;
  inline ::google::protobuf::uint32 framerate() const;
  inline void set_framerate(::google::protobuf::uint32 value);

  // repeated .Medusa.CoreProto.ComponentInfo Components = 2;
  inline int components_size() const;
  inline void clear_components();
  static const int kComponentsFieldNumber = 2;
  inline const ::Medusa::CoreProto::ComponentInfo& components(int index) const;
  inline ::Medusa::CoreProto::ComponentInfo* mutable_components(int index);
  inline ::Medusa::CoreProto::ComponentInfo* add_components();
  inline const ::google::protobuf::RepeatedPtrField< ::Medusa::CoreProto::ComponentInfo >&
      components() const;
  inline ::google::protobuf::RepeatedPtrField< ::Medusa::CoreProto::ComponentInfo >*
      mutable_components();

  // repeated .Medusa.CoreProto.FrameModel Frames = 3;
  inline int frames_size() const;
  inline void clear_frames();
  static const int kFramesFieldNumber = 3;
  inline const ::Medusa::CoreProto::FrameModel& frames(int index) const;
  inline ::Medusa::CoreProto::FrameModel* mutable_frames(int index);
  inline ::Medusa::CoreProto::FrameModel* add_frames();
  inline const ::google::protobuf::RepeatedPtrField< ::Medusa::CoreProto::FrameModel >&
      frames() const;
  inline ::google::protobuf::RepeatedPtrField< ::Medusa::CoreProto::FrameModel >*
      mutable_frames();

  // required .Medusa.CoreProto.SizeF ModelSize = 4;
  inline bool has_modelsize() const;
  inline void clear_modelsize();
  static const int kModelSizeFieldNumber = 4;
  inline const ::Medusa::CoreProto::SizeF& modelsize() const;
  inline ::Medusa::CoreProto::SizeF* mutable_modelsize();
  inline ::Medusa::CoreProto::SizeF* release_modelsize();
  inline void set_allocated_modelsize(::Medusa::CoreProto::SizeF* modelsize);

  // @@protoc_insertion_point(class_scope:Medusa.CoreProto.AnimationModel)
 private:
  inline void set_has_framerate();
  inline void clear_has_framerate();
  inline void set_has_modelsize();
  inline void clear_has_modelsize();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::Medusa::CoreProto::ComponentInfo > components_;
  ::google::protobuf::RepeatedPtrField< ::Medusa::CoreProto::FrameModel > frames_;
  ::Medusa::CoreProto::SizeF* modelsize_;
  ::google::protobuf::uint32 framerate_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_AnimationModel_2eproto();
  friend void protobuf_AssignDesc_AnimationModel_2eproto();
  friend void protobuf_ShutdownFile_AnimationModel_2eproto();

  void InitAsDefaultInstance();
  static AnimationModel* default_instance_;
};
// ===================================================================


// ===================================================================

// ComponentInfo

// required .Medusa.CoreProto.FileId FileID = 1;
inline bool ComponentInfo::has_fileid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ComponentInfo::set_has_fileid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ComponentInfo::clear_has_fileid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ComponentInfo::clear_fileid() {
  if (fileid_ != NULL) fileid_->::Medusa::CoreProto::FileId::Clear();
  clear_has_fileid();
}
inline const ::Medusa::CoreProto::FileId& ComponentInfo::fileid() const {
  return fileid_ != NULL ? *fileid_ : *default_instance_->fileid_;
}
inline ::Medusa::CoreProto::FileId* ComponentInfo::mutable_fileid() {
  set_has_fileid();
  if (fileid_ == NULL) fileid_ = new ::Medusa::CoreProto::FileId;
  return fileid_;
}
inline ::Medusa::CoreProto::FileId* ComponentInfo::release_fileid() {
  clear_has_fileid();
  ::Medusa::CoreProto::FileId* temp = fileid_;
  fileid_ = NULL;
  return temp;
}
inline void ComponentInfo::set_allocated_fileid(::Medusa::CoreProto::FileId* fileid) {
  delete fileid_;
  fileid_ = fileid;
  if (fileid) {
    set_has_fileid();
  } else {
    clear_has_fileid();
  }
}

// optional .Medusa.CoreProto.TriggerCondition TriggerCondition = 2;
inline bool ComponentInfo::has_triggercondition() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ComponentInfo::set_has_triggercondition() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ComponentInfo::clear_has_triggercondition() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ComponentInfo::clear_triggercondition() {
  if (triggercondition_ != NULL) triggercondition_->::Medusa::CoreProto::TriggerCondition::Clear();
  clear_has_triggercondition();
}
inline const ::Medusa::CoreProto::TriggerCondition& ComponentInfo::triggercondition() const {
  return triggercondition_ != NULL ? *triggercondition_ : *default_instance_->triggercondition_;
}
inline ::Medusa::CoreProto::TriggerCondition* ComponentInfo::mutable_triggercondition() {
  set_has_triggercondition();
  if (triggercondition_ == NULL) triggercondition_ = new ::Medusa::CoreProto::TriggerCondition;
  return triggercondition_;
}
inline ::Medusa::CoreProto::TriggerCondition* ComponentInfo::release_triggercondition() {
  clear_has_triggercondition();
  ::Medusa::CoreProto::TriggerCondition* temp = triggercondition_;
  triggercondition_ = NULL;
  return temp;
}
inline void ComponentInfo::set_allocated_triggercondition(::Medusa::CoreProto::TriggerCondition* triggercondition) {
  delete triggercondition_;
  triggercondition_ = triggercondition;
  if (triggercondition) {
    set_has_triggercondition();
  } else {
    clear_has_triggercondition();
  }
}

// -------------------------------------------------------------------

// ConditionParameter

// required string Key = 1;
inline bool ConditionParameter::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConditionParameter::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConditionParameter::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConditionParameter::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& ConditionParameter::key() const {
  return *key_;
}
inline void ConditionParameter::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void ConditionParameter::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void ConditionParameter::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ConditionParameter::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* ConditionParameter::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ConditionParameter::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string Value = 2;
inline bool ConditionParameter::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConditionParameter::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConditionParameter::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConditionParameter::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& ConditionParameter::value() const {
  return *value_;
}
inline void ConditionParameter::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void ConditionParameter::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void ConditionParameter::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ConditionParameter::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* ConditionParameter::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ConditionParameter::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TriggerCondition

// required string EventName = 1;
inline bool TriggerCondition::has_eventname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TriggerCondition::set_has_eventname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TriggerCondition::clear_has_eventname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TriggerCondition::clear_eventname() {
  if (eventname_ != &::google::protobuf::internal::kEmptyString) {
    eventname_->clear();
  }
  clear_has_eventname();
}
inline const ::std::string& TriggerCondition::eventname() const {
  return *eventname_;
}
inline void TriggerCondition::set_eventname(const ::std::string& value) {
  set_has_eventname();
  if (eventname_ == &::google::protobuf::internal::kEmptyString) {
    eventname_ = new ::std::string;
  }
  eventname_->assign(value);
}
inline void TriggerCondition::set_eventname(const char* value) {
  set_has_eventname();
  if (eventname_ == &::google::protobuf::internal::kEmptyString) {
    eventname_ = new ::std::string;
  }
  eventname_->assign(value);
}
inline void TriggerCondition::set_eventname(const char* value, size_t size) {
  set_has_eventname();
  if (eventname_ == &::google::protobuf::internal::kEmptyString) {
    eventname_ = new ::std::string;
  }
  eventname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TriggerCondition::mutable_eventname() {
  set_has_eventname();
  if (eventname_ == &::google::protobuf::internal::kEmptyString) {
    eventname_ = new ::std::string;
  }
  return eventname_;
}
inline ::std::string* TriggerCondition::release_eventname() {
  clear_has_eventname();
  if (eventname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = eventname_;
    eventname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TriggerCondition::set_allocated_eventname(::std::string* eventname) {
  if (eventname_ != &::google::protobuf::internal::kEmptyString) {
    delete eventname_;
  }
  if (eventname) {
    set_has_eventname();
    eventname_ = eventname;
  } else {
    clear_has_eventname();
    eventname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .Medusa.CoreProto.ConditionParameter Parameters = 2;
inline int TriggerCondition::parameters_size() const {
  return parameters_.size();
}
inline void TriggerCondition::clear_parameters() {
  parameters_.Clear();
}
inline const ::Medusa::CoreProto::ConditionParameter& TriggerCondition::parameters(int index) const {
  return parameters_.Get(index);
}
inline ::Medusa::CoreProto::ConditionParameter* TriggerCondition::mutable_parameters(int index) {
  return parameters_.Mutable(index);
}
inline ::Medusa::CoreProto::ConditionParameter* TriggerCondition::add_parameters() {
  return parameters_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Medusa::CoreProto::ConditionParameter >&
TriggerCondition::parameters() const {
  return parameters_;
}
inline ::google::protobuf::RepeatedPtrField< ::Medusa::CoreProto::ConditionParameter >*
TriggerCondition::mutable_parameters() {
  return &parameters_;
}

// -------------------------------------------------------------------

// BlockInfo

// required int32 ZOrder = 1;
inline bool BlockInfo::has_zorder() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BlockInfo::set_has_zorder() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BlockInfo::clear_has_zorder() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BlockInfo::clear_zorder() {
  zorder_ = 0;
  clear_has_zorder();
}
inline ::google::protobuf::int32 BlockInfo::zorder() const {
  return zorder_;
}
inline void BlockInfo::set_zorder(::google::protobuf::int32 value) {
  set_has_zorder();
  zorder_ = value;
}

// required .Medusa.CoreProto.PointF Anchor = 2;
inline bool BlockInfo::has_anchor() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BlockInfo::set_has_anchor() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BlockInfo::clear_has_anchor() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BlockInfo::clear_anchor() {
  if (anchor_ != NULL) anchor_->::Medusa::CoreProto::PointF::Clear();
  clear_has_anchor();
}
inline const ::Medusa::CoreProto::PointF& BlockInfo::anchor() const {
  return anchor_ != NULL ? *anchor_ : *default_instance_->anchor_;
}
inline ::Medusa::CoreProto::PointF* BlockInfo::mutable_anchor() {
  set_has_anchor();
  if (anchor_ == NULL) anchor_ = new ::Medusa::CoreProto::PointF;
  return anchor_;
}
inline ::Medusa::CoreProto::PointF* BlockInfo::release_anchor() {
  clear_has_anchor();
  ::Medusa::CoreProto::PointF* temp = anchor_;
  anchor_ = NULL;
  return temp;
}
inline void BlockInfo::set_allocated_anchor(::Medusa::CoreProto::PointF* anchor) {
  delete anchor_;
  anchor_ = anchor;
  if (anchor) {
    set_has_anchor();
  } else {
    clear_has_anchor();
  }
}

// required .Medusa.CoreProto.PointF Pos = 4;
inline bool BlockInfo::has_pos() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BlockInfo::set_has_pos() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BlockInfo::clear_has_pos() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BlockInfo::clear_pos() {
  if (pos_ != NULL) pos_->::Medusa::CoreProto::PointF::Clear();
  clear_has_pos();
}
inline const ::Medusa::CoreProto::PointF& BlockInfo::pos() const {
  return pos_ != NULL ? *pos_ : *default_instance_->pos_;
}
inline ::Medusa::CoreProto::PointF* BlockInfo::mutable_pos() {
  set_has_pos();
  if (pos_ == NULL) pos_ = new ::Medusa::CoreProto::PointF;
  return pos_;
}
inline ::Medusa::CoreProto::PointF* BlockInfo::release_pos() {
  clear_has_pos();
  ::Medusa::CoreProto::PointF* temp = pos_;
  pos_ = NULL;
  return temp;
}
inline void BlockInfo::set_allocated_pos(::Medusa::CoreProto::PointF* pos) {
  delete pos_;
  pos_ = pos;
  if (pos) {
    set_has_pos();
  } else {
    clear_has_pos();
  }
}

// required .Medusa.CoreProto.ScaleF Scale = 6;
inline bool BlockInfo::has_scale() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BlockInfo::set_has_scale() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BlockInfo::clear_has_scale() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BlockInfo::clear_scale() {
  if (scale_ != NULL) scale_->::Medusa::CoreProto::ScaleF::Clear();
  clear_has_scale();
}
inline const ::Medusa::CoreProto::ScaleF& BlockInfo::scale() const {
  return scale_ != NULL ? *scale_ : *default_instance_->scale_;
}
inline ::Medusa::CoreProto::ScaleF* BlockInfo::mutable_scale() {
  set_has_scale();
  if (scale_ == NULL) scale_ = new ::Medusa::CoreProto::ScaleF;
  return scale_;
}
inline ::Medusa::CoreProto::ScaleF* BlockInfo::release_scale() {
  clear_has_scale();
  ::Medusa::CoreProto::ScaleF* temp = scale_;
  scale_ = NULL;
  return temp;
}
inline void BlockInfo::set_allocated_scale(::Medusa::CoreProto::ScaleF* scale) {
  delete scale_;
  scale_ = scale;
  if (scale) {
    set_has_scale();
  } else {
    clear_has_scale();
  }
}

// required .Medusa.CoreProto.PointF Skew = 8;
inline bool BlockInfo::has_skew() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BlockInfo::set_has_skew() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BlockInfo::clear_has_skew() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BlockInfo::clear_skew() {
  if (skew_ != NULL) skew_->::Medusa::CoreProto::PointF::Clear();
  clear_has_skew();
}
inline const ::Medusa::CoreProto::PointF& BlockInfo::skew() const {
  return skew_ != NULL ? *skew_ : *default_instance_->skew_;
}
inline ::Medusa::CoreProto::PointF* BlockInfo::mutable_skew() {
  set_has_skew();
  if (skew_ == NULL) skew_ = new ::Medusa::CoreProto::PointF;
  return skew_;
}
inline ::Medusa::CoreProto::PointF* BlockInfo::release_skew() {
  clear_has_skew();
  ::Medusa::CoreProto::PointF* temp = skew_;
  skew_ = NULL;
  return temp;
}
inline void BlockInfo::set_allocated_skew(::Medusa::CoreProto::PointF* skew) {
  delete skew_;
  skew_ = skew;
  if (skew) {
    set_has_skew();
  } else {
    clear_has_skew();
  }
}

// optional .Medusa.CoreProto.ColorF ColorMultiplier = 10;
inline bool BlockInfo::has_colormultiplier() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BlockInfo::set_has_colormultiplier() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BlockInfo::clear_has_colormultiplier() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BlockInfo::clear_colormultiplier() {
  if (colormultiplier_ != NULL) colormultiplier_->::Medusa::CoreProto::ColorF::Clear();
  clear_has_colormultiplier();
}
inline const ::Medusa::CoreProto::ColorF& BlockInfo::colormultiplier() const {
  return colormultiplier_ != NULL ? *colormultiplier_ : *default_instance_->colormultiplier_;
}
inline ::Medusa::CoreProto::ColorF* BlockInfo::mutable_colormultiplier() {
  set_has_colormultiplier();
  if (colormultiplier_ == NULL) colormultiplier_ = new ::Medusa::CoreProto::ColorF;
  return colormultiplier_;
}
inline ::Medusa::CoreProto::ColorF* BlockInfo::release_colormultiplier() {
  clear_has_colormultiplier();
  ::Medusa::CoreProto::ColorF* temp = colormultiplier_;
  colormultiplier_ = NULL;
  return temp;
}
inline void BlockInfo::set_allocated_colormultiplier(::Medusa::CoreProto::ColorF* colormultiplier) {
  delete colormultiplier_;
  colormultiplier_ = colormultiplier;
  if (colormultiplier) {
    set_has_colormultiplier();
  } else {
    clear_has_colormultiplier();
  }
}

// optional .Medusa.CoreProto.ColorF ColorOffset = 11;
inline bool BlockInfo::has_coloroffset() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BlockInfo::set_has_coloroffset() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BlockInfo::clear_has_coloroffset() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BlockInfo::clear_coloroffset() {
  if (coloroffset_ != NULL) coloroffset_->::Medusa::CoreProto::ColorF::Clear();
  clear_has_coloroffset();
}
inline const ::Medusa::CoreProto::ColorF& BlockInfo::coloroffset() const {
  return coloroffset_ != NULL ? *coloroffset_ : *default_instance_->coloroffset_;
}
inline ::Medusa::CoreProto::ColorF* BlockInfo::mutable_coloroffset() {
  set_has_coloroffset();
  if (coloroffset_ == NULL) coloroffset_ = new ::Medusa::CoreProto::ColorF;
  return coloroffset_;
}
inline ::Medusa::CoreProto::ColorF* BlockInfo::release_coloroffset() {
  clear_has_coloroffset();
  ::Medusa::CoreProto::ColorF* temp = coloroffset_;
  coloroffset_ = NULL;
  return temp;
}
inline void BlockInfo::set_allocated_coloroffset(::Medusa::CoreProto::ColorF* coloroffset) {
  delete coloroffset_;
  coloroffset_ = coloroffset;
  if (coloroffset) {
    set_has_coloroffset();
  } else {
    clear_has_coloroffset();
  }
}

// optional int32 RenderFlag = 50;
inline bool BlockInfo::has_renderflag() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void BlockInfo::set_has_renderflag() {
  _has_bits_[0] |= 0x00000080u;
}
inline void BlockInfo::clear_has_renderflag() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void BlockInfo::clear_renderflag() {
  renderflag_ = 0;
  clear_has_renderflag();
}
inline ::google::protobuf::int32 BlockInfo::renderflag() const {
  return renderflag_;
}
inline void BlockInfo::set_renderflag(::google::protobuf::int32 value) {
  set_has_renderflag();
  renderflag_ = value;
}

// -------------------------------------------------------------------

// BlockModel

// required .Medusa.CoreProto.FrameType FrameValue = 1;
inline bool BlockModel::has_framevalue() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BlockModel::set_has_framevalue() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BlockModel::clear_has_framevalue() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BlockModel::clear_framevalue() {
  framevalue_ = 1;
  clear_has_framevalue();
}
inline ::Medusa::CoreProto::FrameType BlockModel::framevalue() const {
  return static_cast< ::Medusa::CoreProto::FrameType >(framevalue_);
}
inline void BlockModel::set_framevalue(::Medusa::CoreProto::FrameType value) {
  assert(::Medusa::CoreProto::FrameType_IsValid(value));
  set_has_framevalue();
  framevalue_ = value;
}

// optional .Medusa.CoreProto.BlockInfo Info = 2;
inline bool BlockModel::has_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BlockModel::set_has_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BlockModel::clear_has_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BlockModel::clear_info() {
  if (info_ != NULL) info_->::Medusa::CoreProto::BlockInfo::Clear();
  clear_has_info();
}
inline const ::Medusa::CoreProto::BlockInfo& BlockModel::info() const {
  return info_ != NULL ? *info_ : *default_instance_->info_;
}
inline ::Medusa::CoreProto::BlockInfo* BlockModel::mutable_info() {
  set_has_info();
  if (info_ == NULL) info_ = new ::Medusa::CoreProto::BlockInfo;
  return info_;
}
inline ::Medusa::CoreProto::BlockInfo* BlockModel::release_info() {
  clear_has_info();
  ::Medusa::CoreProto::BlockInfo* temp = info_;
  info_ = NULL;
  return temp;
}
inline void BlockModel::set_allocated_info(::Medusa::CoreProto::BlockInfo* info) {
  delete info_;
  info_ = info;
  if (info) {
    set_has_info();
  } else {
    clear_has_info();
  }
}

// optional uint32 ImageIndex = 3;
inline bool BlockModel::has_imageindex() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BlockModel::set_has_imageindex() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BlockModel::clear_has_imageindex() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BlockModel::clear_imageindex() {
  imageindex_ = 0u;
  clear_has_imageindex();
}
inline ::google::protobuf::uint32 BlockModel::imageindex() const {
  return imageindex_;
}
inline void BlockModel::set_imageindex(::google::protobuf::uint32 value) {
  set_has_imageindex();
  imageindex_ = value;
}

// optional uint32 BlockId = 4;
inline bool BlockModel::has_blockid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BlockModel::set_has_blockid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BlockModel::clear_has_blockid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BlockModel::clear_blockid() {
  blockid_ = 0u;
  clear_has_blockid();
}
inline ::google::protobuf::uint32 BlockModel::blockid() const {
  return blockid_;
}
inline void BlockModel::set_blockid(::google::protobuf::uint32 value) {
  set_has_blockid();
  blockid_ = value;
}

// optional uint32 PrevKeyFrameIndex = 5;
inline bool BlockModel::has_prevkeyframeindex() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BlockModel::set_has_prevkeyframeindex() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BlockModel::clear_has_prevkeyframeindex() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BlockModel::clear_prevkeyframeindex() {
  prevkeyframeindex_ = 0u;
  clear_has_prevkeyframeindex();
}
inline ::google::protobuf::uint32 BlockModel::prevkeyframeindex() const {
  return prevkeyframeindex_;
}
inline void BlockModel::set_prevkeyframeindex(::google::protobuf::uint32 value) {
  set_has_prevkeyframeindex();
  prevkeyframeindex_ = value;
}

// optional uint32 NextKeyFrameIndex = 6;
inline bool BlockModel::has_nextkeyframeindex() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BlockModel::set_has_nextkeyframeindex() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BlockModel::clear_has_nextkeyframeindex() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BlockModel::clear_nextkeyframeindex() {
  nextkeyframeindex_ = 0u;
  clear_has_nextkeyframeindex();
}
inline ::google::protobuf::uint32 BlockModel::nextkeyframeindex() const {
  return nextkeyframeindex_;
}
inline void BlockModel::set_nextkeyframeindex(::google::protobuf::uint32 value) {
  set_has_nextkeyframeindex();
  nextkeyframeindex_ = value;
}

// -------------------------------------------------------------------

// FrameModel

// repeated .Medusa.CoreProto.BlockModel Blocks = 1;
inline int FrameModel::blocks_size() const {
  return blocks_.size();
}
inline void FrameModel::clear_blocks() {
  blocks_.Clear();
}
inline const ::Medusa::CoreProto::BlockModel& FrameModel::blocks(int index) const {
  return blocks_.Get(index);
}
inline ::Medusa::CoreProto::BlockModel* FrameModel::mutable_blocks(int index) {
  return blocks_.Mutable(index);
}
inline ::Medusa::CoreProto::BlockModel* FrameModel::add_blocks() {
  return blocks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Medusa::CoreProto::BlockModel >&
FrameModel::blocks() const {
  return blocks_;
}
inline ::google::protobuf::RepeatedPtrField< ::Medusa::CoreProto::BlockModel >*
FrameModel::mutable_blocks() {
  return &blocks_;
}

// -------------------------------------------------------------------

// AnimationModel

// required uint32 FrameRate = 1;
inline bool AnimationModel::has_framerate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AnimationModel::set_has_framerate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AnimationModel::clear_has_framerate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AnimationModel::clear_framerate() {
  framerate_ = 0u;
  clear_has_framerate();
}
inline ::google::protobuf::uint32 AnimationModel::framerate() const {
  return framerate_;
}
inline void AnimationModel::set_framerate(::google::protobuf::uint32 value) {
  set_has_framerate();
  framerate_ = value;
}

// repeated .Medusa.CoreProto.ComponentInfo Components = 2;
inline int AnimationModel::components_size() const {
  return components_.size();
}
inline void AnimationModel::clear_components() {
  components_.Clear();
}
inline const ::Medusa::CoreProto::ComponentInfo& AnimationModel::components(int index) const {
  return components_.Get(index);
}
inline ::Medusa::CoreProto::ComponentInfo* AnimationModel::mutable_components(int index) {
  return components_.Mutable(index);
}
inline ::Medusa::CoreProto::ComponentInfo* AnimationModel::add_components() {
  return components_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Medusa::CoreProto::ComponentInfo >&
AnimationModel::components() const {
  return components_;
}
inline ::google::protobuf::RepeatedPtrField< ::Medusa::CoreProto::ComponentInfo >*
AnimationModel::mutable_components() {
  return &components_;
}

// repeated .Medusa.CoreProto.FrameModel Frames = 3;
inline int AnimationModel::frames_size() const {
  return frames_.size();
}
inline void AnimationModel::clear_frames() {
  frames_.Clear();
}
inline const ::Medusa::CoreProto::FrameModel& AnimationModel::frames(int index) const {
  return frames_.Get(index);
}
inline ::Medusa::CoreProto::FrameModel* AnimationModel::mutable_frames(int index) {
  return frames_.Mutable(index);
}
inline ::Medusa::CoreProto::FrameModel* AnimationModel::add_frames() {
  return frames_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Medusa::CoreProto::FrameModel >&
AnimationModel::frames() const {
  return frames_;
}
inline ::google::protobuf::RepeatedPtrField< ::Medusa::CoreProto::FrameModel >*
AnimationModel::mutable_frames() {
  return &frames_;
}

// required .Medusa.CoreProto.SizeF ModelSize = 4;
inline bool AnimationModel::has_modelsize() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AnimationModel::set_has_modelsize() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AnimationModel::clear_has_modelsize() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AnimationModel::clear_modelsize() {
  if (modelsize_ != NULL) modelsize_->::Medusa::CoreProto::SizeF::Clear();
  clear_has_modelsize();
}
inline const ::Medusa::CoreProto::SizeF& AnimationModel::modelsize() const {
  return modelsize_ != NULL ? *modelsize_ : *default_instance_->modelsize_;
}
inline ::Medusa::CoreProto::SizeF* AnimationModel::mutable_modelsize() {
  set_has_modelsize();
  if (modelsize_ == NULL) modelsize_ = new ::Medusa::CoreProto::SizeF;
  return modelsize_;
}
inline ::Medusa::CoreProto::SizeF* AnimationModel::release_modelsize() {
  clear_has_modelsize();
  ::Medusa::CoreProto::SizeF* temp = modelsize_;
  modelsize_ = NULL;
  return temp;
}
inline void AnimationModel::set_allocated_modelsize(::Medusa::CoreProto::SizeF* modelsize) {
  delete modelsize_;
  modelsize_ = modelsize;
  if (modelsize) {
    set_has_modelsize();
  } else {
    clear_has_modelsize();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace CoreProto
}  // namespace Medusa

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Medusa::CoreProto::FrameType>() {
  return ::Medusa::CoreProto::FrameType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_AnimationModel_2eproto__INCLUDED
