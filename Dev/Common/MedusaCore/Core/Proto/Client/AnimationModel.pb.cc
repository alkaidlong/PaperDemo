// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: AnimationModel.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "AnimationModel.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace Medusa {
namespace CoreProto {

namespace {

const ::google::protobuf::Descriptor* ComponentInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ComponentInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* ConditionParameter_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ConditionParameter_reflection_ = NULL;
const ::google::protobuf::Descriptor* TriggerCondition_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TriggerCondition_reflection_ = NULL;
const ::google::protobuf::Descriptor* BlockInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  BlockInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* BlockModel_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  BlockModel_reflection_ = NULL;
const ::google::protobuf::Descriptor* FrameModel_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  FrameModel_reflection_ = NULL;
const ::google::protobuf::Descriptor* AnimationModel_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AnimationModel_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* FrameType_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_AnimationModel_2eproto() {
  protobuf_AddDesc_AnimationModel_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "AnimationModel.proto");
  GOOGLE_CHECK(file != NULL);
  ComponentInfo_descriptor_ = file->message_type(0);
  static const int ComponentInfo_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ComponentInfo, fileid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ComponentInfo, triggercondition_),
  };
  ComponentInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ComponentInfo_descriptor_,
      ComponentInfo::default_instance_,
      ComponentInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ComponentInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ComponentInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ComponentInfo));
  ConditionParameter_descriptor_ = file->message_type(1);
  static const int ConditionParameter_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ConditionParameter, key_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ConditionParameter, value_),
  };
  ConditionParameter_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ConditionParameter_descriptor_,
      ConditionParameter::default_instance_,
      ConditionParameter_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ConditionParameter, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ConditionParameter, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ConditionParameter));
  TriggerCondition_descriptor_ = file->message_type(2);
  static const int TriggerCondition_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TriggerCondition, eventname_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TriggerCondition, parameters_),
  };
  TriggerCondition_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TriggerCondition_descriptor_,
      TriggerCondition::default_instance_,
      TriggerCondition_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TriggerCondition, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TriggerCondition, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TriggerCondition));
  BlockInfo_descriptor_ = file->message_type(3);
  static const int BlockInfo_offsets_[8] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BlockInfo, zorder_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BlockInfo, anchor_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BlockInfo, pos_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BlockInfo, scale_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BlockInfo, skew_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BlockInfo, colormultiplier_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BlockInfo, coloroffset_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BlockInfo, renderflag_),
  };
  BlockInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      BlockInfo_descriptor_,
      BlockInfo::default_instance_,
      BlockInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BlockInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BlockInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(BlockInfo));
  BlockModel_descriptor_ = file->message_type(4);
  static const int BlockModel_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BlockModel, framevalue_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BlockModel, info_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BlockModel, imageindex_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BlockModel, blockid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BlockModel, prevkeyframeindex_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BlockModel, nextkeyframeindex_),
  };
  BlockModel_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      BlockModel_descriptor_,
      BlockModel::default_instance_,
      BlockModel_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BlockModel, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BlockModel, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(BlockModel));
  FrameModel_descriptor_ = file->message_type(5);
  static const int FrameModel_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameModel, blocks_),
  };
  FrameModel_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      FrameModel_descriptor_,
      FrameModel::default_instance_,
      FrameModel_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameModel, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameModel, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(FrameModel));
  AnimationModel_descriptor_ = file->message_type(6);
  static const int AnimationModel_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AnimationModel, framerate_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AnimationModel, components_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AnimationModel, frames_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AnimationModel, modelsize_),
  };
  AnimationModel_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AnimationModel_descriptor_,
      AnimationModel::default_instance_,
      AnimationModel_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AnimationModel, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AnimationModel, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AnimationModel));
  FrameType_descriptor_ = file->enum_type(0);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_AnimationModel_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ComponentInfo_descriptor_, &ComponentInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ConditionParameter_descriptor_, &ConditionParameter::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TriggerCondition_descriptor_, &TriggerCondition::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    BlockInfo_descriptor_, &BlockInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    BlockModel_descriptor_, &BlockModel::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    FrameModel_descriptor_, &FrameModel::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AnimationModel_descriptor_, &AnimationModel::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_AnimationModel_2eproto() {
  delete ComponentInfo::default_instance_;
  delete ComponentInfo_reflection_;
  delete ConditionParameter::default_instance_;
  delete ConditionParameter_reflection_;
  delete TriggerCondition::default_instance_;
  delete TriggerCondition_reflection_;
  delete BlockInfo::default_instance_;
  delete BlockInfo_reflection_;
  delete BlockModel::default_instance_;
  delete BlockModel_reflection_;
  delete FrameModel::default_instance_;
  delete FrameModel_reflection_;
  delete AnimationModel::default_instance_;
  delete AnimationModel_reflection_;
}

void protobuf_AddDesc_AnimationModel_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::Medusa::CoreProto::protobuf_AddDesc_Geometry_2eproto();
  ::Medusa::CoreProto::protobuf_AddDesc_FileSystem_2eproto();
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\024AnimationModel.proto\022\020Medusa.CoreProto"
    "\032\016Geometry.proto\032\020FileSystem.proto\"w\n\rCo"
    "mponentInfo\022(\n\006FileID\030\001 \002(\0132\030.Medusa.Cor"
    "eProto.FileId\022<\n\020TriggerCondition\030\002 \001(\0132"
    "\".Medusa.CoreProto.TriggerCondition\"0\n\022C"
    "onditionParameter\022\013\n\003Key\030\001 \002(\t\022\r\n\005Value\030"
    "\002 \002(\t\"_\n\020TriggerCondition\022\021\n\tEventName\030\001"
    " \002(\t\0228\n\nParameters\030\002 \003(\0132$.Medusa.CorePr"
    "oto.ConditionParameter\"\263\002\n\tBlockInfo\022\016\n\006"
    "ZOrder\030\001 \002(\005\022(\n\006Anchor\030\002 \002(\0132\030.Medusa.Co"
    "reProto.PointF\022%\n\003Pos\030\004 \002(\0132\030.Medusa.Cor"
    "eProto.PointF\022\'\n\005Scale\030\006 \002(\0132\030.Medusa.Co"
    "reProto.ScaleF\022&\n\004Skew\030\010 \002(\0132\030.Medusa.Co"
    "reProto.PointF\0221\n\017ColorMultiplier\030\n \001(\0132"
    "\030.Medusa.CoreProto.ColorF\022-\n\013ColorOffset"
    "\030\013 \001(\0132\030.Medusa.CoreProto.ColorF\022\022\n\nRend"
    "erFlag\0302 \001(\005\"\303\001\n\nBlockModel\022/\n\nFrameValu"
    "e\030\001 \002(\0162\033.Medusa.CoreProto.FrameType\022)\n\004"
    "Info\030\002 \001(\0132\033.Medusa.CoreProto.BlockInfo\022"
    "\022\n\nImageIndex\030\003 \001(\r\022\017\n\007BlockId\030\004 \001(\r\022\031\n\021"
    "PrevKeyFrameIndex\030\005 \001(\r\022\031\n\021NextKeyFrameI"
    "ndex\030\006 \001(\r\":\n\nFrameModel\022,\n\006Blocks\030\001 \003(\013"
    "2\034.Medusa.CoreProto.BlockModel\"\262\001\n\016Anima"
    "tionModel\022\021\n\tFrameRate\030\001 \002(\r\0223\n\nComponen"
    "ts\030\002 \003(\0132\037.Medusa.CoreProto.ComponentInf"
    "o\022,\n\006Frames\030\003 \003(\0132\034.Medusa.CoreProto.Fra"
    "meModel\022*\n\tModelSize\030\004 \002(\0132\027.Medusa.Core"
    "Proto.SizeF*9\n\tFrameType\022\014\n\010KeyFrame\020\001\022\016"
    "\n\nTweenFrame\020\002\022\016\n\nEmptyFrame\020\003", 1150);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "AnimationModel.proto", &protobuf_RegisterTypes);
  ComponentInfo::default_instance_ = new ComponentInfo();
  ConditionParameter::default_instance_ = new ConditionParameter();
  TriggerCondition::default_instance_ = new TriggerCondition();
  BlockInfo::default_instance_ = new BlockInfo();
  BlockModel::default_instance_ = new BlockModel();
  FrameModel::default_instance_ = new FrameModel();
  AnimationModel::default_instance_ = new AnimationModel();
  ComponentInfo::default_instance_->InitAsDefaultInstance();
  ConditionParameter::default_instance_->InitAsDefaultInstance();
  TriggerCondition::default_instance_->InitAsDefaultInstance();
  BlockInfo::default_instance_->InitAsDefaultInstance();
  BlockModel::default_instance_->InitAsDefaultInstance();
  FrameModel::default_instance_->InitAsDefaultInstance();
  AnimationModel::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_AnimationModel_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_AnimationModel_2eproto {
  StaticDescriptorInitializer_AnimationModel_2eproto() {
    protobuf_AddDesc_AnimationModel_2eproto();
  }
} static_descriptor_initializer_AnimationModel_2eproto_;
const ::google::protobuf::EnumDescriptor* FrameType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FrameType_descriptor_;
}
bool FrameType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#ifndef _MSC_VER
const int ComponentInfo::kFileIDFieldNumber;
const int ComponentInfo::kTriggerConditionFieldNumber;
#endif  // !_MSC_VER

ComponentInfo::ComponentInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ComponentInfo::InitAsDefaultInstance() {
  fileid_ = const_cast< ::Medusa::CoreProto::FileId*>(&::Medusa::CoreProto::FileId::default_instance());
  triggercondition_ = const_cast< ::Medusa::CoreProto::TriggerCondition*>(&::Medusa::CoreProto::TriggerCondition::default_instance());
}

ComponentInfo::ComponentInfo(const ComponentInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ComponentInfo::SharedCtor() {
  _cached_size_ = 0;
  fileid_ = NULL;
  triggercondition_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ComponentInfo::~ComponentInfo() {
  SharedDtor();
}

void ComponentInfo::SharedDtor() {
  if (this != default_instance_) {
    delete fileid_;
    delete triggercondition_;
  }
}

void ComponentInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ComponentInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ComponentInfo_descriptor_;
}

const ComponentInfo& ComponentInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_AnimationModel_2eproto();
  return *default_instance_;
}

ComponentInfo* ComponentInfo::default_instance_ = NULL;

ComponentInfo* ComponentInfo::New() const {
  return new ComponentInfo;
}

void ComponentInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_fileid()) {
      if (fileid_ != NULL) fileid_->::Medusa::CoreProto::FileId::Clear();
    }
    if (has_triggercondition()) {
      if (triggercondition_ != NULL) triggercondition_->::Medusa::CoreProto::TriggerCondition::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ComponentInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .Medusa.CoreProto.FileId FileID = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_fileid()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_TriggerCondition;
        break;
      }

      // optional .Medusa.CoreProto.TriggerCondition TriggerCondition = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_TriggerCondition:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_triggercondition()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ComponentInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .Medusa.CoreProto.FileId FileID = 1;
  if (has_fileid()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->fileid(), output);
  }

  // optional .Medusa.CoreProto.TriggerCondition TriggerCondition = 2;
  if (has_triggercondition()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->triggercondition(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ComponentInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .Medusa.CoreProto.FileId FileID = 1;
  if (has_fileid()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->fileid(), target);
  }

  // optional .Medusa.CoreProto.TriggerCondition TriggerCondition = 2;
  if (has_triggercondition()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->triggercondition(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ComponentInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .Medusa.CoreProto.FileId FileID = 1;
    if (has_fileid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->fileid());
    }

    // optional .Medusa.CoreProto.TriggerCondition TriggerCondition = 2;
    if (has_triggercondition()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->triggercondition());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ComponentInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ComponentInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ComponentInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ComponentInfo::MergeFrom(const ComponentInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_fileid()) {
      mutable_fileid()->::Medusa::CoreProto::FileId::MergeFrom(from.fileid());
    }
    if (from.has_triggercondition()) {
      mutable_triggercondition()->::Medusa::CoreProto::TriggerCondition::MergeFrom(from.triggercondition());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ComponentInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ComponentInfo::CopyFrom(const ComponentInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ComponentInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_fileid()) {
    if (!this->fileid().IsInitialized()) return false;
  }
  if (has_triggercondition()) {
    if (!this->triggercondition().IsInitialized()) return false;
  }
  return true;
}

void ComponentInfo::Swap(ComponentInfo* other) {
  if (other != this) {
    std::swap(fileid_, other->fileid_);
    std::swap(triggercondition_, other->triggercondition_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ComponentInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ComponentInfo_descriptor_;
  metadata.reflection = ComponentInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ConditionParameter::kKeyFieldNumber;
const int ConditionParameter::kValueFieldNumber;
#endif  // !_MSC_VER

ConditionParameter::ConditionParameter()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ConditionParameter::InitAsDefaultInstance() {
}

ConditionParameter::ConditionParameter(const ConditionParameter& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ConditionParameter::SharedCtor() {
  _cached_size_ = 0;
  key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ConditionParameter::~ConditionParameter() {
  SharedDtor();
}

void ConditionParameter::SharedDtor() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (this != default_instance_) {
  }
}

void ConditionParameter::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ConditionParameter::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ConditionParameter_descriptor_;
}

const ConditionParameter& ConditionParameter::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_AnimationModel_2eproto();
  return *default_instance_;
}

ConditionParameter* ConditionParameter::default_instance_ = NULL;

ConditionParameter* ConditionParameter::New() const {
  return new ConditionParameter;
}

void ConditionParameter::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_key()) {
      if (key_ != &::google::protobuf::internal::kEmptyString) {
        key_->clear();
      }
    }
    if (has_value()) {
      if (value_ != &::google::protobuf::internal::kEmptyString) {
        value_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ConditionParameter::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string Key = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_key()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->key().data(), this->key().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_Value;
        break;
      }

      // required string Value = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Value:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_value()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->value().data(), this->value().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ConditionParameter::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string Key = 1;
  if (has_key()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->key().data(), this->key().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->key(), output);
  }

  // required string Value = 2;
  if (has_value()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->value().data(), this->value().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->value(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ConditionParameter::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string Key = 1;
  if (has_key()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->key().data(), this->key().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->key(), target);
  }

  // required string Value = 2;
  if (has_value()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->value().data(), this->value().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->value(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ConditionParameter::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string Key = 1;
    if (has_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->key());
    }

    // required string Value = 2;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->value());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ConditionParameter::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ConditionParameter* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ConditionParameter*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ConditionParameter::MergeFrom(const ConditionParameter& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_key()) {
      set_key(from.key());
    }
    if (from.has_value()) {
      set_value(from.value());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ConditionParameter::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ConditionParameter::CopyFrom(const ConditionParameter& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConditionParameter::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void ConditionParameter::Swap(ConditionParameter* other) {
  if (other != this) {
    std::swap(key_, other->key_);
    std::swap(value_, other->value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ConditionParameter::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ConditionParameter_descriptor_;
  metadata.reflection = ConditionParameter_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TriggerCondition::kEventNameFieldNumber;
const int TriggerCondition::kParametersFieldNumber;
#endif  // !_MSC_VER

TriggerCondition::TriggerCondition()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void TriggerCondition::InitAsDefaultInstance() {
}

TriggerCondition::TriggerCondition(const TriggerCondition& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void TriggerCondition::SharedCtor() {
  _cached_size_ = 0;
  eventname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TriggerCondition::~TriggerCondition() {
  SharedDtor();
}

void TriggerCondition::SharedDtor() {
  if (eventname_ != &::google::protobuf::internal::kEmptyString) {
    delete eventname_;
  }
  if (this != default_instance_) {
  }
}

void TriggerCondition::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TriggerCondition::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TriggerCondition_descriptor_;
}

const TriggerCondition& TriggerCondition::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_AnimationModel_2eproto();
  return *default_instance_;
}

TriggerCondition* TriggerCondition::default_instance_ = NULL;

TriggerCondition* TriggerCondition::New() const {
  return new TriggerCondition;
}

void TriggerCondition::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_eventname()) {
      if (eventname_ != &::google::protobuf::internal::kEmptyString) {
        eventname_->clear();
      }
    }
  }
  parameters_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TriggerCondition::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string EventName = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_eventname()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->eventname().data(), this->eventname().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_Parameters;
        break;
      }

      // repeated .Medusa.CoreProto.ConditionParameter Parameters = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Parameters:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_parameters()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_Parameters;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TriggerCondition::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string EventName = 1;
  if (has_eventname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->eventname().data(), this->eventname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->eventname(), output);
  }

  // repeated .Medusa.CoreProto.ConditionParameter Parameters = 2;
  for (int i = 0; i < this->parameters_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->parameters(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* TriggerCondition::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string EventName = 1;
  if (has_eventname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->eventname().data(), this->eventname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->eventname(), target);
  }

  // repeated .Medusa.CoreProto.ConditionParameter Parameters = 2;
  for (int i = 0; i < this->parameters_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->parameters(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int TriggerCondition::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string EventName = 1;
    if (has_eventname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->eventname());
    }

  }
  // repeated .Medusa.CoreProto.ConditionParameter Parameters = 2;
  total_size += 1 * this->parameters_size();
  for (int i = 0; i < this->parameters_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->parameters(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TriggerCondition::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TriggerCondition* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TriggerCondition*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TriggerCondition::MergeFrom(const TriggerCondition& from) {
  GOOGLE_CHECK_NE(&from, this);
  parameters_.MergeFrom(from.parameters_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_eventname()) {
      set_eventname(from.eventname());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TriggerCondition::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TriggerCondition::CopyFrom(const TriggerCondition& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TriggerCondition::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  for (int i = 0; i < parameters_size(); i++) {
    if (!this->parameters(i).IsInitialized()) return false;
  }
  return true;
}

void TriggerCondition::Swap(TriggerCondition* other) {
  if (other != this) {
    std::swap(eventname_, other->eventname_);
    parameters_.Swap(&other->parameters_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TriggerCondition::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TriggerCondition_descriptor_;
  metadata.reflection = TriggerCondition_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int BlockInfo::kZOrderFieldNumber;
const int BlockInfo::kAnchorFieldNumber;
const int BlockInfo::kPosFieldNumber;
const int BlockInfo::kScaleFieldNumber;
const int BlockInfo::kSkewFieldNumber;
const int BlockInfo::kColorMultiplierFieldNumber;
const int BlockInfo::kColorOffsetFieldNumber;
const int BlockInfo::kRenderFlagFieldNumber;
#endif  // !_MSC_VER

BlockInfo::BlockInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void BlockInfo::InitAsDefaultInstance() {
  anchor_ = const_cast< ::Medusa::CoreProto::PointF*>(&::Medusa::CoreProto::PointF::default_instance());
  pos_ = const_cast< ::Medusa::CoreProto::PointF*>(&::Medusa::CoreProto::PointF::default_instance());
  scale_ = const_cast< ::Medusa::CoreProto::ScaleF*>(&::Medusa::CoreProto::ScaleF::default_instance());
  skew_ = const_cast< ::Medusa::CoreProto::PointF*>(&::Medusa::CoreProto::PointF::default_instance());
  colormultiplier_ = const_cast< ::Medusa::CoreProto::ColorF*>(&::Medusa::CoreProto::ColorF::default_instance());
  coloroffset_ = const_cast< ::Medusa::CoreProto::ColorF*>(&::Medusa::CoreProto::ColorF::default_instance());
}

BlockInfo::BlockInfo(const BlockInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void BlockInfo::SharedCtor() {
  _cached_size_ = 0;
  zorder_ = 0;
  anchor_ = NULL;
  pos_ = NULL;
  scale_ = NULL;
  skew_ = NULL;
  colormultiplier_ = NULL;
  coloroffset_ = NULL;
  renderflag_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BlockInfo::~BlockInfo() {
  SharedDtor();
}

void BlockInfo::SharedDtor() {
  if (this != default_instance_) {
    delete anchor_;
    delete pos_;
    delete scale_;
    delete skew_;
    delete colormultiplier_;
    delete coloroffset_;
  }
}

void BlockInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* BlockInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return BlockInfo_descriptor_;
}

const BlockInfo& BlockInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_AnimationModel_2eproto();
  return *default_instance_;
}

BlockInfo* BlockInfo::default_instance_ = NULL;

BlockInfo* BlockInfo::New() const {
  return new BlockInfo;
}

void BlockInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    zorder_ = 0;
    if (has_anchor()) {
      if (anchor_ != NULL) anchor_->::Medusa::CoreProto::PointF::Clear();
    }
    if (has_pos()) {
      if (pos_ != NULL) pos_->::Medusa::CoreProto::PointF::Clear();
    }
    if (has_scale()) {
      if (scale_ != NULL) scale_->::Medusa::CoreProto::ScaleF::Clear();
    }
    if (has_skew()) {
      if (skew_ != NULL) skew_->::Medusa::CoreProto::PointF::Clear();
    }
    if (has_colormultiplier()) {
      if (colormultiplier_ != NULL) colormultiplier_->::Medusa::CoreProto::ColorF::Clear();
    }
    if (has_coloroffset()) {
      if (coloroffset_ != NULL) coloroffset_->::Medusa::CoreProto::ColorF::Clear();
    }
    renderflag_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool BlockInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 ZOrder = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &zorder_)));
          set_has_zorder();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_Anchor;
        break;
      }

      // required .Medusa.CoreProto.PointF Anchor = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Anchor:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_anchor()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_Pos;
        break;
      }

      // required .Medusa.CoreProto.PointF Pos = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Pos:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_pos()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_Scale;
        break;
      }

      // required .Medusa.CoreProto.ScaleF Scale = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Scale:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_scale()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_Skew;
        break;
      }

      // required .Medusa.CoreProto.PointF Skew = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Skew:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_skew()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(82)) goto parse_ColorMultiplier;
        break;
      }

      // optional .Medusa.CoreProto.ColorF ColorMultiplier = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ColorMultiplier:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_colormultiplier()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(90)) goto parse_ColorOffset;
        break;
      }

      // optional .Medusa.CoreProto.ColorF ColorOffset = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ColorOffset:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_coloroffset()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(400)) goto parse_RenderFlag;
        break;
      }

      // optional int32 RenderFlag = 50;
      case 50: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_RenderFlag:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &renderflag_)));
          set_has_renderflag();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void BlockInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 ZOrder = 1;
  if (has_zorder()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->zorder(), output);
  }

  // required .Medusa.CoreProto.PointF Anchor = 2;
  if (has_anchor()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->anchor(), output);
  }

  // required .Medusa.CoreProto.PointF Pos = 4;
  if (has_pos()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->pos(), output);
  }

  // required .Medusa.CoreProto.ScaleF Scale = 6;
  if (has_scale()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->scale(), output);
  }

  // required .Medusa.CoreProto.PointF Skew = 8;
  if (has_skew()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, this->skew(), output);
  }

  // optional .Medusa.CoreProto.ColorF ColorMultiplier = 10;
  if (has_colormultiplier()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      10, this->colormultiplier(), output);
  }

  // optional .Medusa.CoreProto.ColorF ColorOffset = 11;
  if (has_coloroffset()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      11, this->coloroffset(), output);
  }

  // optional int32 RenderFlag = 50;
  if (has_renderflag()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(50, this->renderflag(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* BlockInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 ZOrder = 1;
  if (has_zorder()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->zorder(), target);
  }

  // required .Medusa.CoreProto.PointF Anchor = 2;
  if (has_anchor()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->anchor(), target);
  }

  // required .Medusa.CoreProto.PointF Pos = 4;
  if (has_pos()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->pos(), target);
  }

  // required .Medusa.CoreProto.ScaleF Scale = 6;
  if (has_scale()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->scale(), target);
  }

  // required .Medusa.CoreProto.PointF Skew = 8;
  if (has_skew()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        8, this->skew(), target);
  }

  // optional .Medusa.CoreProto.ColorF ColorMultiplier = 10;
  if (has_colormultiplier()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        10, this->colormultiplier(), target);
  }

  // optional .Medusa.CoreProto.ColorF ColorOffset = 11;
  if (has_coloroffset()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        11, this->coloroffset(), target);
  }

  // optional int32 RenderFlag = 50;
  if (has_renderflag()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(50, this->renderflag(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int BlockInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 ZOrder = 1;
    if (has_zorder()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->zorder());
    }

    // required .Medusa.CoreProto.PointF Anchor = 2;
    if (has_anchor()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->anchor());
    }

    // required .Medusa.CoreProto.PointF Pos = 4;
    if (has_pos()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->pos());
    }

    // required .Medusa.CoreProto.ScaleF Scale = 6;
    if (has_scale()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->scale());
    }

    // required .Medusa.CoreProto.PointF Skew = 8;
    if (has_skew()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->skew());
    }

    // optional .Medusa.CoreProto.ColorF ColorMultiplier = 10;
    if (has_colormultiplier()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->colormultiplier());
    }

    // optional .Medusa.CoreProto.ColorF ColorOffset = 11;
    if (has_coloroffset()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->coloroffset());
    }

    // optional int32 RenderFlag = 50;
    if (has_renderflag()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->renderflag());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BlockInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const BlockInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const BlockInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void BlockInfo::MergeFrom(const BlockInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_zorder()) {
      set_zorder(from.zorder());
    }
    if (from.has_anchor()) {
      mutable_anchor()->::Medusa::CoreProto::PointF::MergeFrom(from.anchor());
    }
    if (from.has_pos()) {
      mutable_pos()->::Medusa::CoreProto::PointF::MergeFrom(from.pos());
    }
    if (from.has_scale()) {
      mutable_scale()->::Medusa::CoreProto::ScaleF::MergeFrom(from.scale());
    }
    if (from.has_skew()) {
      mutable_skew()->::Medusa::CoreProto::PointF::MergeFrom(from.skew());
    }
    if (from.has_colormultiplier()) {
      mutable_colormultiplier()->::Medusa::CoreProto::ColorF::MergeFrom(from.colormultiplier());
    }
    if (from.has_coloroffset()) {
      mutable_coloroffset()->::Medusa::CoreProto::ColorF::MergeFrom(from.coloroffset());
    }
    if (from.has_renderflag()) {
      set_renderflag(from.renderflag());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void BlockInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BlockInfo::CopyFrom(const BlockInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BlockInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;

  if (has_anchor()) {
    if (!this->anchor().IsInitialized()) return false;
  }
  if (has_pos()) {
    if (!this->pos().IsInitialized()) return false;
  }
  if (has_scale()) {
    if (!this->scale().IsInitialized()) return false;
  }
  if (has_skew()) {
    if (!this->skew().IsInitialized()) return false;
  }
  if (has_colormultiplier()) {
    if (!this->colormultiplier().IsInitialized()) return false;
  }
  if (has_coloroffset()) {
    if (!this->coloroffset().IsInitialized()) return false;
  }
  return true;
}

void BlockInfo::Swap(BlockInfo* other) {
  if (other != this) {
    std::swap(zorder_, other->zorder_);
    std::swap(anchor_, other->anchor_);
    std::swap(pos_, other->pos_);
    std::swap(scale_, other->scale_);
    std::swap(skew_, other->skew_);
    std::swap(colormultiplier_, other->colormultiplier_);
    std::swap(coloroffset_, other->coloroffset_);
    std::swap(renderflag_, other->renderflag_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata BlockInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = BlockInfo_descriptor_;
  metadata.reflection = BlockInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int BlockModel::kFrameValueFieldNumber;
const int BlockModel::kInfoFieldNumber;
const int BlockModel::kImageIndexFieldNumber;
const int BlockModel::kBlockIdFieldNumber;
const int BlockModel::kPrevKeyFrameIndexFieldNumber;
const int BlockModel::kNextKeyFrameIndexFieldNumber;
#endif  // !_MSC_VER

BlockModel::BlockModel()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void BlockModel::InitAsDefaultInstance() {
  info_ = const_cast< ::Medusa::CoreProto::BlockInfo*>(&::Medusa::CoreProto::BlockInfo::default_instance());
}

BlockModel::BlockModel(const BlockModel& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void BlockModel::SharedCtor() {
  _cached_size_ = 0;
  framevalue_ = 1;
  info_ = NULL;
  imageindex_ = 0u;
  blockid_ = 0u;
  prevkeyframeindex_ = 0u;
  nextkeyframeindex_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BlockModel::~BlockModel() {
  SharedDtor();
}

void BlockModel::SharedDtor() {
  if (this != default_instance_) {
    delete info_;
  }
}

void BlockModel::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* BlockModel::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return BlockModel_descriptor_;
}

const BlockModel& BlockModel::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_AnimationModel_2eproto();
  return *default_instance_;
}

BlockModel* BlockModel::default_instance_ = NULL;

BlockModel* BlockModel::New() const {
  return new BlockModel;
}

void BlockModel::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    framevalue_ = 1;
    if (has_info()) {
      if (info_ != NULL) info_->::Medusa::CoreProto::BlockInfo::Clear();
    }
    imageindex_ = 0u;
    blockid_ = 0u;
    prevkeyframeindex_ = 0u;
    nextkeyframeindex_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool BlockModel::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .Medusa.CoreProto.FrameType FrameValue = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Medusa::CoreProto::FrameType_IsValid(value)) {
            set_framevalue(static_cast< ::Medusa::CoreProto::FrameType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_Info;
        break;
      }

      // optional .Medusa.CoreProto.BlockInfo Info = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_ImageIndex;
        break;
      }

      // optional uint32 ImageIndex = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_ImageIndex:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &imageindex_)));
          set_has_imageindex();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_BlockId;
        break;
      }

      // optional uint32 BlockId = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_BlockId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &blockid_)));
          set_has_blockid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_PrevKeyFrameIndex;
        break;
      }

      // optional uint32 PrevKeyFrameIndex = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_PrevKeyFrameIndex:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &prevkeyframeindex_)));
          set_has_prevkeyframeindex();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_NextKeyFrameIndex;
        break;
      }

      // optional uint32 NextKeyFrameIndex = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_NextKeyFrameIndex:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &nextkeyframeindex_)));
          set_has_nextkeyframeindex();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void BlockModel::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .Medusa.CoreProto.FrameType FrameValue = 1;
  if (has_framevalue()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->framevalue(), output);
  }

  // optional .Medusa.CoreProto.BlockInfo Info = 2;
  if (has_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->info(), output);
  }

  // optional uint32 ImageIndex = 3;
  if (has_imageindex()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->imageindex(), output);
  }

  // optional uint32 BlockId = 4;
  if (has_blockid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->blockid(), output);
  }

  // optional uint32 PrevKeyFrameIndex = 5;
  if (has_prevkeyframeindex()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->prevkeyframeindex(), output);
  }

  // optional uint32 NextKeyFrameIndex = 6;
  if (has_nextkeyframeindex()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->nextkeyframeindex(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* BlockModel::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .Medusa.CoreProto.FrameType FrameValue = 1;
  if (has_framevalue()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->framevalue(), target);
  }

  // optional .Medusa.CoreProto.BlockInfo Info = 2;
  if (has_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->info(), target);
  }

  // optional uint32 ImageIndex = 3;
  if (has_imageindex()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->imageindex(), target);
  }

  // optional uint32 BlockId = 4;
  if (has_blockid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->blockid(), target);
  }

  // optional uint32 PrevKeyFrameIndex = 5;
  if (has_prevkeyframeindex()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->prevkeyframeindex(), target);
  }

  // optional uint32 NextKeyFrameIndex = 6;
  if (has_nextkeyframeindex()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(6, this->nextkeyframeindex(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int BlockModel::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .Medusa.CoreProto.FrameType FrameValue = 1;
    if (has_framevalue()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->framevalue());
    }

    // optional .Medusa.CoreProto.BlockInfo Info = 2;
    if (has_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->info());
    }

    // optional uint32 ImageIndex = 3;
    if (has_imageindex()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->imageindex());
    }

    // optional uint32 BlockId = 4;
    if (has_blockid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->blockid());
    }

    // optional uint32 PrevKeyFrameIndex = 5;
    if (has_prevkeyframeindex()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->prevkeyframeindex());
    }

    // optional uint32 NextKeyFrameIndex = 6;
    if (has_nextkeyframeindex()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->nextkeyframeindex());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BlockModel::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const BlockModel* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const BlockModel*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void BlockModel::MergeFrom(const BlockModel& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_framevalue()) {
      set_framevalue(from.framevalue());
    }
    if (from.has_info()) {
      mutable_info()->::Medusa::CoreProto::BlockInfo::MergeFrom(from.info());
    }
    if (from.has_imageindex()) {
      set_imageindex(from.imageindex());
    }
    if (from.has_blockid()) {
      set_blockid(from.blockid());
    }
    if (from.has_prevkeyframeindex()) {
      set_prevkeyframeindex(from.prevkeyframeindex());
    }
    if (from.has_nextkeyframeindex()) {
      set_nextkeyframeindex(from.nextkeyframeindex());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void BlockModel::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BlockModel::CopyFrom(const BlockModel& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BlockModel::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_info()) {
    if (!this->info().IsInitialized()) return false;
  }
  return true;
}

void BlockModel::Swap(BlockModel* other) {
  if (other != this) {
    std::swap(framevalue_, other->framevalue_);
    std::swap(info_, other->info_);
    std::swap(imageindex_, other->imageindex_);
    std::swap(blockid_, other->blockid_);
    std::swap(prevkeyframeindex_, other->prevkeyframeindex_);
    std::swap(nextkeyframeindex_, other->nextkeyframeindex_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata BlockModel::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = BlockModel_descriptor_;
  metadata.reflection = BlockModel_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int FrameModel::kBlocksFieldNumber;
#endif  // !_MSC_VER

FrameModel::FrameModel()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void FrameModel::InitAsDefaultInstance() {
}

FrameModel::FrameModel(const FrameModel& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void FrameModel::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FrameModel::~FrameModel() {
  SharedDtor();
}

void FrameModel::SharedDtor() {
  if (this != default_instance_) {
  }
}

void FrameModel::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* FrameModel::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FrameModel_descriptor_;
}

const FrameModel& FrameModel::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_AnimationModel_2eproto();
  return *default_instance_;
}

FrameModel* FrameModel::default_instance_ = NULL;

FrameModel* FrameModel::New() const {
  return new FrameModel;
}

void FrameModel::Clear() {
  blocks_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool FrameModel::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .Medusa.CoreProto.BlockModel Blocks = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Blocks:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_blocks()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_Blocks;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void FrameModel::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .Medusa.CoreProto.BlockModel Blocks = 1;
  for (int i = 0; i < this->blocks_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->blocks(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* FrameModel::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .Medusa.CoreProto.BlockModel Blocks = 1;
  for (int i = 0; i < this->blocks_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->blocks(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int FrameModel::ByteSize() const {
  int total_size = 0;

  // repeated .Medusa.CoreProto.BlockModel Blocks = 1;
  total_size += 1 * this->blocks_size();
  for (int i = 0; i < this->blocks_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->blocks(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FrameModel::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const FrameModel* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const FrameModel*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void FrameModel::MergeFrom(const FrameModel& from) {
  GOOGLE_CHECK_NE(&from, this);
  blocks_.MergeFrom(from.blocks_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void FrameModel::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FrameModel::CopyFrom(const FrameModel& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FrameModel::IsInitialized() const {

  for (int i = 0; i < blocks_size(); i++) {
    if (!this->blocks(i).IsInitialized()) return false;
  }
  return true;
}

void FrameModel::Swap(FrameModel* other) {
  if (other != this) {
    blocks_.Swap(&other->blocks_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata FrameModel::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = FrameModel_descriptor_;
  metadata.reflection = FrameModel_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int AnimationModel::kFrameRateFieldNumber;
const int AnimationModel::kComponentsFieldNumber;
const int AnimationModel::kFramesFieldNumber;
const int AnimationModel::kModelSizeFieldNumber;
#endif  // !_MSC_VER

AnimationModel::AnimationModel()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AnimationModel::InitAsDefaultInstance() {
  modelsize_ = const_cast< ::Medusa::CoreProto::SizeF*>(&::Medusa::CoreProto::SizeF::default_instance());
}

AnimationModel::AnimationModel(const AnimationModel& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AnimationModel::SharedCtor() {
  _cached_size_ = 0;
  framerate_ = 0u;
  modelsize_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AnimationModel::~AnimationModel() {
  SharedDtor();
}

void AnimationModel::SharedDtor() {
  if (this != default_instance_) {
    delete modelsize_;
  }
}

void AnimationModel::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AnimationModel::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AnimationModel_descriptor_;
}

const AnimationModel& AnimationModel::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_AnimationModel_2eproto();
  return *default_instance_;
}

AnimationModel* AnimationModel::default_instance_ = NULL;

AnimationModel* AnimationModel::New() const {
  return new AnimationModel;
}

void AnimationModel::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    framerate_ = 0u;
    if (has_modelsize()) {
      if (modelsize_ != NULL) modelsize_->::Medusa::CoreProto::SizeF::Clear();
    }
  }
  components_.Clear();
  frames_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AnimationModel::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 FrameRate = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &framerate_)));
          set_has_framerate();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_Components;
        break;
      }

      // repeated .Medusa.CoreProto.ComponentInfo Components = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Components:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_components()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_Components;
        if (input->ExpectTag(26)) goto parse_Frames;
        break;
      }

      // repeated .Medusa.CoreProto.FrameModel Frames = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Frames:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_frames()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_Frames;
        if (input->ExpectTag(34)) goto parse_ModelSize;
        break;
      }

      // required .Medusa.CoreProto.SizeF ModelSize = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ModelSize:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_modelsize()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AnimationModel::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 FrameRate = 1;
  if (has_framerate()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->framerate(), output);
  }

  // repeated .Medusa.CoreProto.ComponentInfo Components = 2;
  for (int i = 0; i < this->components_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->components(i), output);
  }

  // repeated .Medusa.CoreProto.FrameModel Frames = 3;
  for (int i = 0; i < this->frames_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->frames(i), output);
  }

  // required .Medusa.CoreProto.SizeF ModelSize = 4;
  if (has_modelsize()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->modelsize(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AnimationModel::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 FrameRate = 1;
  if (has_framerate()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->framerate(), target);
  }

  // repeated .Medusa.CoreProto.ComponentInfo Components = 2;
  for (int i = 0; i < this->components_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->components(i), target);
  }

  // repeated .Medusa.CoreProto.FrameModel Frames = 3;
  for (int i = 0; i < this->frames_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->frames(i), target);
  }

  // required .Medusa.CoreProto.SizeF ModelSize = 4;
  if (has_modelsize()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->modelsize(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AnimationModel::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 FrameRate = 1;
    if (has_framerate()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->framerate());
    }

    // required .Medusa.CoreProto.SizeF ModelSize = 4;
    if (has_modelsize()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->modelsize());
    }

  }
  // repeated .Medusa.CoreProto.ComponentInfo Components = 2;
  total_size += 1 * this->components_size();
  for (int i = 0; i < this->components_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->components(i));
  }

  // repeated .Medusa.CoreProto.FrameModel Frames = 3;
  total_size += 1 * this->frames_size();
  for (int i = 0; i < this->frames_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->frames(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AnimationModel::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AnimationModel* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AnimationModel*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AnimationModel::MergeFrom(const AnimationModel& from) {
  GOOGLE_CHECK_NE(&from, this);
  components_.MergeFrom(from.components_);
  frames_.MergeFrom(from.frames_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_framerate()) {
      set_framerate(from.framerate());
    }
    if (from.has_modelsize()) {
      mutable_modelsize()->::Medusa::CoreProto::SizeF::MergeFrom(from.modelsize());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AnimationModel::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AnimationModel::CopyFrom(const AnimationModel& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AnimationModel::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000009) != 0x00000009) return false;

  for (int i = 0; i < components_size(); i++) {
    if (!this->components(i).IsInitialized()) return false;
  }
  for (int i = 0; i < frames_size(); i++) {
    if (!this->frames(i).IsInitialized()) return false;
  }
  if (has_modelsize()) {
    if (!this->modelsize().IsInitialized()) return false;
  }
  return true;
}

void AnimationModel::Swap(AnimationModel* other) {
  if (other != this) {
    std::swap(framerate_, other->framerate_);
    components_.Swap(&other->components_);
    frames_.Swap(&other->frames_);
    std::swap(modelsize_, other->modelsize_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AnimationModel::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AnimationModel_descriptor_;
  metadata.reflection = AnimationModel_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace CoreProto
}  // namespace Medusa

// @@protoc_insertion_point(global_scope)
