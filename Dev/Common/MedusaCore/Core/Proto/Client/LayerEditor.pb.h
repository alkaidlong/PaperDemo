// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: LayerEditor.proto

#ifndef PROTOBUF_LayerEditor_2eproto__INCLUDED
#define PROTOBUF_LayerEditor_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "Geometry.pb.h"
#include "FileSystem.pb.h"
// @@protoc_insertion_point(includes)

namespace Medusa {
namespace CoreProto {
namespace Editor {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_LayerEditor_2eproto();
void protobuf_AssignDesc_LayerEditor_2eproto();
void protobuf_ShutdownFile_LayerEditor_2eproto();

class ImageFile;
class Image;
class Button;
class Frame;
class Label;
class EditBox;
class ProgressBar;
class Trigger;
class TriggerRef;
class LayerRef;
class ListBox;
class Layer;

enum EditBox_EditBoxKeyboardReturnType {
  EditBox_EditBoxKeyboardReturnType_Default = 0,
  EditBox_EditBoxKeyboardReturnType_Done = 1,
  EditBox_EditBoxKeyboardReturnType_Send = 2,
  EditBox_EditBoxKeyboardReturnType_Search = 3,
  EditBox_EditBoxKeyboardReturnType_Go = 4
};
bool EditBox_EditBoxKeyboardReturnType_IsValid(int value);
const EditBox_EditBoxKeyboardReturnType EditBox_EditBoxKeyboardReturnType_EditBoxKeyboardReturnType_MIN = EditBox_EditBoxKeyboardReturnType_Default;
const EditBox_EditBoxKeyboardReturnType EditBox_EditBoxKeyboardReturnType_EditBoxKeyboardReturnType_MAX = EditBox_EditBoxKeyboardReturnType_Go;
const int EditBox_EditBoxKeyboardReturnType_EditBoxKeyboardReturnType_ARRAYSIZE = EditBox_EditBoxKeyboardReturnType_EditBoxKeyboardReturnType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EditBox_EditBoxKeyboardReturnType_descriptor();
inline const ::std::string& EditBox_EditBoxKeyboardReturnType_Name(EditBox_EditBoxKeyboardReturnType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EditBox_EditBoxKeyboardReturnType_descriptor(), value);
}
inline bool EditBox_EditBoxKeyboardReturnType_Parse(
    const ::std::string& name, EditBox_EditBoxKeyboardReturnType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EditBox_EditBoxKeyboardReturnType>(
    EditBox_EditBoxKeyboardReturnType_descriptor(), name, value);
}
enum EditBox_EditBoxInputMode {
  EditBox_EditBoxInputMode_Any = 0,
  EditBox_EditBoxInputMode_EmailAddr = 1,
  EditBox_EditBoxInputMode_Numeric = 2,
  EditBox_EditBoxInputMode_PhoneNumber = 3,
  EditBox_EditBoxInputMode_Url = 4,
  EditBox_EditBoxInputMode_Decimal = 5,
  EditBox_EditBoxInputMode_SingleLine = 6
};
bool EditBox_EditBoxInputMode_IsValid(int value);
const EditBox_EditBoxInputMode EditBox_EditBoxInputMode_EditBoxInputMode_MIN = EditBox_EditBoxInputMode_Any;
const EditBox_EditBoxInputMode EditBox_EditBoxInputMode_EditBoxInputMode_MAX = EditBox_EditBoxInputMode_SingleLine;
const int EditBox_EditBoxInputMode_EditBoxInputMode_ARRAYSIZE = EditBox_EditBoxInputMode_EditBoxInputMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* EditBox_EditBoxInputMode_descriptor();
inline const ::std::string& EditBox_EditBoxInputMode_Name(EditBox_EditBoxInputMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    EditBox_EditBoxInputMode_descriptor(), value);
}
inline bool EditBox_EditBoxInputMode_Parse(
    const ::std::string& name, EditBox_EditBoxInputMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EditBox_EditBoxInputMode>(
    EditBox_EditBoxInputMode_descriptor(), name, value);
}
enum EditBox_EditBoxInputFlag {
  EditBox_EditBoxInputFlag_Password = 0,
  EditBox_EditBoxInputFlag_Sensitive = 1,
  EditBox_EditBoxInputFlag_InitialCapsWord = 2,
  EditBox_EditBoxInputFlag_InitialCapsSentence = 3,
  EditBox_EditBoxInputFlag_InitialCapsAllCharacters = 4
};
bool EditBox_EditBoxInputFlag_IsValid(int value);
const EditBox_EditBoxInputFlag EditBox_EditBoxInputFlag_EditBoxInputFlag_MIN = EditBox_EditBoxInputFlag_Password;
const EditBox_EditBoxInputFlag EditBox_EditBoxInputFlag_EditBoxInputFlag_MAX = EditBox_EditBoxInputFlag_InitialCapsAllCharacters;
const int EditBox_EditBoxInputFlag_EditBoxInputFlag_ARRAYSIZE = EditBox_EditBoxInputFlag_EditBoxInputFlag_MAX + 1;

const ::google::protobuf::EnumDescriptor* EditBox_EditBoxInputFlag_descriptor();
inline const ::std::string& EditBox_EditBoxInputFlag_Name(EditBox_EditBoxInputFlag value) {
  return ::google::protobuf::internal::NameOfEnum(
    EditBox_EditBoxInputFlag_descriptor(), value);
}
inline bool EditBox_EditBoxInputFlag_Parse(
    const ::std::string& name, EditBox_EditBoxInputFlag* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EditBox_EditBoxInputFlag>(
    EditBox_EditBoxInputFlag_descriptor(), name, value);
}
enum ProgressBar_ProgressBarType {
  ProgressBar_ProgressBarType_Radial = 0,
  ProgressBar_ProgressBarType_Bar = 1
};
bool ProgressBar_ProgressBarType_IsValid(int value);
const ProgressBar_ProgressBarType ProgressBar_ProgressBarType_ProgressBarType_MIN = ProgressBar_ProgressBarType_Radial;
const ProgressBar_ProgressBarType ProgressBar_ProgressBarType_ProgressBarType_MAX = ProgressBar_ProgressBarType_Bar;
const int ProgressBar_ProgressBarType_ProgressBarType_ARRAYSIZE = ProgressBar_ProgressBarType_ProgressBarType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ProgressBar_ProgressBarType_descriptor();
inline const ::std::string& ProgressBar_ProgressBarType_Name(ProgressBar_ProgressBarType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ProgressBar_ProgressBarType_descriptor(), value);
}
inline bool ProgressBar_ProgressBarType_Parse(
    const ::std::string& name, ProgressBar_ProgressBarType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ProgressBar_ProgressBarType>(
    ProgressBar_ProgressBarType_descriptor(), name, value);
}
enum ListBox_ScorllDirection {
  ListBox_ScorllDirection_None = -1,
  ListBox_ScorllDirection_Horizontal = 0,
  ListBox_ScorllDirection_Vertical = 1,
  ListBox_ScorllDirection_Both = 2
};
bool ListBox_ScorllDirection_IsValid(int value);
const ListBox_ScorllDirection ListBox_ScorllDirection_ScorllDirection_MIN = ListBox_ScorllDirection_None;
const ListBox_ScorllDirection ListBox_ScorllDirection_ScorllDirection_MAX = ListBox_ScorllDirection_Both;
const int ListBox_ScorllDirection_ScorllDirection_ARRAYSIZE = ListBox_ScorllDirection_ScorllDirection_MAX + 1;

const ::google::protobuf::EnumDescriptor* ListBox_ScorllDirection_descriptor();
inline const ::std::string& ListBox_ScorllDirection_Name(ListBox_ScorllDirection value) {
  return ::google::protobuf::internal::NameOfEnum(
    ListBox_ScorllDirection_descriptor(), value);
}
inline bool ListBox_ScorllDirection_Parse(
    const ::std::string& name, ListBox_ScorllDirection* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ListBox_ScorllDirection>(
    ListBox_ScorllDirection_descriptor(), name, value);
}
enum ListBox_VerticalOrder {
  ListBox_VerticalOrder_Ascending = 0,
  ListBox_VerticalOrder_Descending = 1
};
bool ListBox_VerticalOrder_IsValid(int value);
const ListBox_VerticalOrder ListBox_VerticalOrder_VerticalOrder_MIN = ListBox_VerticalOrder_Ascending;
const ListBox_VerticalOrder ListBox_VerticalOrder_VerticalOrder_MAX = ListBox_VerticalOrder_Descending;
const int ListBox_VerticalOrder_VerticalOrder_ARRAYSIZE = ListBox_VerticalOrder_VerticalOrder_MAX + 1;

const ::google::protobuf::EnumDescriptor* ListBox_VerticalOrder_descriptor();
inline const ::std::string& ListBox_VerticalOrder_Name(ListBox_VerticalOrder value) {
  return ::google::protobuf::internal::NameOfEnum(
    ListBox_VerticalOrder_descriptor(), value);
}
inline bool ListBox_VerticalOrder_Parse(
    const ::std::string& name, ListBox_VerticalOrder* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ListBox_VerticalOrder>(
    ListBox_VerticalOrder_descriptor(), name, value);
}
enum TextAlignmentType {
  LeftTop = 1,
  MiddleTop = 2,
  RightTop = 3,
  LeftCenter = 4,
  MiddleCenter = 5,
  RightCenter = 6,
  LeftBottom = 7,
  MiddleBottom = 8,
  RightBottom = 9
};
bool TextAlignmentType_IsValid(int value);
const TextAlignmentType TextAlignmentType_MIN = LeftTop;
const TextAlignmentType TextAlignmentType_MAX = RightBottom;
const int TextAlignmentType_ARRAYSIZE = TextAlignmentType_MAX + 1;

const ::google::protobuf::EnumDescriptor* TextAlignmentType_descriptor();
inline const ::std::string& TextAlignmentType_Name(TextAlignmentType value) {
  return ::google::protobuf::internal::NameOfEnum(
    TextAlignmentType_descriptor(), value);
}
inline bool TextAlignmentType_Parse(
    const ::std::string& name, TextAlignmentType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TextAlignmentType>(
    TextAlignmentType_descriptor(), name, value);
}
// ===================================================================

class ImageFile : public ::google::protobuf::Message {
 public:
  ImageFile();
  virtual ~ImageFile();

  ImageFile(const ImageFile& from);

  inline ImageFile& operator=(const ImageFile& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ImageFile& default_instance();

  void Swap(ImageFile* other);

  // implements Message ----------------------------------------------

  ImageFile* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ImageFile& from);
  void MergeFrom(const ImageFile& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Medusa.CoreProto.FileId File = 1;
  inline bool has_file() const;
  inline void clear_file();
  static const int kFileFieldNumber = 1;
  inline const ::Medusa::CoreProto::FileId& file() const;
  inline ::Medusa::CoreProto::FileId* mutable_file();
  inline ::Medusa::CoreProto::FileId* release_file();
  inline void set_allocated_file(::Medusa::CoreProto::FileId* file);

  // optional .Medusa.CoreProto.BorderU Border = 2;
  inline bool has_border() const;
  inline void clear_border();
  static const int kBorderFieldNumber = 2;
  inline const ::Medusa::CoreProto::BorderU& border() const;
  inline ::Medusa::CoreProto::BorderU* mutable_border();
  inline ::Medusa::CoreProto::BorderU* release_border();
  inline void set_allocated_border(::Medusa::CoreProto::BorderU* border);

  // @@protoc_insertion_point(class_scope:Medusa.CoreProto.Editor.ImageFile)
 private:
  inline void set_has_file();
  inline void clear_has_file();
  inline void set_has_border();
  inline void clear_has_border();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Medusa::CoreProto::FileId* file_;
  ::Medusa::CoreProto::BorderU* border_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_LayerEditor_2eproto();
  friend void protobuf_AssignDesc_LayerEditor_2eproto();
  friend void protobuf_ShutdownFile_LayerEditor_2eproto();

  void InitAsDefaultInstance();
  static ImageFile* default_instance_;
};
// -------------------------------------------------------------------

class Image : public ::google::protobuf::Message {
 public:
  Image();
  virtual ~Image();

  Image(const Image& from);

  inline Image& operator=(const Image& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Image& default_instance();

  void Swap(Image* other);

  // implements Message ----------------------------------------------

  Image* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Image& from);
  void MergeFrom(const Image& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string ID = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIDFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // repeated .Medusa.CoreProto.Editor.ImageFile OptionalImages = 2;
  inline int optionalimages_size() const;
  inline void clear_optionalimages();
  static const int kOptionalImagesFieldNumber = 2;
  inline const ::Medusa::CoreProto::Editor::ImageFile& optionalimages(int index) const;
  inline ::Medusa::CoreProto::Editor::ImageFile* mutable_optionalimages(int index);
  inline ::Medusa::CoreProto::Editor::ImageFile* add_optionalimages();
  inline const ::google::protobuf::RepeatedPtrField< ::Medusa::CoreProto::Editor::ImageFile >&
      optionalimages() const;
  inline ::google::protobuf::RepeatedPtrField< ::Medusa::CoreProto::Editor::ImageFile >*
      mutable_optionalimages();

  // required .Medusa.CoreProto.SizeU Size = 3;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 3;
  inline const ::Medusa::CoreProto::SizeU& size() const;
  inline ::Medusa::CoreProto::SizeU* mutable_size();
  inline ::Medusa::CoreProto::SizeU* release_size();
  inline void set_allocated_size(::Medusa::CoreProto::SizeU* size);

  // required .Medusa.CoreProto.PointF Position = 4;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 4;
  inline const ::Medusa::CoreProto::PointF& position() const;
  inline ::Medusa::CoreProto::PointF* mutable_position();
  inline ::Medusa::CoreProto::PointF* release_position();
  inline void set_allocated_position(::Medusa::CoreProto::PointF* position);

  // required bool IsProportionPoint = 5;
  inline bool has_isproportionpoint() const;
  inline void clear_isproportionpoint();
  static const int kIsProportionPointFieldNumber = 5;
  inline bool isproportionpoint() const;
  inline void set_isproportionpoint(bool value);

  // required .Medusa.CoreProto.PointF Anchor = 6;
  inline bool has_anchor() const;
  inline void clear_anchor();
  static const int kAnchorFieldNumber = 6;
  inline const ::Medusa::CoreProto::PointF& anchor() const;
  inline ::Medusa::CoreProto::PointF* mutable_anchor();
  inline ::Medusa::CoreProto::PointF* release_anchor();
  inline void set_allocated_anchor(::Medusa::CoreProto::PointF* anchor);

  // required int32 ZOrder = 7;
  inline bool has_zorder() const;
  inline void clear_zorder();
  static const int kZOrderFieldNumber = 7;
  inline ::google::protobuf::int32 zorder() const;
  inline void set_zorder(::google::protobuf::int32 value);

  // optional float Rotation = 8;
  inline bool has_rotation() const;
  inline void clear_rotation();
  static const int kRotationFieldNumber = 8;
  inline float rotation() const;
  inline void set_rotation(float value);

  // optional .Medusa.CoreProto.ScaleF Scale = 9;
  inline bool has_scale() const;
  inline void clear_scale();
  static const int kScaleFieldNumber = 9;
  inline const ::Medusa::CoreProto::ScaleF& scale() const;
  inline ::Medusa::CoreProto::ScaleF* mutable_scale();
  inline ::Medusa::CoreProto::ScaleF* release_scale();
  inline void set_allocated_scale(::Medusa::CoreProto::ScaleF* scale);

  // optional bool IsFilpX = 10;
  inline bool has_isfilpx() const;
  inline void clear_isfilpx();
  static const int kIsFilpXFieldNumber = 10;
  inline bool isfilpx() const;
  inline void set_isfilpx(bool value);

  // optional bool IsFilpY = 11;
  inline bool has_isfilpy() const;
  inline void clear_isfilpy();
  static const int kIsFilpYFieldNumber = 11;
  inline bool isfilpy() const;
  inline void set_isfilpy(bool value);

  // required bool IsVisible = 12;
  inline bool has_isvisible() const;
  inline void clear_isvisible();
  static const int kIsVisibleFieldNumber = 12;
  inline bool isvisible() const;
  inline void set_isvisible(bool value);

  // required float Parallax = 13;
  inline bool has_parallax() const;
  inline void clear_parallax();
  static const int kParallaxFieldNumber = 13;
  inline float parallax() const;
  inline void set_parallax(float value);

  // required .Medusa.CoreProto.Editor.ImageFile File = 14;
  inline bool has_file() const;
  inline void clear_file();
  static const int kFileFieldNumber = 14;
  inline const ::Medusa::CoreProto::Editor::ImageFile& file() const;
  inline ::Medusa::CoreProto::Editor::ImageFile* mutable_file();
  inline ::Medusa::CoreProto::Editor::ImageFile* release_file();
  inline void set_allocated_file(::Medusa::CoreProto::Editor::ImageFile* file);

  // optional string OnLoad = 15;
  inline bool has_onload() const;
  inline void clear_onload();
  static const int kOnLoadFieldNumber = 15;
  inline const ::std::string& onload() const;
  inline void set_onload(const ::std::string& value);
  inline void set_onload(const char* value);
  inline void set_onload(const char* value, size_t size);
  inline ::std::string* mutable_onload();
  inline ::std::string* release_onload();
  inline void set_allocated_onload(::std::string* onload);

  // optional string OnShow = 16;
  inline bool has_onshow() const;
  inline void clear_onshow();
  static const int kOnShowFieldNumber = 16;
  inline const ::std::string& onshow() const;
  inline void set_onshow(const ::std::string& value);
  inline void set_onshow(const char* value);
  inline void set_onshow(const char* value, size_t size);
  inline ::std::string* mutable_onshow();
  inline ::std::string* release_onshow();
  inline void set_allocated_onshow(::std::string* onshow);

  // optional string OnHide = 17;
  inline bool has_onhide() const;
  inline void clear_onhide();
  static const int kOnHideFieldNumber = 17;
  inline const ::std::string& onhide() const;
  inline void set_onhide(const ::std::string& value);
  inline void set_onhide(const char* value);
  inline void set_onhide(const char* value, size_t size);
  inline ::std::string* mutable_onhide();
  inline ::std::string* release_onhide();
  inline void set_allocated_onhide(::std::string* onhide);

  // optional string OnClosed = 18;
  inline bool has_onclosed() const;
  inline void clear_onclosed();
  static const int kOnClosedFieldNumber = 18;
  inline const ::std::string& onclosed() const;
  inline void set_onclosed(const ::std::string& value);
  inline void set_onclosed(const char* value);
  inline void set_onclosed(const char* value, size_t size);
  inline ::std::string* mutable_onclosed();
  inline ::std::string* release_onclosed();
  inline void set_allocated_onclosed(::std::string* onclosed);

  // optional string OnUpdate = 19;
  inline bool has_onupdate() const;
  inline void clear_onupdate();
  static const int kOnUpdateFieldNumber = 19;
  inline const ::std::string& onupdate() const;
  inline void set_onupdate(const ::std::string& value);
  inline void set_onupdate(const char* value);
  inline void set_onupdate(const char* value, size_t size);
  inline ::std::string* mutable_onupdate();
  inline ::std::string* release_onupdate();
  inline void set_allocated_onupdate(::std::string* onupdate);

  // optional string OnEvent = 20;
  inline bool has_onevent() const;
  inline void clear_onevent();
  static const int kOnEventFieldNumber = 20;
  inline const ::std::string& onevent() const;
  inline void set_onevent(const ::std::string& value);
  inline void set_onevent(const char* value);
  inline void set_onevent(const char* value, size_t size);
  inline ::std::string* mutable_onevent();
  inline ::std::string* release_onevent();
  inline void set_allocated_onevent(::std::string* onevent);

  // optional bool IsLoop = 21;
  inline bool has_isloop() const;
  inline void clear_isloop();
  static const int kIsLoopFieldNumber = 21;
  inline bool isloop() const;
  inline void set_isloop(bool value);

  // optional .Medusa.CoreProto.RectF ScissorBox = 22;
  inline bool has_scissorbox() const;
  inline void clear_scissorbox();
  static const int kScissorBoxFieldNumber = 22;
  inline const ::Medusa::CoreProto::RectF& scissorbox() const;
  inline ::Medusa::CoreProto::RectF* mutable_scissorbox();
  inline ::Medusa::CoreProto::RectF* release_scissorbox();
  inline void set_allocated_scissorbox(::Medusa::CoreProto::RectF* scissorbox);

  // optional int32 RenderFlag = 50;
  inline bool has_renderflag() const;
  inline void clear_renderflag();
  static const int kRenderFlagFieldNumber = 50;
  inline ::google::protobuf::int32 renderflag() const;
  inline void set_renderflag(::google::protobuf::int32 value);

  // optional int32 Tag = 51;
  inline bool has_tag() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 51;
  inline ::google::protobuf::int32 tag() const;
  inline void set_tag(::google::protobuf::int32 value);

  // optional string ClickEffect = 101;
  inline bool has_clickeffect() const;
  inline void clear_clickeffect();
  static const int kClickEffectFieldNumber = 101;
  inline const ::std::string& clickeffect() const;
  inline void set_clickeffect(const ::std::string& value);
  inline void set_clickeffect(const char* value);
  inline void set_clickeffect(const char* value, size_t size);
  inline ::std::string* mutable_clickeffect();
  inline ::std::string* release_clickeffect();
  inline void set_allocated_clickeffect(::std::string* clickeffect);

  // optional bool IsLock = 201;
  inline bool has_islock() const;
  inline void clear_islock();
  static const int kIsLockFieldNumber = 201;
  inline bool islock() const;
  inline void set_islock(bool value);

  // optional bool IsHide = 202;
  inline bool has_ishide() const;
  inline void clear_ishide();
  static const int kIsHideFieldNumber = 202;
  inline bool ishide() const;
  inline void set_ishide(bool value);

  // @@protoc_insertion_point(class_scope:Medusa.CoreProto.Editor.Image)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_isproportionpoint();
  inline void clear_has_isproportionpoint();
  inline void set_has_anchor();
  inline void clear_has_anchor();
  inline void set_has_zorder();
  inline void clear_has_zorder();
  inline void set_has_rotation();
  inline void clear_has_rotation();
  inline void set_has_scale();
  inline void clear_has_scale();
  inline void set_has_isfilpx();
  inline void clear_has_isfilpx();
  inline void set_has_isfilpy();
  inline void clear_has_isfilpy();
  inline void set_has_isvisible();
  inline void clear_has_isvisible();
  inline void set_has_parallax();
  inline void clear_has_parallax();
  inline void set_has_file();
  inline void clear_has_file();
  inline void set_has_onload();
  inline void clear_has_onload();
  inline void set_has_onshow();
  inline void clear_has_onshow();
  inline void set_has_onhide();
  inline void clear_has_onhide();
  inline void set_has_onclosed();
  inline void clear_has_onclosed();
  inline void set_has_onupdate();
  inline void clear_has_onupdate();
  inline void set_has_onevent();
  inline void clear_has_onevent();
  inline void set_has_isloop();
  inline void clear_has_isloop();
  inline void set_has_scissorbox();
  inline void clear_has_scissorbox();
  inline void set_has_renderflag();
  inline void clear_has_renderflag();
  inline void set_has_tag();
  inline void clear_has_tag();
  inline void set_has_clickeffect();
  inline void clear_has_clickeffect();
  inline void set_has_islock();
  inline void clear_has_islock();
  inline void set_has_ishide();
  inline void clear_has_ishide();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::google::protobuf::RepeatedPtrField< ::Medusa::CoreProto::Editor::ImageFile > optionalimages_;
  ::Medusa::CoreProto::SizeU* size_;
  ::Medusa::CoreProto::PointF* position_;
  ::Medusa::CoreProto::PointF* anchor_;
  ::google::protobuf::int32 zorder_;
  float rotation_;
  ::Medusa::CoreProto::ScaleF* scale_;
  bool isproportionpoint_;
  bool isfilpx_;
  bool isfilpy_;
  bool isvisible_;
  float parallax_;
  ::Medusa::CoreProto::Editor::ImageFile* file_;
  ::std::string* onload_;
  ::std::string* onshow_;
  ::std::string* onhide_;
  ::std::string* onclosed_;
  ::std::string* onupdate_;
  ::std::string* onevent_;
  ::Medusa::CoreProto::RectF* scissorbox_;
  ::google::protobuf::int32 renderflag_;
  ::google::protobuf::int32 tag_;
  ::std::string* clickeffect_;
  bool isloop_;
  bool islock_;
  bool ishide_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(27 + 31) / 32];

  friend void  protobuf_AddDesc_LayerEditor_2eproto();
  friend void protobuf_AssignDesc_LayerEditor_2eproto();
  friend void protobuf_ShutdownFile_LayerEditor_2eproto();

  void InitAsDefaultInstance();
  static Image* default_instance_;
};
// -------------------------------------------------------------------

class Button : public ::google::protobuf::Message {
 public:
  Button();
  virtual ~Button();

  Button(const Button& from);

  inline Button& operator=(const Button& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Button& default_instance();

  void Swap(Button* other);

  // implements Message ----------------------------------------------

  Button* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Button& from);
  void MergeFrom(const Button& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string ID = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIDFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // required .Medusa.CoreProto.SizeU Size = 2;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 2;
  inline const ::Medusa::CoreProto::SizeU& size() const;
  inline ::Medusa::CoreProto::SizeU* mutable_size();
  inline ::Medusa::CoreProto::SizeU* release_size();
  inline void set_allocated_size(::Medusa::CoreProto::SizeU* size);

  // required .Medusa.CoreProto.PointF Position = 3;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 3;
  inline const ::Medusa::CoreProto::PointF& position() const;
  inline ::Medusa::CoreProto::PointF* mutable_position();
  inline ::Medusa::CoreProto::PointF* release_position();
  inline void set_allocated_position(::Medusa::CoreProto::PointF* position);

  // required bool IsProportionPoint = 4;
  inline bool has_isproportionpoint() const;
  inline void clear_isproportionpoint();
  static const int kIsProportionPointFieldNumber = 4;
  inline bool isproportionpoint() const;
  inline void set_isproportionpoint(bool value);

  // required .Medusa.CoreProto.PointF Anchor = 5;
  inline bool has_anchor() const;
  inline void clear_anchor();
  static const int kAnchorFieldNumber = 5;
  inline const ::Medusa::CoreProto::PointF& anchor() const;
  inline ::Medusa::CoreProto::PointF* mutable_anchor();
  inline ::Medusa::CoreProto::PointF* release_anchor();
  inline void set_allocated_anchor(::Medusa::CoreProto::PointF* anchor);

  // required int32 ZOrder = 6;
  inline bool has_zorder() const;
  inline void clear_zorder();
  static const int kZOrderFieldNumber = 6;
  inline ::google::protobuf::int32 zorder() const;
  inline void set_zorder(::google::protobuf::int32 value);

  // optional float Rotation = 7;
  inline bool has_rotation() const;
  inline void clear_rotation();
  static const int kRotationFieldNumber = 7;
  inline float rotation() const;
  inline void set_rotation(float value);

  // optional .Medusa.CoreProto.ScaleF Scale = 8;
  inline bool has_scale() const;
  inline void clear_scale();
  static const int kScaleFieldNumber = 8;
  inline const ::Medusa::CoreProto::ScaleF& scale() const;
  inline ::Medusa::CoreProto::ScaleF* mutable_scale();
  inline ::Medusa::CoreProto::ScaleF* release_scale();
  inline void set_allocated_scale(::Medusa::CoreProto::ScaleF* scale);

  // optional bool IsFilpX = 9;
  inline bool has_isfilpx() const;
  inline void clear_isfilpx();
  static const int kIsFilpXFieldNumber = 9;
  inline bool isfilpx() const;
  inline void set_isfilpx(bool value);

  // optional bool IsFilpY = 10;
  inline bool has_isfilpy() const;
  inline void clear_isfilpy();
  static const int kIsFilpYFieldNumber = 10;
  inline bool isfilpy() const;
  inline void set_isfilpy(bool value);

  // required bool IsVisible = 11;
  inline bool has_isvisible() const;
  inline void clear_isvisible();
  static const int kIsVisibleFieldNumber = 11;
  inline bool isvisible() const;
  inline void set_isvisible(bool value);

  // optional .Medusa.CoreProto.Editor.ImageFile NormalImage = 12;
  inline bool has_normalimage() const;
  inline void clear_normalimage();
  static const int kNormalImageFieldNumber = 12;
  inline const ::Medusa::CoreProto::Editor::ImageFile& normalimage() const;
  inline ::Medusa::CoreProto::Editor::ImageFile* mutable_normalimage();
  inline ::Medusa::CoreProto::Editor::ImageFile* release_normalimage();
  inline void set_allocated_normalimage(::Medusa::CoreProto::Editor::ImageFile* normalimage);

  // optional .Medusa.CoreProto.Editor.ImageFile SelectedImage = 13;
  inline bool has_selectedimage() const;
  inline void clear_selectedimage();
  static const int kSelectedImageFieldNumber = 13;
  inline const ::Medusa::CoreProto::Editor::ImageFile& selectedimage() const;
  inline ::Medusa::CoreProto::Editor::ImageFile* mutable_selectedimage();
  inline ::Medusa::CoreProto::Editor::ImageFile* release_selectedimage();
  inline void set_allocated_selectedimage(::Medusa::CoreProto::Editor::ImageFile* selectedimage);

  // optional .Medusa.CoreProto.Editor.ImageFile DisabledImage = 14;
  inline bool has_disabledimage() const;
  inline void clear_disabledimage();
  static const int kDisabledImageFieldNumber = 14;
  inline const ::Medusa::CoreProto::Editor::ImageFile& disabledimage() const;
  inline ::Medusa::CoreProto::Editor::ImageFile* mutable_disabledimage();
  inline ::Medusa::CoreProto::Editor::ImageFile* release_disabledimage();
  inline void set_allocated_disabledimage(::Medusa::CoreProto::Editor::ImageFile* disabledimage);

  // optional .Medusa.CoreProto.Editor.ImageFile DisabledSelectedImage = 15;
  inline bool has_disabledselectedimage() const;
  inline void clear_disabledselectedimage();
  static const int kDisabledSelectedImageFieldNumber = 15;
  inline const ::Medusa::CoreProto::Editor::ImageFile& disabledselectedimage() const;
  inline ::Medusa::CoreProto::Editor::ImageFile* mutable_disabledselectedimage();
  inline ::Medusa::CoreProto::Editor::ImageFile* release_disabledselectedimage();
  inline void set_allocated_disabledselectedimage(::Medusa::CoreProto::Editor::ImageFile* disabledselectedimage);

  // optional string OnLoad = 16;
  inline bool has_onload() const;
  inline void clear_onload();
  static const int kOnLoadFieldNumber = 16;
  inline const ::std::string& onload() const;
  inline void set_onload(const ::std::string& value);
  inline void set_onload(const char* value);
  inline void set_onload(const char* value, size_t size);
  inline ::std::string* mutable_onload();
  inline ::std::string* release_onload();
  inline void set_allocated_onload(::std::string* onload);

  // optional string OnShow = 17;
  inline bool has_onshow() const;
  inline void clear_onshow();
  static const int kOnShowFieldNumber = 17;
  inline const ::std::string& onshow() const;
  inline void set_onshow(const ::std::string& value);
  inline void set_onshow(const char* value);
  inline void set_onshow(const char* value, size_t size);
  inline ::std::string* mutable_onshow();
  inline ::std::string* release_onshow();
  inline void set_allocated_onshow(::std::string* onshow);

  // optional string OnHide = 18;
  inline bool has_onhide() const;
  inline void clear_onhide();
  static const int kOnHideFieldNumber = 18;
  inline const ::std::string& onhide() const;
  inline void set_onhide(const ::std::string& value);
  inline void set_onhide(const char* value);
  inline void set_onhide(const char* value, size_t size);
  inline ::std::string* mutable_onhide();
  inline ::std::string* release_onhide();
  inline void set_allocated_onhide(::std::string* onhide);

  // optional string OnClosed = 19;
  inline bool has_onclosed() const;
  inline void clear_onclosed();
  static const int kOnClosedFieldNumber = 19;
  inline const ::std::string& onclosed() const;
  inline void set_onclosed(const ::std::string& value);
  inline void set_onclosed(const char* value);
  inline void set_onclosed(const char* value, size_t size);
  inline ::std::string* mutable_onclosed();
  inline ::std::string* release_onclosed();
  inline void set_allocated_onclosed(::std::string* onclosed);

  // optional string OnUpdate = 20;
  inline bool has_onupdate() const;
  inline void clear_onupdate();
  static const int kOnUpdateFieldNumber = 20;
  inline const ::std::string& onupdate() const;
  inline void set_onupdate(const ::std::string& value);
  inline void set_onupdate(const char* value);
  inline void set_onupdate(const char* value, size_t size);
  inline ::std::string* mutable_onupdate();
  inline ::std::string* release_onupdate();
  inline void set_allocated_onupdate(::std::string* onupdate);

  // optional string OnTouchBegan = 21;
  inline bool has_ontouchbegan() const;
  inline void clear_ontouchbegan();
  static const int kOnTouchBeganFieldNumber = 21;
  inline const ::std::string& ontouchbegan() const;
  inline void set_ontouchbegan(const ::std::string& value);
  inline void set_ontouchbegan(const char* value);
  inline void set_ontouchbegan(const char* value, size_t size);
  inline ::std::string* mutable_ontouchbegan();
  inline ::std::string* release_ontouchbegan();
  inline void set_allocated_ontouchbegan(::std::string* ontouchbegan);

  // optional string OnTouchMoved = 22;
  inline bool has_ontouchmoved() const;
  inline void clear_ontouchmoved();
  static const int kOnTouchMovedFieldNumber = 22;
  inline const ::std::string& ontouchmoved() const;
  inline void set_ontouchmoved(const ::std::string& value);
  inline void set_ontouchmoved(const char* value);
  inline void set_ontouchmoved(const char* value, size_t size);
  inline ::std::string* mutable_ontouchmoved();
  inline ::std::string* release_ontouchmoved();
  inline void set_allocated_ontouchmoved(::std::string* ontouchmoved);

  // optional string OnTouchEnd = 23;
  inline bool has_ontouchend() const;
  inline void clear_ontouchend();
  static const int kOnTouchEndFieldNumber = 23;
  inline const ::std::string& ontouchend() const;
  inline void set_ontouchend(const ::std::string& value);
  inline void set_ontouchend(const char* value);
  inline void set_ontouchend(const char* value, size_t size);
  inline ::std::string* mutable_ontouchend();
  inline ::std::string* release_ontouchend();
  inline void set_allocated_ontouchend(::std::string* ontouchend);

  // optional string OnClick = 24;
  inline bool has_onclick() const;
  inline void clear_onclick();
  static const int kOnClickFieldNumber = 24;
  inline const ::std::string& onclick() const;
  inline void set_onclick(const ::std::string& value);
  inline void set_onclick(const char* value);
  inline void set_onclick(const char* value, size_t size);
  inline ::std::string* mutable_onclick();
  inline ::std::string* release_onclick();
  inline void set_allocated_onclick(::std::string* onclick);

  // optional string OnEvent = 25;
  inline bool has_onevent() const;
  inline void clear_onevent();
  static const int kOnEventFieldNumber = 25;
  inline const ::std::string& onevent() const;
  inline void set_onevent(const ::std::string& value);
  inline void set_onevent(const char* value);
  inline void set_onevent(const char* value, size_t size);
  inline ::std::string* mutable_onevent();
  inline ::std::string* release_onevent();
  inline void set_allocated_onevent(::std::string* onevent);

  // optional .Medusa.CoreProto.RectF ScissorBox = 26;
  inline bool has_scissorbox() const;
  inline void clear_scissorbox();
  static const int kScissorBoxFieldNumber = 26;
  inline const ::Medusa::CoreProto::RectF& scissorbox() const;
  inline ::Medusa::CoreProto::RectF* mutable_scissorbox();
  inline ::Medusa::CoreProto::RectF* release_scissorbox();
  inline void set_allocated_scissorbox(::Medusa::CoreProto::RectF* scissorbox);

  // optional int32 RenderFlag = 50;
  inline bool has_renderflag() const;
  inline void clear_renderflag();
  static const int kRenderFlagFieldNumber = 50;
  inline ::google::protobuf::int32 renderflag() const;
  inline void set_renderflag(::google::protobuf::int32 value);

  // optional int32 Tag = 51;
  inline bool has_tag() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 51;
  inline ::google::protobuf::int32 tag() const;
  inline void set_tag(::google::protobuf::int32 value);

  // optional string ClickEffect = 101;
  inline bool has_clickeffect() const;
  inline void clear_clickeffect();
  static const int kClickEffectFieldNumber = 101;
  inline const ::std::string& clickeffect() const;
  inline void set_clickeffect(const ::std::string& value);
  inline void set_clickeffect(const char* value);
  inline void set_clickeffect(const char* value, size_t size);
  inline ::std::string* mutable_clickeffect();
  inline ::std::string* release_clickeffect();
  inline void set_allocated_clickeffect(::std::string* clickeffect);

  // optional bool IsLock = 201;
  inline bool has_islock() const;
  inline void clear_islock();
  static const int kIsLockFieldNumber = 201;
  inline bool islock() const;
  inline void set_islock(bool value);

  // optional bool IsHide = 202;
  inline bool has_ishide() const;
  inline void clear_ishide();
  static const int kIsHideFieldNumber = 202;
  inline bool ishide() const;
  inline void set_ishide(bool value);

  // @@protoc_insertion_point(class_scope:Medusa.CoreProto.Editor.Button)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_isproportionpoint();
  inline void clear_has_isproportionpoint();
  inline void set_has_anchor();
  inline void clear_has_anchor();
  inline void set_has_zorder();
  inline void clear_has_zorder();
  inline void set_has_rotation();
  inline void clear_has_rotation();
  inline void set_has_scale();
  inline void clear_has_scale();
  inline void set_has_isfilpx();
  inline void clear_has_isfilpx();
  inline void set_has_isfilpy();
  inline void clear_has_isfilpy();
  inline void set_has_isvisible();
  inline void clear_has_isvisible();
  inline void set_has_normalimage();
  inline void clear_has_normalimage();
  inline void set_has_selectedimage();
  inline void clear_has_selectedimage();
  inline void set_has_disabledimage();
  inline void clear_has_disabledimage();
  inline void set_has_disabledselectedimage();
  inline void clear_has_disabledselectedimage();
  inline void set_has_onload();
  inline void clear_has_onload();
  inline void set_has_onshow();
  inline void clear_has_onshow();
  inline void set_has_onhide();
  inline void clear_has_onhide();
  inline void set_has_onclosed();
  inline void clear_has_onclosed();
  inline void set_has_onupdate();
  inline void clear_has_onupdate();
  inline void set_has_ontouchbegan();
  inline void clear_has_ontouchbegan();
  inline void set_has_ontouchmoved();
  inline void clear_has_ontouchmoved();
  inline void set_has_ontouchend();
  inline void clear_has_ontouchend();
  inline void set_has_onclick();
  inline void clear_has_onclick();
  inline void set_has_onevent();
  inline void clear_has_onevent();
  inline void set_has_scissorbox();
  inline void clear_has_scissorbox();
  inline void set_has_renderflag();
  inline void clear_has_renderflag();
  inline void set_has_tag();
  inline void clear_has_tag();
  inline void set_has_clickeffect();
  inline void clear_has_clickeffect();
  inline void set_has_islock();
  inline void clear_has_islock();
  inline void set_has_ishide();
  inline void clear_has_ishide();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::Medusa::CoreProto::SizeU* size_;
  ::Medusa::CoreProto::PointF* position_;
  ::Medusa::CoreProto::PointF* anchor_;
  ::google::protobuf::int32 zorder_;
  float rotation_;
  ::Medusa::CoreProto::ScaleF* scale_;
  ::Medusa::CoreProto::Editor::ImageFile* normalimage_;
  bool isproportionpoint_;
  bool isfilpx_;
  bool isfilpy_;
  bool isvisible_;
  ::google::protobuf::int32 renderflag_;
  ::Medusa::CoreProto::Editor::ImageFile* selectedimage_;
  ::Medusa::CoreProto::Editor::ImageFile* disabledimage_;
  ::Medusa::CoreProto::Editor::ImageFile* disabledselectedimage_;
  ::std::string* onload_;
  ::std::string* onshow_;
  ::std::string* onhide_;
  ::std::string* onclosed_;
  ::std::string* onupdate_;
  ::std::string* ontouchbegan_;
  ::std::string* ontouchmoved_;
  ::std::string* ontouchend_;
  ::std::string* onclick_;
  ::std::string* onevent_;
  ::Medusa::CoreProto::RectF* scissorbox_;
  ::std::string* clickeffect_;
  ::google::protobuf::int32 tag_;
  bool islock_;
  bool ishide_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(31 + 31) / 32];

  friend void  protobuf_AddDesc_LayerEditor_2eproto();
  friend void protobuf_AssignDesc_LayerEditor_2eproto();
  friend void protobuf_ShutdownFile_LayerEditor_2eproto();

  void InitAsDefaultInstance();
  static Button* default_instance_;
};
// -------------------------------------------------------------------

class Frame : public ::google::protobuf::Message {
 public:
  Frame();
  virtual ~Frame();

  Frame(const Frame& from);

  inline Frame& operator=(const Frame& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Frame& default_instance();

  void Swap(Frame* other);

  // implements Message ----------------------------------------------

  Frame* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Frame& from);
  void MergeFrom(const Frame& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string ID = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIDFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // required .Medusa.CoreProto.SizeU Size = 2;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 2;
  inline const ::Medusa::CoreProto::SizeU& size() const;
  inline ::Medusa::CoreProto::SizeU* mutable_size();
  inline ::Medusa::CoreProto::SizeU* release_size();
  inline void set_allocated_size(::Medusa::CoreProto::SizeU* size);

  // required .Medusa.CoreProto.PointF Position = 3;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 3;
  inline const ::Medusa::CoreProto::PointF& position() const;
  inline ::Medusa::CoreProto::PointF* mutable_position();
  inline ::Medusa::CoreProto::PointF* release_position();
  inline void set_allocated_position(::Medusa::CoreProto::PointF* position);

  // required bool IsProportionPoint = 4;
  inline bool has_isproportionpoint() const;
  inline void clear_isproportionpoint();
  static const int kIsProportionPointFieldNumber = 4;
  inline bool isproportionpoint() const;
  inline void set_isproportionpoint(bool value);

  // required .Medusa.CoreProto.PointF Anchor = 5;
  inline bool has_anchor() const;
  inline void clear_anchor();
  static const int kAnchorFieldNumber = 5;
  inline const ::Medusa::CoreProto::PointF& anchor() const;
  inline ::Medusa::CoreProto::PointF* mutable_anchor();
  inline ::Medusa::CoreProto::PointF* release_anchor();
  inline void set_allocated_anchor(::Medusa::CoreProto::PointF* anchor);

  // required int32 ZOrder = 6;
  inline bool has_zorder() const;
  inline void clear_zorder();
  static const int kZOrderFieldNumber = 6;
  inline ::google::protobuf::int32 zorder() const;
  inline void set_zorder(::google::protobuf::int32 value);

  // optional float Rotation = 7;
  inline bool has_rotation() const;
  inline void clear_rotation();
  static const int kRotationFieldNumber = 7;
  inline float rotation() const;
  inline void set_rotation(float value);

  // optional .Medusa.CoreProto.ScaleF Scale = 8;
  inline bool has_scale() const;
  inline void clear_scale();
  static const int kScaleFieldNumber = 8;
  inline const ::Medusa::CoreProto::ScaleF& scale() const;
  inline ::Medusa::CoreProto::ScaleF* mutable_scale();
  inline ::Medusa::CoreProto::ScaleF* release_scale();
  inline void set_allocated_scale(::Medusa::CoreProto::ScaleF* scale);

  // optional bool IsFilpX = 9;
  inline bool has_isfilpx() const;
  inline void clear_isfilpx();
  static const int kIsFilpXFieldNumber = 9;
  inline bool isfilpx() const;
  inline void set_isfilpx(bool value);

  // optional bool IsFilpY = 10;
  inline bool has_isfilpy() const;
  inline void clear_isfilpy();
  static const int kIsFilpYFieldNumber = 10;
  inline bool isfilpy() const;
  inline void set_isfilpy(bool value);

  // optional float Parallax = 11;
  inline bool has_parallax() const;
  inline void clear_parallax();
  static const int kParallaxFieldNumber = 11;
  inline float parallax() const;
  inline void set_parallax(float value);

  // optional int32 UserValue = 20;
  inline bool has_uservalue() const;
  inline void clear_uservalue();
  static const int kUserValueFieldNumber = 20;
  inline ::google::protobuf::int32 uservalue() const;
  inline void set_uservalue(::google::protobuf::int32 value);

  // optional string UserString = 21;
  inline bool has_userstring() const;
  inline void clear_userstring();
  static const int kUserStringFieldNumber = 21;
  inline const ::std::string& userstring() const;
  inline void set_userstring(const ::std::string& value);
  inline void set_userstring(const char* value);
  inline void set_userstring(const char* value, size_t size);
  inline ::std::string* mutable_userstring();
  inline ::std::string* release_userstring();
  inline void set_allocated_userstring(::std::string* userstring);

  // optional .Medusa.CoreProto.RectF ScissorBox = 22;
  inline bool has_scissorbox() const;
  inline void clear_scissorbox();
  static const int kScissorBoxFieldNumber = 22;
  inline const ::Medusa::CoreProto::RectF& scissorbox() const;
  inline ::Medusa::CoreProto::RectF* mutable_scissorbox();
  inline ::Medusa::CoreProto::RectF* release_scissorbox();
  inline void set_allocated_scissorbox(::Medusa::CoreProto::RectF* scissorbox);

  // optional int32 RenderFlag = 50;
  inline bool has_renderflag() const;
  inline void clear_renderflag();
  static const int kRenderFlagFieldNumber = 50;
  inline ::google::protobuf::int32 renderflag() const;
  inline void set_renderflag(::google::protobuf::int32 value);

  // optional int32 Tag = 51;
  inline bool has_tag() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 51;
  inline ::google::protobuf::int32 tag() const;
  inline void set_tag(::google::protobuf::int32 value);

  // optional string ClickEffect = 101;
  inline bool has_clickeffect() const;
  inline void clear_clickeffect();
  static const int kClickEffectFieldNumber = 101;
  inline const ::std::string& clickeffect() const;
  inline void set_clickeffect(const ::std::string& value);
  inline void set_clickeffect(const char* value);
  inline void set_clickeffect(const char* value, size_t size);
  inline ::std::string* mutable_clickeffect();
  inline ::std::string* release_clickeffect();
  inline void set_allocated_clickeffect(::std::string* clickeffect);

  // optional bool IsLock = 201;
  inline bool has_islock() const;
  inline void clear_islock();
  static const int kIsLockFieldNumber = 201;
  inline bool islock() const;
  inline void set_islock(bool value);

  // optional bool IsHide = 202;
  inline bool has_ishide() const;
  inline void clear_ishide();
  static const int kIsHideFieldNumber = 202;
  inline bool ishide() const;
  inline void set_ishide(bool value);

  // @@protoc_insertion_point(class_scope:Medusa.CoreProto.Editor.Frame)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_isproportionpoint();
  inline void clear_has_isproportionpoint();
  inline void set_has_anchor();
  inline void clear_has_anchor();
  inline void set_has_zorder();
  inline void clear_has_zorder();
  inline void set_has_rotation();
  inline void clear_has_rotation();
  inline void set_has_scale();
  inline void clear_has_scale();
  inline void set_has_isfilpx();
  inline void clear_has_isfilpx();
  inline void set_has_isfilpy();
  inline void clear_has_isfilpy();
  inline void set_has_parallax();
  inline void clear_has_parallax();
  inline void set_has_uservalue();
  inline void clear_has_uservalue();
  inline void set_has_userstring();
  inline void clear_has_userstring();
  inline void set_has_scissorbox();
  inline void clear_has_scissorbox();
  inline void set_has_renderflag();
  inline void clear_has_renderflag();
  inline void set_has_tag();
  inline void clear_has_tag();
  inline void set_has_clickeffect();
  inline void clear_has_clickeffect();
  inline void set_has_islock();
  inline void clear_has_islock();
  inline void set_has_ishide();
  inline void clear_has_ishide();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::Medusa::CoreProto::SizeU* size_;
  ::Medusa::CoreProto::PointF* position_;
  ::Medusa::CoreProto::PointF* anchor_;
  ::google::protobuf::int32 zorder_;
  float rotation_;
  ::Medusa::CoreProto::ScaleF* scale_;
  bool isproportionpoint_;
  bool isfilpx_;
  bool isfilpy_;
  bool islock_;
  float parallax_;
  ::std::string* userstring_;
  ::google::protobuf::int32 uservalue_;
  ::google::protobuf::int32 renderflag_;
  ::Medusa::CoreProto::RectF* scissorbox_;
  ::std::string* clickeffect_;
  ::google::protobuf::int32 tag_;
  bool ishide_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(19 + 31) / 32];

  friend void  protobuf_AddDesc_LayerEditor_2eproto();
  friend void protobuf_AssignDesc_LayerEditor_2eproto();
  friend void protobuf_ShutdownFile_LayerEditor_2eproto();

  void InitAsDefaultInstance();
  static Frame* default_instance_;
};
// -------------------------------------------------------------------

class Label : public ::google::protobuf::Message {
 public:
  Label();
  virtual ~Label();

  Label(const Label& from);

  inline Label& operator=(const Label& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Label& default_instance();

  void Swap(Label* other);

  // implements Message ----------------------------------------------

  Label* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Label& from);
  void MergeFrom(const Label& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string ID = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIDFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // required .Medusa.CoreProto.SizeU Size = 2;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 2;
  inline const ::Medusa::CoreProto::SizeU& size() const;
  inline ::Medusa::CoreProto::SizeU* mutable_size();
  inline ::Medusa::CoreProto::SizeU* release_size();
  inline void set_allocated_size(::Medusa::CoreProto::SizeU* size);

  // required .Medusa.CoreProto.PointF Position = 3;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 3;
  inline const ::Medusa::CoreProto::PointF& position() const;
  inline ::Medusa::CoreProto::PointF* mutable_position();
  inline ::Medusa::CoreProto::PointF* release_position();
  inline void set_allocated_position(::Medusa::CoreProto::PointF* position);

  // required bool IsProportionPoint = 4;
  inline bool has_isproportionpoint() const;
  inline void clear_isproportionpoint();
  static const int kIsProportionPointFieldNumber = 4;
  inline bool isproportionpoint() const;
  inline void set_isproportionpoint(bool value);

  // required .Medusa.CoreProto.PointF Anchor = 5;
  inline bool has_anchor() const;
  inline void clear_anchor();
  static const int kAnchorFieldNumber = 5;
  inline const ::Medusa::CoreProto::PointF& anchor() const;
  inline ::Medusa::CoreProto::PointF* mutable_anchor();
  inline ::Medusa::CoreProto::PointF* release_anchor();
  inline void set_allocated_anchor(::Medusa::CoreProto::PointF* anchor);

  // required int32 ZOrder = 6;
  inline bool has_zorder() const;
  inline void clear_zorder();
  static const int kZOrderFieldNumber = 6;
  inline ::google::protobuf::int32 zorder() const;
  inline void set_zorder(::google::protobuf::int32 value);

  // optional float Rotation = 7;
  inline bool has_rotation() const;
  inline void clear_rotation();
  static const int kRotationFieldNumber = 7;
  inline float rotation() const;
  inline void set_rotation(float value);

  // optional .Medusa.CoreProto.ScaleF Scale = 8;
  inline bool has_scale() const;
  inline void clear_scale();
  static const int kScaleFieldNumber = 8;
  inline const ::Medusa::CoreProto::ScaleF& scale() const;
  inline ::Medusa::CoreProto::ScaleF* mutable_scale();
  inline ::Medusa::CoreProto::ScaleF* release_scale();
  inline void set_allocated_scale(::Medusa::CoreProto::ScaleF* scale);

  // required bool IsVisible = 9;
  inline bool has_isvisible() const;
  inline void clear_isvisible();
  static const int kIsVisibleFieldNumber = 9;
  inline bool isvisible() const;
  inline void set_isvisible(bool value);

  // required .Medusa.CoreProto.FileId FontName = 11;
  inline bool has_fontname() const;
  inline void clear_fontname();
  static const int kFontNameFieldNumber = 11;
  inline const ::Medusa::CoreProto::FileId& fontname() const;
  inline ::Medusa::CoreProto::FileId* mutable_fontname();
  inline ::Medusa::CoreProto::FileId* release_fontname();
  inline void set_allocated_fontname(::Medusa::CoreProto::FileId* fontname);

  // required uint32 FontSize = 12;
  inline bool has_fontsize() const;
  inline void clear_fontsize();
  static const int kFontSizeFieldNumber = 12;
  inline ::google::protobuf::uint32 fontsize() const;
  inline void set_fontsize(::google::protobuf::uint32 value);

  // required string Text = 13;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 13;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  inline void set_allocated_text(::std::string* text);

  // optional .Medusa.CoreProto.ColorF Color = 14;
  inline bool has_color() const;
  inline void clear_color();
  static const int kColorFieldNumber = 14;
  inline const ::Medusa::CoreProto::ColorF& color() const;
  inline ::Medusa::CoreProto::ColorF* mutable_color();
  inline ::Medusa::CoreProto::ColorF* release_color();
  inline void set_allocated_color(::Medusa::CoreProto::ColorF* color);

  // required .Medusa.CoreProto.Editor.TextAlignmentType AlignmentType = 10;
  inline bool has_alignmenttype() const;
  inline void clear_alignmenttype();
  static const int kAlignmentTypeFieldNumber = 10;
  inline ::Medusa::CoreProto::Editor::TextAlignmentType alignmenttype() const;
  inline void set_alignmenttype(::Medusa::CoreProto::Editor::TextAlignmentType value);

  // optional string OnLoad = 15;
  inline bool has_onload() const;
  inline void clear_onload();
  static const int kOnLoadFieldNumber = 15;
  inline const ::std::string& onload() const;
  inline void set_onload(const ::std::string& value);
  inline void set_onload(const char* value);
  inline void set_onload(const char* value, size_t size);
  inline ::std::string* mutable_onload();
  inline ::std::string* release_onload();
  inline void set_allocated_onload(::std::string* onload);

  // optional string OnShow = 16;
  inline bool has_onshow() const;
  inline void clear_onshow();
  static const int kOnShowFieldNumber = 16;
  inline const ::std::string& onshow() const;
  inline void set_onshow(const ::std::string& value);
  inline void set_onshow(const char* value);
  inline void set_onshow(const char* value, size_t size);
  inline ::std::string* mutable_onshow();
  inline ::std::string* release_onshow();
  inline void set_allocated_onshow(::std::string* onshow);

  // optional string OnHide = 17;
  inline bool has_onhide() const;
  inline void clear_onhide();
  static const int kOnHideFieldNumber = 17;
  inline const ::std::string& onhide() const;
  inline void set_onhide(const ::std::string& value);
  inline void set_onhide(const char* value);
  inline void set_onhide(const char* value, size_t size);
  inline ::std::string* mutable_onhide();
  inline ::std::string* release_onhide();
  inline void set_allocated_onhide(::std::string* onhide);

  // optional string OnClosed = 18;
  inline bool has_onclosed() const;
  inline void clear_onclosed();
  static const int kOnClosedFieldNumber = 18;
  inline const ::std::string& onclosed() const;
  inline void set_onclosed(const ::std::string& value);
  inline void set_onclosed(const char* value);
  inline void set_onclosed(const char* value, size_t size);
  inline ::std::string* mutable_onclosed();
  inline ::std::string* release_onclosed();
  inline void set_allocated_onclosed(::std::string* onclosed);

  // optional string OnUpdate = 19;
  inline bool has_onupdate() const;
  inline void clear_onupdate();
  static const int kOnUpdateFieldNumber = 19;
  inline const ::std::string& onupdate() const;
  inline void set_onupdate(const ::std::string& value);
  inline void set_onupdate(const char* value);
  inline void set_onupdate(const char* value, size_t size);
  inline ::std::string* mutable_onupdate();
  inline ::std::string* release_onupdate();
  inline void set_allocated_onupdate(::std::string* onupdate);

  // optional string OnEvent = 20;
  inline bool has_onevent() const;
  inline void clear_onevent();
  static const int kOnEventFieldNumber = 20;
  inline const ::std::string& onevent() const;
  inline void set_onevent(const ::std::string& value);
  inline void set_onevent(const char* value);
  inline void set_onevent(const char* value, size_t size);
  inline ::std::string* mutable_onevent();
  inline ::std::string* release_onevent();
  inline void set_allocated_onevent(::std::string* onevent);

  // optional .Medusa.CoreProto.RectF ScissorBox = 21;
  inline bool has_scissorbox() const;
  inline void clear_scissorbox();
  static const int kScissorBoxFieldNumber = 21;
  inline const ::Medusa::CoreProto::RectF& scissorbox() const;
  inline ::Medusa::CoreProto::RectF* mutable_scissorbox();
  inline ::Medusa::CoreProto::RectF* release_scissorbox();
  inline void set_allocated_scissorbox(::Medusa::CoreProto::RectF* scissorbox);

  // optional int32 Tag = 51;
  inline bool has_tag() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 51;
  inline ::google::protobuf::int32 tag() const;
  inline void set_tag(::google::protobuf::int32 value);

  // optional float StrokeSize = 52;
  inline bool has_strokesize() const;
  inline void clear_strokesize();
  static const int kStrokeSizeFieldNumber = 52;
  inline float strokesize() const;
  inline void set_strokesize(float value);

  // optional .Medusa.CoreProto.PointF ShadowOffset = 53;
  inline bool has_shadowoffset() const;
  inline void clear_shadowoffset();
  static const int kShadowOffsetFieldNumber = 53;
  inline const ::Medusa::CoreProto::PointF& shadowoffset() const;
  inline ::Medusa::CoreProto::PointF* mutable_shadowoffset();
  inline ::Medusa::CoreProto::PointF* release_shadowoffset();
  inline void set_allocated_shadowoffset(::Medusa::CoreProto::PointF* shadowoffset);

  // optional .Medusa.CoreProto.ColorF ShadowColor = 54;
  inline bool has_shadowcolor() const;
  inline void clear_shadowcolor();
  static const int kShadowColorFieldNumber = 54;
  inline const ::Medusa::CoreProto::ColorF& shadowcolor() const;
  inline ::Medusa::CoreProto::ColorF* mutable_shadowcolor();
  inline ::Medusa::CoreProto::ColorF* release_shadowcolor();
  inline void set_allocated_shadowcolor(::Medusa::CoreProto::ColorF* shadowcolor);

  // optional float ShadowBlur = 55;
  inline bool has_shadowblur() const;
  inline void clear_shadowblur();
  static const int kShadowBlurFieldNumber = 55;
  inline float shadowblur() const;
  inline void set_shadowblur(float value);

  // optional bool IsLock = 201;
  inline bool has_islock() const;
  inline void clear_islock();
  static const int kIsLockFieldNumber = 201;
  inline bool islock() const;
  inline void set_islock(bool value);

  // optional bool IsHide = 202;
  inline bool has_ishide() const;
  inline void clear_ishide();
  static const int kIsHideFieldNumber = 202;
  inline bool ishide() const;
  inline void set_ishide(bool value);

  // @@protoc_insertion_point(class_scope:Medusa.CoreProto.Editor.Label)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_isproportionpoint();
  inline void clear_has_isproportionpoint();
  inline void set_has_anchor();
  inline void clear_has_anchor();
  inline void set_has_zorder();
  inline void clear_has_zorder();
  inline void set_has_rotation();
  inline void clear_has_rotation();
  inline void set_has_scale();
  inline void clear_has_scale();
  inline void set_has_isvisible();
  inline void clear_has_isvisible();
  inline void set_has_fontname();
  inline void clear_has_fontname();
  inline void set_has_fontsize();
  inline void clear_has_fontsize();
  inline void set_has_text();
  inline void clear_has_text();
  inline void set_has_color();
  inline void clear_has_color();
  inline void set_has_alignmenttype();
  inline void clear_has_alignmenttype();
  inline void set_has_onload();
  inline void clear_has_onload();
  inline void set_has_onshow();
  inline void clear_has_onshow();
  inline void set_has_onhide();
  inline void clear_has_onhide();
  inline void set_has_onclosed();
  inline void clear_has_onclosed();
  inline void set_has_onupdate();
  inline void clear_has_onupdate();
  inline void set_has_onevent();
  inline void clear_has_onevent();
  inline void set_has_scissorbox();
  inline void clear_has_scissorbox();
  inline void set_has_tag();
  inline void clear_has_tag();
  inline void set_has_strokesize();
  inline void clear_has_strokesize();
  inline void set_has_shadowoffset();
  inline void clear_has_shadowoffset();
  inline void set_has_shadowcolor();
  inline void clear_has_shadowcolor();
  inline void set_has_shadowblur();
  inline void clear_has_shadowblur();
  inline void set_has_islock();
  inline void clear_has_islock();
  inline void set_has_ishide();
  inline void clear_has_ishide();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::Medusa::CoreProto::SizeU* size_;
  ::Medusa::CoreProto::PointF* position_;
  ::Medusa::CoreProto::PointF* anchor_;
  ::google::protobuf::int32 zorder_;
  float rotation_;
  ::Medusa::CoreProto::ScaleF* scale_;
  ::Medusa::CoreProto::FileId* fontname_;
  ::std::string* text_;
  ::google::protobuf::uint32 fontsize_;
  int alignmenttype_;
  ::Medusa::CoreProto::ColorF* color_;
  ::std::string* onload_;
  ::std::string* onshow_;
  ::std::string* onhide_;
  ::std::string* onclosed_;
  bool isproportionpoint_;
  bool isvisible_;
  bool islock_;
  bool ishide_;
  ::google::protobuf::int32 tag_;
  ::std::string* onupdate_;
  ::std::string* onevent_;
  ::Medusa::CoreProto::RectF* scissorbox_;
  ::Medusa::CoreProto::PointF* shadowoffset_;
  float strokesize_;
  float shadowblur_;
  ::Medusa::CoreProto::ColorF* shadowcolor_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(28 + 31) / 32];

  friend void  protobuf_AddDesc_LayerEditor_2eproto();
  friend void protobuf_AssignDesc_LayerEditor_2eproto();
  friend void protobuf_ShutdownFile_LayerEditor_2eproto();

  void InitAsDefaultInstance();
  static Label* default_instance_;
};
// -------------------------------------------------------------------

class EditBox : public ::google::protobuf::Message {
 public:
  EditBox();
  virtual ~EditBox();

  EditBox(const EditBox& from);

  inline EditBox& operator=(const EditBox& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EditBox& default_instance();

  void Swap(EditBox* other);

  // implements Message ----------------------------------------------

  EditBox* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EditBox& from);
  void MergeFrom(const EditBox& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef EditBox_EditBoxKeyboardReturnType EditBoxKeyboardReturnType;
  static const EditBoxKeyboardReturnType Default = EditBox_EditBoxKeyboardReturnType_Default;
  static const EditBoxKeyboardReturnType Done = EditBox_EditBoxKeyboardReturnType_Done;
  static const EditBoxKeyboardReturnType Send = EditBox_EditBoxKeyboardReturnType_Send;
  static const EditBoxKeyboardReturnType Search = EditBox_EditBoxKeyboardReturnType_Search;
  static const EditBoxKeyboardReturnType Go = EditBox_EditBoxKeyboardReturnType_Go;
  static inline bool EditBoxKeyboardReturnType_IsValid(int value) {
    return EditBox_EditBoxKeyboardReturnType_IsValid(value);
  }
  static const EditBoxKeyboardReturnType EditBoxKeyboardReturnType_MIN =
    EditBox_EditBoxKeyboardReturnType_EditBoxKeyboardReturnType_MIN;
  static const EditBoxKeyboardReturnType EditBoxKeyboardReturnType_MAX =
    EditBox_EditBoxKeyboardReturnType_EditBoxKeyboardReturnType_MAX;
  static const int EditBoxKeyboardReturnType_ARRAYSIZE =
    EditBox_EditBoxKeyboardReturnType_EditBoxKeyboardReturnType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EditBoxKeyboardReturnType_descriptor() {
    return EditBox_EditBoxKeyboardReturnType_descriptor();
  }
  static inline const ::std::string& EditBoxKeyboardReturnType_Name(EditBoxKeyboardReturnType value) {
    return EditBox_EditBoxKeyboardReturnType_Name(value);
  }
  static inline bool EditBoxKeyboardReturnType_Parse(const ::std::string& name,
      EditBoxKeyboardReturnType* value) {
    return EditBox_EditBoxKeyboardReturnType_Parse(name, value);
  }

  typedef EditBox_EditBoxInputMode EditBoxInputMode;
  static const EditBoxInputMode Any = EditBox_EditBoxInputMode_Any;
  static const EditBoxInputMode EmailAddr = EditBox_EditBoxInputMode_EmailAddr;
  static const EditBoxInputMode Numeric = EditBox_EditBoxInputMode_Numeric;
  static const EditBoxInputMode PhoneNumber = EditBox_EditBoxInputMode_PhoneNumber;
  static const EditBoxInputMode Url = EditBox_EditBoxInputMode_Url;
  static const EditBoxInputMode Decimal = EditBox_EditBoxInputMode_Decimal;
  static const EditBoxInputMode SingleLine = EditBox_EditBoxInputMode_SingleLine;
  static inline bool EditBoxInputMode_IsValid(int value) {
    return EditBox_EditBoxInputMode_IsValid(value);
  }
  static const EditBoxInputMode EditBoxInputMode_MIN =
    EditBox_EditBoxInputMode_EditBoxInputMode_MIN;
  static const EditBoxInputMode EditBoxInputMode_MAX =
    EditBox_EditBoxInputMode_EditBoxInputMode_MAX;
  static const int EditBoxInputMode_ARRAYSIZE =
    EditBox_EditBoxInputMode_EditBoxInputMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EditBoxInputMode_descriptor() {
    return EditBox_EditBoxInputMode_descriptor();
  }
  static inline const ::std::string& EditBoxInputMode_Name(EditBoxInputMode value) {
    return EditBox_EditBoxInputMode_Name(value);
  }
  static inline bool EditBoxInputMode_Parse(const ::std::string& name,
      EditBoxInputMode* value) {
    return EditBox_EditBoxInputMode_Parse(name, value);
  }

  typedef EditBox_EditBoxInputFlag EditBoxInputFlag;
  static const EditBoxInputFlag Password = EditBox_EditBoxInputFlag_Password;
  static const EditBoxInputFlag Sensitive = EditBox_EditBoxInputFlag_Sensitive;
  static const EditBoxInputFlag InitialCapsWord = EditBox_EditBoxInputFlag_InitialCapsWord;
  static const EditBoxInputFlag InitialCapsSentence = EditBox_EditBoxInputFlag_InitialCapsSentence;
  static const EditBoxInputFlag InitialCapsAllCharacters = EditBox_EditBoxInputFlag_InitialCapsAllCharacters;
  static inline bool EditBoxInputFlag_IsValid(int value) {
    return EditBox_EditBoxInputFlag_IsValid(value);
  }
  static const EditBoxInputFlag EditBoxInputFlag_MIN =
    EditBox_EditBoxInputFlag_EditBoxInputFlag_MIN;
  static const EditBoxInputFlag EditBoxInputFlag_MAX =
    EditBox_EditBoxInputFlag_EditBoxInputFlag_MAX;
  static const int EditBoxInputFlag_ARRAYSIZE =
    EditBox_EditBoxInputFlag_EditBoxInputFlag_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EditBoxInputFlag_descriptor() {
    return EditBox_EditBoxInputFlag_descriptor();
  }
  static inline const ::std::string& EditBoxInputFlag_Name(EditBoxInputFlag value) {
    return EditBox_EditBoxInputFlag_Name(value);
  }
  static inline bool EditBoxInputFlag_Parse(const ::std::string& name,
      EditBoxInputFlag* value) {
    return EditBox_EditBoxInputFlag_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string ID = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIDFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // required .Medusa.CoreProto.SizeU Size = 2;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 2;
  inline const ::Medusa::CoreProto::SizeU& size() const;
  inline ::Medusa::CoreProto::SizeU* mutable_size();
  inline ::Medusa::CoreProto::SizeU* release_size();
  inline void set_allocated_size(::Medusa::CoreProto::SizeU* size);

  // required .Medusa.CoreProto.PointF Position = 3;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 3;
  inline const ::Medusa::CoreProto::PointF& position() const;
  inline ::Medusa::CoreProto::PointF* mutable_position();
  inline ::Medusa::CoreProto::PointF* release_position();
  inline void set_allocated_position(::Medusa::CoreProto::PointF* position);

  // required bool IsProportionPoint = 4;
  inline bool has_isproportionpoint() const;
  inline void clear_isproportionpoint();
  static const int kIsProportionPointFieldNumber = 4;
  inline bool isproportionpoint() const;
  inline void set_isproportionpoint(bool value);

  // required .Medusa.CoreProto.PointF Anchor = 5;
  inline bool has_anchor() const;
  inline void clear_anchor();
  static const int kAnchorFieldNumber = 5;
  inline const ::Medusa::CoreProto::PointF& anchor() const;
  inline ::Medusa::CoreProto::PointF* mutable_anchor();
  inline ::Medusa::CoreProto::PointF* release_anchor();
  inline void set_allocated_anchor(::Medusa::CoreProto::PointF* anchor);

  // required int32 ZOrder = 6;
  inline bool has_zorder() const;
  inline void clear_zorder();
  static const int kZOrderFieldNumber = 6;
  inline ::google::protobuf::int32 zorder() const;
  inline void set_zorder(::google::protobuf::int32 value);

  // optional float Rotation = 7;
  inline bool has_rotation() const;
  inline void clear_rotation();
  static const int kRotationFieldNumber = 7;
  inline float rotation() const;
  inline void set_rotation(float value);

  // optional .Medusa.CoreProto.ScaleF Scale = 8;
  inline bool has_scale() const;
  inline void clear_scale();
  static const int kScaleFieldNumber = 8;
  inline const ::Medusa::CoreProto::ScaleF& scale() const;
  inline ::Medusa::CoreProto::ScaleF* mutable_scale();
  inline ::Medusa::CoreProto::ScaleF* release_scale();
  inline void set_allocated_scale(::Medusa::CoreProto::ScaleF* scale);

  // required bool IsVisible = 9;
  inline bool has_isvisible() const;
  inline void clear_isvisible();
  static const int kIsVisibleFieldNumber = 9;
  inline bool isvisible() const;
  inline void set_isvisible(bool value);

  // required .Medusa.CoreProto.FileId FontName = 10;
  inline bool has_fontname() const;
  inline void clear_fontname();
  static const int kFontNameFieldNumber = 10;
  inline const ::Medusa::CoreProto::FileId& fontname() const;
  inline ::Medusa::CoreProto::FileId* mutable_fontname();
  inline ::Medusa::CoreProto::FileId* release_fontname();
  inline void set_allocated_fontname(::Medusa::CoreProto::FileId* fontname);

  // required uint32 FontSize = 11;
  inline bool has_fontsize() const;
  inline void clear_fontsize();
  static const int kFontSizeFieldNumber = 11;
  inline ::google::protobuf::uint32 fontsize() const;
  inline void set_fontsize(::google::protobuf::uint32 value);

  // optional string Text = 12;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 12;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  inline void set_allocated_text(::std::string* text);

  // optional .Medusa.CoreProto.ColorF Color = 13;
  inline bool has_color() const;
  inline void clear_color();
  static const int kColorFieldNumber = 13;
  inline const ::Medusa::CoreProto::ColorF& color() const;
  inline ::Medusa::CoreProto::ColorF* mutable_color();
  inline ::Medusa::CoreProto::ColorF* release_color();
  inline void set_allocated_color(::Medusa::CoreProto::ColorF* color);

  // required .Medusa.CoreProto.Editor.ImageFile BackgroundImage = 14;
  inline bool has_backgroundimage() const;
  inline void clear_backgroundimage();
  static const int kBackgroundImageFieldNumber = 14;
  inline const ::Medusa::CoreProto::Editor::ImageFile& backgroundimage() const;
  inline ::Medusa::CoreProto::Editor::ImageFile* mutable_backgroundimage();
  inline ::Medusa::CoreProto::Editor::ImageFile* release_backgroundimage();
  inline void set_allocated_backgroundimage(::Medusa::CoreProto::Editor::ImageFile* backgroundimage);

  // required .Medusa.CoreProto.Editor.TextAlignmentType AlignmentType = 18;
  inline bool has_alignmenttype() const;
  inline void clear_alignmenttype();
  static const int kAlignmentTypeFieldNumber = 18;
  inline ::Medusa::CoreProto::Editor::TextAlignmentType alignmenttype() const;
  inline void set_alignmenttype(::Medusa::CoreProto::Editor::TextAlignmentType value);

  // required .Medusa.CoreProto.Editor.EditBox.EditBoxKeyboardReturnType KeyboardReturnType = 19;
  inline bool has_keyboardreturntype() const;
  inline void clear_keyboardreturntype();
  static const int kKeyboardReturnTypeFieldNumber = 19;
  inline ::Medusa::CoreProto::Editor::EditBox_EditBoxKeyboardReturnType keyboardreturntype() const;
  inline void set_keyboardreturntype(::Medusa::CoreProto::Editor::EditBox_EditBoxKeyboardReturnType value);

  // required .Medusa.CoreProto.Editor.EditBox.EditBoxInputMode InputMode = 20;
  inline bool has_inputmode() const;
  inline void clear_inputmode();
  static const int kInputModeFieldNumber = 20;
  inline ::Medusa::CoreProto::Editor::EditBox_EditBoxInputMode inputmode() const;
  inline void set_inputmode(::Medusa::CoreProto::Editor::EditBox_EditBoxInputMode value);

  // required .Medusa.CoreProto.Editor.EditBox.EditBoxInputFlag InputFlag = 21;
  inline bool has_inputflag() const;
  inline void clear_inputflag();
  static const int kInputFlagFieldNumber = 21;
  inline ::Medusa::CoreProto::Editor::EditBox_EditBoxInputFlag inputflag() const;
  inline void set_inputflag(::Medusa::CoreProto::Editor::EditBox_EditBoxInputFlag value);

  // optional uint32 CharacterNum = 25;
  inline bool has_characternum() const;
  inline void clear_characternum();
  static const int kCharacterNumFieldNumber = 25;
  inline ::google::protobuf::uint32 characternum() const;
  inline void set_characternum(::google::protobuf::uint32 value);

  // optional string MinLineNum = 26;
  inline bool has_minlinenum() const;
  inline void clear_minlinenum();
  static const int kMinLineNumFieldNumber = 26;
  inline const ::std::string& minlinenum() const;
  inline void set_minlinenum(const ::std::string& value);
  inline void set_minlinenum(const char* value);
  inline void set_minlinenum(const char* value, size_t size);
  inline ::std::string* mutable_minlinenum();
  inline ::std::string* release_minlinenum();
  inline void set_allocated_minlinenum(::std::string* minlinenum);

  // optional string MaxLineNum = 27;
  inline bool has_maxlinenum() const;
  inline void clear_maxlinenum();
  static const int kMaxLineNumFieldNumber = 27;
  inline const ::std::string& maxlinenum() const;
  inline void set_maxlinenum(const ::std::string& value);
  inline void set_maxlinenum(const char* value);
  inline void set_maxlinenum(const char* value, size_t size);
  inline ::std::string* mutable_maxlinenum();
  inline ::std::string* release_maxlinenum();
  inline void set_allocated_maxlinenum(::std::string* maxlinenum);

  // optional string OnLoad = 30;
  inline bool has_onload() const;
  inline void clear_onload();
  static const int kOnLoadFieldNumber = 30;
  inline const ::std::string& onload() const;
  inline void set_onload(const ::std::string& value);
  inline void set_onload(const char* value);
  inline void set_onload(const char* value, size_t size);
  inline ::std::string* mutable_onload();
  inline ::std::string* release_onload();
  inline void set_allocated_onload(::std::string* onload);

  // optional string OnShow = 31;
  inline bool has_onshow() const;
  inline void clear_onshow();
  static const int kOnShowFieldNumber = 31;
  inline const ::std::string& onshow() const;
  inline void set_onshow(const ::std::string& value);
  inline void set_onshow(const char* value);
  inline void set_onshow(const char* value, size_t size);
  inline ::std::string* mutable_onshow();
  inline ::std::string* release_onshow();
  inline void set_allocated_onshow(::std::string* onshow);

  // optional string OnHide = 32;
  inline bool has_onhide() const;
  inline void clear_onhide();
  static const int kOnHideFieldNumber = 32;
  inline const ::std::string& onhide() const;
  inline void set_onhide(const ::std::string& value);
  inline void set_onhide(const char* value);
  inline void set_onhide(const char* value, size_t size);
  inline ::std::string* mutable_onhide();
  inline ::std::string* release_onhide();
  inline void set_allocated_onhide(::std::string* onhide);

  // optional string OnClosed = 33;
  inline bool has_onclosed() const;
  inline void clear_onclosed();
  static const int kOnClosedFieldNumber = 33;
  inline const ::std::string& onclosed() const;
  inline void set_onclosed(const ::std::string& value);
  inline void set_onclosed(const char* value);
  inline void set_onclosed(const char* value, size_t size);
  inline ::std::string* mutable_onclosed();
  inline ::std::string* release_onclosed();
  inline void set_allocated_onclosed(::std::string* onclosed);

  // optional string OnUpdate = 34;
  inline bool has_onupdate() const;
  inline void clear_onupdate();
  static const int kOnUpdateFieldNumber = 34;
  inline const ::std::string& onupdate() const;
  inline void set_onupdate(const ::std::string& value);
  inline void set_onupdate(const char* value);
  inline void set_onupdate(const char* value, size_t size);
  inline ::std::string* mutable_onupdate();
  inline ::std::string* release_onupdate();
  inline void set_allocated_onupdate(::std::string* onupdate);

  // optional string OnChar = 35;
  inline bool has_onchar() const;
  inline void clear_onchar();
  static const int kOnCharFieldNumber = 35;
  inline const ::std::string& onchar() const;
  inline void set_onchar(const ::std::string& value);
  inline void set_onchar(const char* value);
  inline void set_onchar(const char* value, size_t size);
  inline ::std::string* mutable_onchar();
  inline ::std::string* release_onchar();
  inline void set_allocated_onchar(::std::string* onchar);

  // optional string OnEvent = 36;
  inline bool has_onevent() const;
  inline void clear_onevent();
  static const int kOnEventFieldNumber = 36;
  inline const ::std::string& onevent() const;
  inline void set_onevent(const ::std::string& value);
  inline void set_onevent(const char* value);
  inline void set_onevent(const char* value, size_t size);
  inline ::std::string* mutable_onevent();
  inline ::std::string* release_onevent();
  inline void set_allocated_onevent(::std::string* onevent);

  // optional .Medusa.CoreProto.RectF ScissorBox = 37;
  inline bool has_scissorbox() const;
  inline void clear_scissorbox();
  static const int kScissorBoxFieldNumber = 37;
  inline const ::Medusa::CoreProto::RectF& scissorbox() const;
  inline ::Medusa::CoreProto::RectF* mutable_scissorbox();
  inline ::Medusa::CoreProto::RectF* release_scissorbox();
  inline void set_allocated_scissorbox(::Medusa::CoreProto::RectF* scissorbox);

  // optional int32 Tag = 51;
  inline bool has_tag() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 51;
  inline ::google::protobuf::int32 tag() const;
  inline void set_tag(::google::protobuf::int32 value);

  // optional bool IsLock = 201;
  inline bool has_islock() const;
  inline void clear_islock();
  static const int kIsLockFieldNumber = 201;
  inline bool islock() const;
  inline void set_islock(bool value);

  // optional bool IsHide = 202;
  inline bool has_ishide() const;
  inline void clear_ishide();
  static const int kIsHideFieldNumber = 202;
  inline bool ishide() const;
  inline void set_ishide(bool value);

  // @@protoc_insertion_point(class_scope:Medusa.CoreProto.Editor.EditBox)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_isproportionpoint();
  inline void clear_has_isproportionpoint();
  inline void set_has_anchor();
  inline void clear_has_anchor();
  inline void set_has_zorder();
  inline void clear_has_zorder();
  inline void set_has_rotation();
  inline void clear_has_rotation();
  inline void set_has_scale();
  inline void clear_has_scale();
  inline void set_has_isvisible();
  inline void clear_has_isvisible();
  inline void set_has_fontname();
  inline void clear_has_fontname();
  inline void set_has_fontsize();
  inline void clear_has_fontsize();
  inline void set_has_text();
  inline void clear_has_text();
  inline void set_has_color();
  inline void clear_has_color();
  inline void set_has_backgroundimage();
  inline void clear_has_backgroundimage();
  inline void set_has_alignmenttype();
  inline void clear_has_alignmenttype();
  inline void set_has_keyboardreturntype();
  inline void clear_has_keyboardreturntype();
  inline void set_has_inputmode();
  inline void clear_has_inputmode();
  inline void set_has_inputflag();
  inline void clear_has_inputflag();
  inline void set_has_characternum();
  inline void clear_has_characternum();
  inline void set_has_minlinenum();
  inline void clear_has_minlinenum();
  inline void set_has_maxlinenum();
  inline void clear_has_maxlinenum();
  inline void set_has_onload();
  inline void clear_has_onload();
  inline void set_has_onshow();
  inline void clear_has_onshow();
  inline void set_has_onhide();
  inline void clear_has_onhide();
  inline void set_has_onclosed();
  inline void clear_has_onclosed();
  inline void set_has_onupdate();
  inline void clear_has_onupdate();
  inline void set_has_onchar();
  inline void clear_has_onchar();
  inline void set_has_onevent();
  inline void clear_has_onevent();
  inline void set_has_scissorbox();
  inline void clear_has_scissorbox();
  inline void set_has_tag();
  inline void clear_has_tag();
  inline void set_has_islock();
  inline void clear_has_islock();
  inline void set_has_ishide();
  inline void clear_has_ishide();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::Medusa::CoreProto::SizeU* size_;
  ::Medusa::CoreProto::PointF* position_;
  ::Medusa::CoreProto::PointF* anchor_;
  ::google::protobuf::int32 zorder_;
  float rotation_;
  ::Medusa::CoreProto::ScaleF* scale_;
  ::Medusa::CoreProto::FileId* fontname_;
  ::std::string* text_;
  ::Medusa::CoreProto::ColorF* color_;
  ::google::protobuf::uint32 fontsize_;
  int alignmenttype_;
  ::Medusa::CoreProto::Editor::ImageFile* backgroundimage_;
  int keyboardreturntype_;
  int inputmode_;
  int inputflag_;
  ::google::protobuf::uint32 characternum_;
  ::std::string* minlinenum_;
  ::std::string* maxlinenum_;
  bool isproportionpoint_;
  bool isvisible_;
  bool islock_;
  bool ishide_;
  ::google::protobuf::int32 tag_;
  ::std::string* onload_;
  ::std::string* onshow_;
  ::std::string* onhide_;
  ::std::string* onclosed_;
  ::std::string* onupdate_;
  ::std::string* onchar_;
  ::std::string* onevent_;
  ::Medusa::CoreProto::RectF* scissorbox_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(32 + 31) / 32];

  friend void  protobuf_AddDesc_LayerEditor_2eproto();
  friend void protobuf_AssignDesc_LayerEditor_2eproto();
  friend void protobuf_ShutdownFile_LayerEditor_2eproto();

  void InitAsDefaultInstance();
  static EditBox* default_instance_;
};
// -------------------------------------------------------------------

class ProgressBar : public ::google::protobuf::Message {
 public:
  ProgressBar();
  virtual ~ProgressBar();

  ProgressBar(const ProgressBar& from);

  inline ProgressBar& operator=(const ProgressBar& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProgressBar& default_instance();

  void Swap(ProgressBar* other);

  // implements Message ----------------------------------------------

  ProgressBar* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProgressBar& from);
  void MergeFrom(const ProgressBar& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ProgressBar_ProgressBarType ProgressBarType;
  static const ProgressBarType Radial = ProgressBar_ProgressBarType_Radial;
  static const ProgressBarType Bar = ProgressBar_ProgressBarType_Bar;
  static inline bool ProgressBarType_IsValid(int value) {
    return ProgressBar_ProgressBarType_IsValid(value);
  }
  static const ProgressBarType ProgressBarType_MIN =
    ProgressBar_ProgressBarType_ProgressBarType_MIN;
  static const ProgressBarType ProgressBarType_MAX =
    ProgressBar_ProgressBarType_ProgressBarType_MAX;
  static const int ProgressBarType_ARRAYSIZE =
    ProgressBar_ProgressBarType_ProgressBarType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ProgressBarType_descriptor() {
    return ProgressBar_ProgressBarType_descriptor();
  }
  static inline const ::std::string& ProgressBarType_Name(ProgressBarType value) {
    return ProgressBar_ProgressBarType_Name(value);
  }
  static inline bool ProgressBarType_Parse(const ::std::string& name,
      ProgressBarType* value) {
    return ProgressBar_ProgressBarType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string ID = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIDFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // required .Medusa.CoreProto.PointF Position = 2;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 2;
  inline const ::Medusa::CoreProto::PointF& position() const;
  inline ::Medusa::CoreProto::PointF* mutable_position();
  inline ::Medusa::CoreProto::PointF* release_position();
  inline void set_allocated_position(::Medusa::CoreProto::PointF* position);

  // required bool IsProportionPoint = 3;
  inline bool has_isproportionpoint() const;
  inline void clear_isproportionpoint();
  static const int kIsProportionPointFieldNumber = 3;
  inline bool isproportionpoint() const;
  inline void set_isproportionpoint(bool value);

  // required .Medusa.CoreProto.PointF Anchor = 4;
  inline bool has_anchor() const;
  inline void clear_anchor();
  static const int kAnchorFieldNumber = 4;
  inline const ::Medusa::CoreProto::PointF& anchor() const;
  inline ::Medusa::CoreProto::PointF* mutable_anchor();
  inline ::Medusa::CoreProto::PointF* release_anchor();
  inline void set_allocated_anchor(::Medusa::CoreProto::PointF* anchor);

  // required int32 ZOrder = 5;
  inline bool has_zorder() const;
  inline void clear_zorder();
  static const int kZOrderFieldNumber = 5;
  inline ::google::protobuf::int32 zorder() const;
  inline void set_zorder(::google::protobuf::int32 value);

  // optional float Rotation = 6;
  inline bool has_rotation() const;
  inline void clear_rotation();
  static const int kRotationFieldNumber = 6;
  inline float rotation() const;
  inline void set_rotation(float value);

  // optional .Medusa.CoreProto.ScaleF Scale = 7;
  inline bool has_scale() const;
  inline void clear_scale();
  static const int kScaleFieldNumber = 7;
  inline const ::Medusa::CoreProto::ScaleF& scale() const;
  inline ::Medusa::CoreProto::ScaleF* mutable_scale();
  inline ::Medusa::CoreProto::ScaleF* release_scale();
  inline void set_allocated_scale(::Medusa::CoreProto::ScaleF* scale);

  // required bool IsVisible = 8;
  inline bool has_isvisible() const;
  inline void clear_isvisible();
  static const int kIsVisibleFieldNumber = 8;
  inline bool isvisible() const;
  inline void set_isvisible(bool value);

  // required .Medusa.CoreProto.SizeU Size = 9;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 9;
  inline const ::Medusa::CoreProto::SizeU& size() const;
  inline ::Medusa::CoreProto::SizeU* mutable_size();
  inline ::Medusa::CoreProto::SizeU* release_size();
  inline void set_allocated_size(::Medusa::CoreProto::SizeU* size);

  // optional .Medusa.CoreProto.Editor.ImageFile Image = 10;
  inline bool has_image() const;
  inline void clear_image();
  static const int kImageFieldNumber = 10;
  inline const ::Medusa::CoreProto::Editor::ImageFile& image() const;
  inline ::Medusa::CoreProto::Editor::ImageFile* mutable_image();
  inline ::Medusa::CoreProto::Editor::ImageFile* release_image();
  inline void set_allocated_image(::Medusa::CoreProto::Editor::ImageFile* image);

  // optional string OnLoad = 12;
  inline bool has_onload() const;
  inline void clear_onload();
  static const int kOnLoadFieldNumber = 12;
  inline const ::std::string& onload() const;
  inline void set_onload(const ::std::string& value);
  inline void set_onload(const char* value);
  inline void set_onload(const char* value, size_t size);
  inline ::std::string* mutable_onload();
  inline ::std::string* release_onload();
  inline void set_allocated_onload(::std::string* onload);

  // optional string OnShow = 13;
  inline bool has_onshow() const;
  inline void clear_onshow();
  static const int kOnShowFieldNumber = 13;
  inline const ::std::string& onshow() const;
  inline void set_onshow(const ::std::string& value);
  inline void set_onshow(const char* value);
  inline void set_onshow(const char* value, size_t size);
  inline ::std::string* mutable_onshow();
  inline ::std::string* release_onshow();
  inline void set_allocated_onshow(::std::string* onshow);

  // optional string OnHide = 14;
  inline bool has_onhide() const;
  inline void clear_onhide();
  static const int kOnHideFieldNumber = 14;
  inline const ::std::string& onhide() const;
  inline void set_onhide(const ::std::string& value);
  inline void set_onhide(const char* value);
  inline void set_onhide(const char* value, size_t size);
  inline ::std::string* mutable_onhide();
  inline ::std::string* release_onhide();
  inline void set_allocated_onhide(::std::string* onhide);

  // optional string OnClosed = 15;
  inline bool has_onclosed() const;
  inline void clear_onclosed();
  static const int kOnClosedFieldNumber = 15;
  inline const ::std::string& onclosed() const;
  inline void set_onclosed(const ::std::string& value);
  inline void set_onclosed(const char* value);
  inline void set_onclosed(const char* value, size_t size);
  inline ::std::string* mutable_onclosed();
  inline ::std::string* release_onclosed();
  inline void set_allocated_onclosed(::std::string* onclosed);

  // optional string OnUpdate = 16;
  inline bool has_onupdate() const;
  inline void clear_onupdate();
  static const int kOnUpdateFieldNumber = 16;
  inline const ::std::string& onupdate() const;
  inline void set_onupdate(const ::std::string& value);
  inline void set_onupdate(const char* value);
  inline void set_onupdate(const char* value, size_t size);
  inline ::std::string* mutable_onupdate();
  inline ::std::string* release_onupdate();
  inline void set_allocated_onupdate(::std::string* onupdate);

  // optional string OnEvent = 17;
  inline bool has_onevent() const;
  inline void clear_onevent();
  static const int kOnEventFieldNumber = 17;
  inline const ::std::string& onevent() const;
  inline void set_onevent(const ::std::string& value);
  inline void set_onevent(const char* value);
  inline void set_onevent(const char* value, size_t size);
  inline ::std::string* mutable_onevent();
  inline ::std::string* release_onevent();
  inline void set_allocated_onevent(::std::string* onevent);

  // required float Duration = 18;
  inline bool has_duration() const;
  inline void clear_duration();
  static const int kDurationFieldNumber = 18;
  inline float duration() const;
  inline void set_duration(float value);

  // optional .Medusa.CoreProto.Editor.ProgressBar.ProgressBarType Type = 19;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 19;
  inline ::Medusa::CoreProto::Editor::ProgressBar_ProgressBarType type() const;
  inline void set_type(::Medusa::CoreProto::Editor::ProgressBar_ProgressBarType value);

  // optional .Medusa.CoreProto.PointF Midpoint = 20;
  inline bool has_midpoint() const;
  inline void clear_midpoint();
  static const int kMidpointFieldNumber = 20;
  inline const ::Medusa::CoreProto::PointF& midpoint() const;
  inline ::Medusa::CoreProto::PointF* mutable_midpoint();
  inline ::Medusa::CoreProto::PointF* release_midpoint();
  inline void set_allocated_midpoint(::Medusa::CoreProto::PointF* midpoint);

  // optional .Medusa.CoreProto.PointF ChangeRate = 21;
  inline bool has_changerate() const;
  inline void clear_changerate();
  static const int kChangeRateFieldNumber = 21;
  inline const ::Medusa::CoreProto::PointF& changerate() const;
  inline ::Medusa::CoreProto::PointF* mutable_changerate();
  inline ::Medusa::CoreProto::PointF* release_changerate();
  inline void set_allocated_changerate(::Medusa::CoreProto::PointF* changerate);

  // optional .Medusa.CoreProto.RectF ScissorBox = 22;
  inline bool has_scissorbox() const;
  inline void clear_scissorbox();
  static const int kScissorBoxFieldNumber = 22;
  inline const ::Medusa::CoreProto::RectF& scissorbox() const;
  inline ::Medusa::CoreProto::RectF* mutable_scissorbox();
  inline ::Medusa::CoreProto::RectF* release_scissorbox();
  inline void set_allocated_scissorbox(::Medusa::CoreProto::RectF* scissorbox);

  // optional int32 RenderFlag = 50;
  inline bool has_renderflag() const;
  inline void clear_renderflag();
  static const int kRenderFlagFieldNumber = 50;
  inline ::google::protobuf::int32 renderflag() const;
  inline void set_renderflag(::google::protobuf::int32 value);

  // optional int32 Tag = 51;
  inline bool has_tag() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 51;
  inline ::google::protobuf::int32 tag() const;
  inline void set_tag(::google::protobuf::int32 value);

  // optional bool IsLock = 201;
  inline bool has_islock() const;
  inline void clear_islock();
  static const int kIsLockFieldNumber = 201;
  inline bool islock() const;
  inline void set_islock(bool value);

  // optional bool IsHide = 202;
  inline bool has_ishide() const;
  inline void clear_ishide();
  static const int kIsHideFieldNumber = 202;
  inline bool ishide() const;
  inline void set_ishide(bool value);

  // @@protoc_insertion_point(class_scope:Medusa.CoreProto.Editor.ProgressBar)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_isproportionpoint();
  inline void clear_has_isproportionpoint();
  inline void set_has_anchor();
  inline void clear_has_anchor();
  inline void set_has_zorder();
  inline void clear_has_zorder();
  inline void set_has_rotation();
  inline void clear_has_rotation();
  inline void set_has_scale();
  inline void clear_has_scale();
  inline void set_has_isvisible();
  inline void clear_has_isvisible();
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_image();
  inline void clear_has_image();
  inline void set_has_onload();
  inline void clear_has_onload();
  inline void set_has_onshow();
  inline void clear_has_onshow();
  inline void set_has_onhide();
  inline void clear_has_onhide();
  inline void set_has_onclosed();
  inline void clear_has_onclosed();
  inline void set_has_onupdate();
  inline void clear_has_onupdate();
  inline void set_has_onevent();
  inline void clear_has_onevent();
  inline void set_has_duration();
  inline void clear_has_duration();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_midpoint();
  inline void clear_has_midpoint();
  inline void set_has_changerate();
  inline void clear_has_changerate();
  inline void set_has_scissorbox();
  inline void clear_has_scissorbox();
  inline void set_has_renderflag();
  inline void clear_has_renderflag();
  inline void set_has_tag();
  inline void clear_has_tag();
  inline void set_has_islock();
  inline void clear_has_islock();
  inline void set_has_ishide();
  inline void clear_has_ishide();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::Medusa::CoreProto::PointF* position_;
  ::Medusa::CoreProto::PointF* anchor_;
  ::google::protobuf::int32 zorder_;
  float rotation_;
  ::Medusa::CoreProto::ScaleF* scale_;
  ::Medusa::CoreProto::SizeU* size_;
  ::Medusa::CoreProto::Editor::ImageFile* image_;
  ::std::string* onload_;
  ::std::string* onshow_;
  ::std::string* onhide_;
  ::std::string* onclosed_;
  ::std::string* onupdate_;
  bool isproportionpoint_;
  bool isvisible_;
  bool islock_;
  bool ishide_;
  float duration_;
  ::std::string* onevent_;
  ::Medusa::CoreProto::PointF* midpoint_;
  ::Medusa::CoreProto::PointF* changerate_;
  int type_;
  ::google::protobuf::int32 renderflag_;
  ::Medusa::CoreProto::RectF* scissorbox_;
  ::google::protobuf::int32 tag_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(25 + 31) / 32];

  friend void  protobuf_AddDesc_LayerEditor_2eproto();
  friend void protobuf_AssignDesc_LayerEditor_2eproto();
  friend void protobuf_ShutdownFile_LayerEditor_2eproto();

  void InitAsDefaultInstance();
  static ProgressBar* default_instance_;
};
// -------------------------------------------------------------------

class Trigger : public ::google::protobuf::Message {
 public:
  Trigger();
  virtual ~Trigger();

  Trigger(const Trigger& from);

  inline Trigger& operator=(const Trigger& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Trigger& default_instance();

  void Swap(Trigger* other);

  // implements Message ----------------------------------------------

  Trigger* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Trigger& from);
  void MergeFrom(const Trigger& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string ID = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIDFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional string OnUpdate = 2;
  inline bool has_onupdate() const;
  inline void clear_onupdate();
  static const int kOnUpdateFieldNumber = 2;
  inline const ::std::string& onupdate() const;
  inline void set_onupdate(const ::std::string& value);
  inline void set_onupdate(const char* value);
  inline void set_onupdate(const char* value, size_t size);
  inline ::std::string* mutable_onupdate();
  inline ::std::string* release_onupdate();
  inline void set_allocated_onupdate(::std::string* onupdate);

  // optional string OnEvent = 3;
  inline bool has_onevent() const;
  inline void clear_onevent();
  static const int kOnEventFieldNumber = 3;
  inline const ::std::string& onevent() const;
  inline void set_onevent(const ::std::string& value);
  inline void set_onevent(const char* value);
  inline void set_onevent(const char* value, size_t size);
  inline ::std::string* mutable_onevent();
  inline ::std::string* release_onevent();
  inline void set_allocated_onevent(::std::string* onevent);

  // optional .Medusa.CoreProto.SizeU Size = 4;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 4;
  inline const ::Medusa::CoreProto::SizeU& size() const;
  inline ::Medusa::CoreProto::SizeU* mutable_size();
  inline ::Medusa::CoreProto::SizeU* release_size();
  inline void set_allocated_size(::Medusa::CoreProto::SizeU* size);

  // optional .Medusa.CoreProto.PointF Position = 5;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 5;
  inline const ::Medusa::CoreProto::PointF& position() const;
  inline ::Medusa::CoreProto::PointF* mutable_position();
  inline ::Medusa::CoreProto::PointF* release_position();
  inline void set_allocated_position(::Medusa::CoreProto::PointF* position);

  // optional bool IsProportionPoint = 6;
  inline bool has_isproportionpoint() const;
  inline void clear_isproportionpoint();
  static const int kIsProportionPointFieldNumber = 6;
  inline bool isproportionpoint() const;
  inline void set_isproportionpoint(bool value);

  // optional float Parallax = 7;
  inline bool has_parallax() const;
  inline void clear_parallax();
  static const int kParallaxFieldNumber = 7;
  inline float parallax() const;
  inline void set_parallax(float value);

  // optional int32 Tag = 51;
  inline bool has_tag() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 51;
  inline ::google::protobuf::int32 tag() const;
  inline void set_tag(::google::protobuf::int32 value);

  // optional bool IsLock = 201;
  inline bool has_islock() const;
  inline void clear_islock();
  static const int kIsLockFieldNumber = 201;
  inline bool islock() const;
  inline void set_islock(bool value);

  // optional bool IsHide = 202;
  inline bool has_ishide() const;
  inline void clear_ishide();
  static const int kIsHideFieldNumber = 202;
  inline bool ishide() const;
  inline void set_ishide(bool value);

  // @@protoc_insertion_point(class_scope:Medusa.CoreProto.Editor.Trigger)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_onupdate();
  inline void clear_has_onupdate();
  inline void set_has_onevent();
  inline void clear_has_onevent();
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_isproportionpoint();
  inline void clear_has_isproportionpoint();
  inline void set_has_parallax();
  inline void clear_has_parallax();
  inline void set_has_tag();
  inline void clear_has_tag();
  inline void set_has_islock();
  inline void clear_has_islock();
  inline void set_has_ishide();
  inline void clear_has_ishide();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::std::string* onupdate_;
  ::std::string* onevent_;
  ::Medusa::CoreProto::SizeU* size_;
  ::Medusa::CoreProto::PointF* position_;
  float parallax_;
  ::google::protobuf::int32 tag_;
  bool isproportionpoint_;
  bool islock_;
  bool ishide_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_LayerEditor_2eproto();
  friend void protobuf_AssignDesc_LayerEditor_2eproto();
  friend void protobuf_ShutdownFile_LayerEditor_2eproto();

  void InitAsDefaultInstance();
  static Trigger* default_instance_;
};
// -------------------------------------------------------------------

class TriggerRef : public ::google::protobuf::Message {
 public:
  TriggerRef();
  virtual ~TriggerRef();

  TriggerRef(const TriggerRef& from);

  inline TriggerRef& operator=(const TriggerRef& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TriggerRef& default_instance();

  void Swap(TriggerRef* other);

  // implements Message ----------------------------------------------

  TriggerRef* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TriggerRef& from);
  void MergeFrom(const TriggerRef& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string ID = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIDFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // required .Medusa.CoreProto.FileId ModelName = 2;
  inline bool has_modelname() const;
  inline void clear_modelname();
  static const int kModelNameFieldNumber = 2;
  inline const ::Medusa::CoreProto::FileId& modelname() const;
  inline ::Medusa::CoreProto::FileId* mutable_modelname();
  inline ::Medusa::CoreProto::FileId* release_modelname();
  inline void set_allocated_modelname(::Medusa::CoreProto::FileId* modelname);

  // optional .Medusa.CoreProto.SizeU Size = 3;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 3;
  inline const ::Medusa::CoreProto::SizeU& size() const;
  inline ::Medusa::CoreProto::SizeU* mutable_size();
  inline ::Medusa::CoreProto::SizeU* release_size();
  inline void set_allocated_size(::Medusa::CoreProto::SizeU* size);

  // optional .Medusa.CoreProto.PointF Position = 4;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 4;
  inline const ::Medusa::CoreProto::PointF& position() const;
  inline ::Medusa::CoreProto::PointF* mutable_position();
  inline ::Medusa::CoreProto::PointF* release_position();
  inline void set_allocated_position(::Medusa::CoreProto::PointF* position);

  // optional bool IsProportionPoint = 5;
  inline bool has_isproportionpoint() const;
  inline void clear_isproportionpoint();
  static const int kIsProportionPointFieldNumber = 5;
  inline bool isproportionpoint() const;
  inline void set_isproportionpoint(bool value);

  // optional float Parallax = 6;
  inline bool has_parallax() const;
  inline void clear_parallax();
  static const int kParallaxFieldNumber = 6;
  inline float parallax() const;
  inline void set_parallax(float value);

  // optional int32 Tag = 51;
  inline bool has_tag() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 51;
  inline ::google::protobuf::int32 tag() const;
  inline void set_tag(::google::protobuf::int32 value);

  // optional bool IsLock = 201;
  inline bool has_islock() const;
  inline void clear_islock();
  static const int kIsLockFieldNumber = 201;
  inline bool islock() const;
  inline void set_islock(bool value);

  // optional bool IsHide = 202;
  inline bool has_ishide() const;
  inline void clear_ishide();
  static const int kIsHideFieldNumber = 202;
  inline bool ishide() const;
  inline void set_ishide(bool value);

  // @@protoc_insertion_point(class_scope:Medusa.CoreProto.Editor.TriggerRef)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_modelname();
  inline void clear_has_modelname();
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_isproportionpoint();
  inline void clear_has_isproportionpoint();
  inline void set_has_parallax();
  inline void clear_has_parallax();
  inline void set_has_tag();
  inline void clear_has_tag();
  inline void set_has_islock();
  inline void clear_has_islock();
  inline void set_has_ishide();
  inline void clear_has_ishide();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::Medusa::CoreProto::FileId* modelname_;
  ::Medusa::CoreProto::SizeU* size_;
  ::Medusa::CoreProto::PointF* position_;
  float parallax_;
  ::google::protobuf::int32 tag_;
  bool isproportionpoint_;
  bool islock_;
  bool ishide_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_LayerEditor_2eproto();
  friend void protobuf_AssignDesc_LayerEditor_2eproto();
  friend void protobuf_ShutdownFile_LayerEditor_2eproto();

  void InitAsDefaultInstance();
  static TriggerRef* default_instance_;
};
// -------------------------------------------------------------------

class LayerRef : public ::google::protobuf::Message {
 public:
  LayerRef();
  virtual ~LayerRef();

  LayerRef(const LayerRef& from);

  inline LayerRef& operator=(const LayerRef& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LayerRef& default_instance();

  void Swap(LayerRef* other);

  // implements Message ----------------------------------------------

  LayerRef* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LayerRef& from);
  void MergeFrom(const LayerRef& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string ID = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIDFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // required .Medusa.CoreProto.FileId ModelName = 2;
  inline bool has_modelname() const;
  inline void clear_modelname();
  static const int kModelNameFieldNumber = 2;
  inline const ::Medusa::CoreProto::FileId& modelname() const;
  inline ::Medusa::CoreProto::FileId* mutable_modelname();
  inline ::Medusa::CoreProto::FileId* release_modelname();
  inline void set_allocated_modelname(::Medusa::CoreProto::FileId* modelname);

  // required .Medusa.CoreProto.PointF Position = 3;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 3;
  inline const ::Medusa::CoreProto::PointF& position() const;
  inline ::Medusa::CoreProto::PointF* mutable_position();
  inline ::Medusa::CoreProto::PointF* release_position();
  inline void set_allocated_position(::Medusa::CoreProto::PointF* position);

  // required bool IsProportionPoint = 4;
  inline bool has_isproportionpoint() const;
  inline void clear_isproportionpoint();
  static const int kIsProportionPointFieldNumber = 4;
  inline bool isproportionpoint() const;
  inline void set_isproportionpoint(bool value);

  // required .Medusa.CoreProto.PointF Anchor = 5;
  inline bool has_anchor() const;
  inline void clear_anchor();
  static const int kAnchorFieldNumber = 5;
  inline const ::Medusa::CoreProto::PointF& anchor() const;
  inline ::Medusa::CoreProto::PointF* mutable_anchor();
  inline ::Medusa::CoreProto::PointF* release_anchor();
  inline void set_allocated_anchor(::Medusa::CoreProto::PointF* anchor);

  // required int32 ZOrder = 6;
  inline bool has_zorder() const;
  inline void clear_zorder();
  static const int kZOrderFieldNumber = 6;
  inline ::google::protobuf::int32 zorder() const;
  inline void set_zorder(::google::protobuf::int32 value);

  // optional float Rotation = 7;
  inline bool has_rotation() const;
  inline void clear_rotation();
  static const int kRotationFieldNumber = 7;
  inline float rotation() const;
  inline void set_rotation(float value);

  // optional .Medusa.CoreProto.ScaleF Scale = 8;
  inline bool has_scale() const;
  inline void clear_scale();
  static const int kScaleFieldNumber = 8;
  inline const ::Medusa::CoreProto::ScaleF& scale() const;
  inline ::Medusa::CoreProto::ScaleF* mutable_scale();
  inline ::Medusa::CoreProto::ScaleF* release_scale();
  inline void set_allocated_scale(::Medusa::CoreProto::ScaleF* scale);

  // optional bool IsFilpX = 9;
  inline bool has_isfilpx() const;
  inline void clear_isfilpx();
  static const int kIsFilpXFieldNumber = 9;
  inline bool isfilpx() const;
  inline void set_isfilpx(bool value);

  // optional bool IsFilpY = 10;
  inline bool has_isfilpy() const;
  inline void clear_isfilpy();
  static const int kIsFilpYFieldNumber = 10;
  inline bool isfilpy() const;
  inline void set_isfilpy(bool value);

  // required bool IsVisible = 11;
  inline bool has_isvisible() const;
  inline void clear_isvisible();
  static const int kIsVisibleFieldNumber = 11;
  inline bool isvisible() const;
  inline void set_isvisible(bool value);

  // required float Parallax = 12;
  inline bool has_parallax() const;
  inline void clear_parallax();
  static const int kParallaxFieldNumber = 12;
  inline float parallax() const;
  inline void set_parallax(float value);

  // optional int32 Tag = 51;
  inline bool has_tag() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 51;
  inline ::google::protobuf::int32 tag() const;
  inline void set_tag(::google::protobuf::int32 value);

  // optional bool IsLock = 201;
  inline bool has_islock() const;
  inline void clear_islock();
  static const int kIsLockFieldNumber = 201;
  inline bool islock() const;
  inline void set_islock(bool value);

  // optional bool IsHide = 202;
  inline bool has_ishide() const;
  inline void clear_ishide();
  static const int kIsHideFieldNumber = 202;
  inline bool ishide() const;
  inline void set_ishide(bool value);

  // @@protoc_insertion_point(class_scope:Medusa.CoreProto.Editor.LayerRef)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_modelname();
  inline void clear_has_modelname();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_isproportionpoint();
  inline void clear_has_isproportionpoint();
  inline void set_has_anchor();
  inline void clear_has_anchor();
  inline void set_has_zorder();
  inline void clear_has_zorder();
  inline void set_has_rotation();
  inline void clear_has_rotation();
  inline void set_has_scale();
  inline void clear_has_scale();
  inline void set_has_isfilpx();
  inline void clear_has_isfilpx();
  inline void set_has_isfilpy();
  inline void clear_has_isfilpy();
  inline void set_has_isvisible();
  inline void clear_has_isvisible();
  inline void set_has_parallax();
  inline void clear_has_parallax();
  inline void set_has_tag();
  inline void clear_has_tag();
  inline void set_has_islock();
  inline void clear_has_islock();
  inline void set_has_ishide();
  inline void clear_has_ishide();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::Medusa::CoreProto::FileId* modelname_;
  ::Medusa::CoreProto::PointF* position_;
  ::Medusa::CoreProto::PointF* anchor_;
  ::google::protobuf::int32 zorder_;
  float rotation_;
  ::Medusa::CoreProto::ScaleF* scale_;
  bool isproportionpoint_;
  bool isfilpx_;
  bool isfilpy_;
  bool isvisible_;
  float parallax_;
  ::google::protobuf::int32 tag_;
  bool islock_;
  bool ishide_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(15 + 31) / 32];

  friend void  protobuf_AddDesc_LayerEditor_2eproto();
  friend void protobuf_AssignDesc_LayerEditor_2eproto();
  friend void protobuf_ShutdownFile_LayerEditor_2eproto();

  void InitAsDefaultInstance();
  static LayerRef* default_instance_;
};
// -------------------------------------------------------------------

class ListBox : public ::google::protobuf::Message {
 public:
  ListBox();
  virtual ~ListBox();

  ListBox(const ListBox& from);

  inline ListBox& operator=(const ListBox& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ListBox& default_instance();

  void Swap(ListBox* other);

  // implements Message ----------------------------------------------

  ListBox* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ListBox& from);
  void MergeFrom(const ListBox& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ListBox_ScorllDirection ScorllDirection;
  static const ScorllDirection None = ListBox_ScorllDirection_None;
  static const ScorllDirection Horizontal = ListBox_ScorllDirection_Horizontal;
  static const ScorllDirection Vertical = ListBox_ScorllDirection_Vertical;
  static const ScorllDirection Both = ListBox_ScorllDirection_Both;
  static inline bool ScorllDirection_IsValid(int value) {
    return ListBox_ScorllDirection_IsValid(value);
  }
  static const ScorllDirection ScorllDirection_MIN =
    ListBox_ScorllDirection_ScorllDirection_MIN;
  static const ScorllDirection ScorllDirection_MAX =
    ListBox_ScorllDirection_ScorllDirection_MAX;
  static const int ScorllDirection_ARRAYSIZE =
    ListBox_ScorllDirection_ScorllDirection_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ScorllDirection_descriptor() {
    return ListBox_ScorllDirection_descriptor();
  }
  static inline const ::std::string& ScorllDirection_Name(ScorllDirection value) {
    return ListBox_ScorllDirection_Name(value);
  }
  static inline bool ScorllDirection_Parse(const ::std::string& name,
      ScorllDirection* value) {
    return ListBox_ScorllDirection_Parse(name, value);
  }

  typedef ListBox_VerticalOrder VerticalOrder;
  static const VerticalOrder Ascending = ListBox_VerticalOrder_Ascending;
  static const VerticalOrder Descending = ListBox_VerticalOrder_Descending;
  static inline bool VerticalOrder_IsValid(int value) {
    return ListBox_VerticalOrder_IsValid(value);
  }
  static const VerticalOrder VerticalOrder_MIN =
    ListBox_VerticalOrder_VerticalOrder_MIN;
  static const VerticalOrder VerticalOrder_MAX =
    ListBox_VerticalOrder_VerticalOrder_MAX;
  static const int VerticalOrder_ARRAYSIZE =
    ListBox_VerticalOrder_VerticalOrder_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  VerticalOrder_descriptor() {
    return ListBox_VerticalOrder_descriptor();
  }
  static inline const ::std::string& VerticalOrder_Name(VerticalOrder value) {
    return ListBox_VerticalOrder_Name(value);
  }
  static inline bool VerticalOrder_Parse(const ::std::string& name,
      VerticalOrder* value) {
    return ListBox_VerticalOrder_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string ID = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIDFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // required .Medusa.CoreProto.FileId ItemFileID = 2;
  inline bool has_itemfileid() const;
  inline void clear_itemfileid();
  static const int kItemFileIDFieldNumber = 2;
  inline const ::Medusa::CoreProto::FileId& itemfileid() const;
  inline ::Medusa::CoreProto::FileId* mutable_itemfileid();
  inline ::Medusa::CoreProto::FileId* release_itemfileid();
  inline void set_allocated_itemfileid(::Medusa::CoreProto::FileId* itemfileid);

  // required .Medusa.CoreProto.SizeU Size = 3;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 3;
  inline const ::Medusa::CoreProto::SizeU& size() const;
  inline ::Medusa::CoreProto::SizeU* mutable_size();
  inline ::Medusa::CoreProto::SizeU* release_size();
  inline void set_allocated_size(::Medusa::CoreProto::SizeU* size);

  // required .Medusa.CoreProto.PointF Position = 4;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 4;
  inline const ::Medusa::CoreProto::PointF& position() const;
  inline ::Medusa::CoreProto::PointF* mutable_position();
  inline ::Medusa::CoreProto::PointF* release_position();
  inline void set_allocated_position(::Medusa::CoreProto::PointF* position);

  // required bool IsProportionPoint = 5;
  inline bool has_isproportionpoint() const;
  inline void clear_isproportionpoint();
  static const int kIsProportionPointFieldNumber = 5;
  inline bool isproportionpoint() const;
  inline void set_isproportionpoint(bool value);

  // required .Medusa.CoreProto.PointF Anchor = 6;
  inline bool has_anchor() const;
  inline void clear_anchor();
  static const int kAnchorFieldNumber = 6;
  inline const ::Medusa::CoreProto::PointF& anchor() const;
  inline ::Medusa::CoreProto::PointF* mutable_anchor();
  inline ::Medusa::CoreProto::PointF* release_anchor();
  inline void set_allocated_anchor(::Medusa::CoreProto::PointF* anchor);

  // required int32 ZOrder = 7;
  inline bool has_zorder() const;
  inline void clear_zorder();
  static const int kZOrderFieldNumber = 7;
  inline ::google::protobuf::int32 zorder() const;
  inline void set_zorder(::google::protobuf::int32 value);

  // optional float Rotation = 8;
  inline bool has_rotation() const;
  inline void clear_rotation();
  static const int kRotationFieldNumber = 8;
  inline float rotation() const;
  inline void set_rotation(float value);

  // optional .Medusa.CoreProto.ScaleF Scale = 9;
  inline bool has_scale() const;
  inline void clear_scale();
  static const int kScaleFieldNumber = 9;
  inline const ::Medusa::CoreProto::ScaleF& scale() const;
  inline ::Medusa::CoreProto::ScaleF* mutable_scale();
  inline ::Medusa::CoreProto::ScaleF* release_scale();
  inline void set_allocated_scale(::Medusa::CoreProto::ScaleF* scale);

  // required bool IsVisible = 12;
  inline bool has_isvisible() const;
  inline void clear_isvisible();
  static const int kIsVisibleFieldNumber = 12;
  inline bool isvisible() const;
  inline void set_isvisible(bool value);

  // required .Medusa.CoreProto.Editor.ListBox.ScorllDirection Direction = 13;
  inline bool has_direction() const;
  inline void clear_direction();
  static const int kDirectionFieldNumber = 13;
  inline ::Medusa::CoreProto::Editor::ListBox_ScorllDirection direction() const;
  inline void set_direction(::Medusa::CoreProto::Editor::ListBox_ScorllDirection value);

  // optional .Medusa.CoreProto.Editor.ListBox.VerticalOrder OrderType = 14;
  inline bool has_ordertype() const;
  inline void clear_ordertype();
  static const int kOrderTypeFieldNumber = 14;
  inline ::Medusa::CoreProto::Editor::ListBox_VerticalOrder ordertype() const;
  inline void set_ordertype(::Medusa::CoreProto::Editor::ListBox_VerticalOrder value);

  // optional string OnLoad = 15;
  inline bool has_onload() const;
  inline void clear_onload();
  static const int kOnLoadFieldNumber = 15;
  inline const ::std::string& onload() const;
  inline void set_onload(const ::std::string& value);
  inline void set_onload(const char* value);
  inline void set_onload(const char* value, size_t size);
  inline ::std::string* mutable_onload();
  inline ::std::string* release_onload();
  inline void set_allocated_onload(::std::string* onload);

  // optional string OnShow = 16;
  inline bool has_onshow() const;
  inline void clear_onshow();
  static const int kOnShowFieldNumber = 16;
  inline const ::std::string& onshow() const;
  inline void set_onshow(const ::std::string& value);
  inline void set_onshow(const char* value);
  inline void set_onshow(const char* value, size_t size);
  inline ::std::string* mutable_onshow();
  inline ::std::string* release_onshow();
  inline void set_allocated_onshow(::std::string* onshow);

  // optional string OnHide = 17;
  inline bool has_onhide() const;
  inline void clear_onhide();
  static const int kOnHideFieldNumber = 17;
  inline const ::std::string& onhide() const;
  inline void set_onhide(const ::std::string& value);
  inline void set_onhide(const char* value);
  inline void set_onhide(const char* value, size_t size);
  inline ::std::string* mutable_onhide();
  inline ::std::string* release_onhide();
  inline void set_allocated_onhide(::std::string* onhide);

  // optional string OnClosed = 18;
  inline bool has_onclosed() const;
  inline void clear_onclosed();
  static const int kOnClosedFieldNumber = 18;
  inline const ::std::string& onclosed() const;
  inline void set_onclosed(const ::std::string& value);
  inline void set_onclosed(const char* value);
  inline void set_onclosed(const char* value, size_t size);
  inline ::std::string* mutable_onclosed();
  inline ::std::string* release_onclosed();
  inline void set_allocated_onclosed(::std::string* onclosed);

  // optional string OnUpdate = 19;
  inline bool has_onupdate() const;
  inline void clear_onupdate();
  static const int kOnUpdateFieldNumber = 19;
  inline const ::std::string& onupdate() const;
  inline void set_onupdate(const ::std::string& value);
  inline void set_onupdate(const char* value);
  inline void set_onupdate(const char* value, size_t size);
  inline ::std::string* mutable_onupdate();
  inline ::std::string* release_onupdate();
  inline void set_allocated_onupdate(::std::string* onupdate);

  // optional string OnEvent = 20;
  inline bool has_onevent() const;
  inline void clear_onevent();
  static const int kOnEventFieldNumber = 20;
  inline const ::std::string& onevent() const;
  inline void set_onevent(const ::std::string& value);
  inline void set_onevent(const char* value);
  inline void set_onevent(const char* value, size_t size);
  inline ::std::string* mutable_onevent();
  inline ::std::string* release_onevent();
  inline void set_allocated_onevent(::std::string* onevent);

  // optional .Medusa.CoreProto.RectF ScissorBox = 21;
  inline bool has_scissorbox() const;
  inline void clear_scissorbox();
  static const int kScissorBoxFieldNumber = 21;
  inline const ::Medusa::CoreProto::RectF& scissorbox() const;
  inline ::Medusa::CoreProto::RectF* mutable_scissorbox();
  inline ::Medusa::CoreProto::RectF* release_scissorbox();
  inline void set_allocated_scissorbox(::Medusa::CoreProto::RectF* scissorbox);

  // optional int32 Tag = 51;
  inline bool has_tag() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 51;
  inline ::google::protobuf::int32 tag() const;
  inline void set_tag(::google::protobuf::int32 value);

  // optional bool IsLock = 201;
  inline bool has_islock() const;
  inline void clear_islock();
  static const int kIsLockFieldNumber = 201;
  inline bool islock() const;
  inline void set_islock(bool value);

  // optional bool IsHide = 202;
  inline bool has_ishide() const;
  inline void clear_ishide();
  static const int kIsHideFieldNumber = 202;
  inline bool ishide() const;
  inline void set_ishide(bool value);

  // @@protoc_insertion_point(class_scope:Medusa.CoreProto.Editor.ListBox)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_itemfileid();
  inline void clear_has_itemfileid();
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_isproportionpoint();
  inline void clear_has_isproportionpoint();
  inline void set_has_anchor();
  inline void clear_has_anchor();
  inline void set_has_zorder();
  inline void clear_has_zorder();
  inline void set_has_rotation();
  inline void clear_has_rotation();
  inline void set_has_scale();
  inline void clear_has_scale();
  inline void set_has_isvisible();
  inline void clear_has_isvisible();
  inline void set_has_direction();
  inline void clear_has_direction();
  inline void set_has_ordertype();
  inline void clear_has_ordertype();
  inline void set_has_onload();
  inline void clear_has_onload();
  inline void set_has_onshow();
  inline void clear_has_onshow();
  inline void set_has_onhide();
  inline void clear_has_onhide();
  inline void set_has_onclosed();
  inline void clear_has_onclosed();
  inline void set_has_onupdate();
  inline void clear_has_onupdate();
  inline void set_has_onevent();
  inline void clear_has_onevent();
  inline void set_has_scissorbox();
  inline void clear_has_scissorbox();
  inline void set_has_tag();
  inline void clear_has_tag();
  inline void set_has_islock();
  inline void clear_has_islock();
  inline void set_has_ishide();
  inline void clear_has_ishide();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::Medusa::CoreProto::FileId* itemfileid_;
  ::Medusa::CoreProto::SizeU* size_;
  ::Medusa::CoreProto::PointF* position_;
  ::Medusa::CoreProto::PointF* anchor_;
  ::google::protobuf::int32 zorder_;
  float rotation_;
  ::Medusa::CoreProto::ScaleF* scale_;
  int direction_;
  int ordertype_;
  ::std::string* onload_;
  ::std::string* onshow_;
  ::std::string* onhide_;
  bool isproportionpoint_;
  bool isvisible_;
  bool islock_;
  bool ishide_;
  ::google::protobuf::int32 tag_;
  ::std::string* onclosed_;
  ::std::string* onupdate_;
  ::std::string* onevent_;
  ::Medusa::CoreProto::RectF* scissorbox_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(22 + 31) / 32];

  friend void  protobuf_AddDesc_LayerEditor_2eproto();
  friend void protobuf_AssignDesc_LayerEditor_2eproto();
  friend void protobuf_ShutdownFile_LayerEditor_2eproto();

  void InitAsDefaultInstance();
  static ListBox* default_instance_;
};
// -------------------------------------------------------------------

class Layer : public ::google::protobuf::Message {
 public:
  Layer();
  virtual ~Layer();

  Layer(const Layer& from);

  inline Layer& operator=(const Layer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Layer& default_instance();

  void Swap(Layer* other);

  // implements Message ----------------------------------------------

  Layer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Layer& from);
  void MergeFrom(const Layer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string ID = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIDFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // required .Medusa.CoreProto.SizeU Size = 2;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 2;
  inline const ::Medusa::CoreProto::SizeU& size() const;
  inline ::Medusa::CoreProto::SizeU* mutable_size();
  inline ::Medusa::CoreProto::SizeU* release_size();
  inline void set_allocated_size(::Medusa::CoreProto::SizeU* size);

  // repeated .Medusa.CoreProto.Editor.Image Images = 3;
  inline int images_size() const;
  inline void clear_images();
  static const int kImagesFieldNumber = 3;
  inline const ::Medusa::CoreProto::Editor::Image& images(int index) const;
  inline ::Medusa::CoreProto::Editor::Image* mutable_images(int index);
  inline ::Medusa::CoreProto::Editor::Image* add_images();
  inline const ::google::protobuf::RepeatedPtrField< ::Medusa::CoreProto::Editor::Image >&
      images() const;
  inline ::google::protobuf::RepeatedPtrField< ::Medusa::CoreProto::Editor::Image >*
      mutable_images();

  // repeated .Medusa.CoreProto.Editor.Button Buttons = 4;
  inline int buttons_size() const;
  inline void clear_buttons();
  static const int kButtonsFieldNumber = 4;
  inline const ::Medusa::CoreProto::Editor::Button& buttons(int index) const;
  inline ::Medusa::CoreProto::Editor::Button* mutable_buttons(int index);
  inline ::Medusa::CoreProto::Editor::Button* add_buttons();
  inline const ::google::protobuf::RepeatedPtrField< ::Medusa::CoreProto::Editor::Button >&
      buttons() const;
  inline ::google::protobuf::RepeatedPtrField< ::Medusa::CoreProto::Editor::Button >*
      mutable_buttons();

  // repeated .Medusa.CoreProto.Editor.Frame Frames = 5;
  inline int frames_size() const;
  inline void clear_frames();
  static const int kFramesFieldNumber = 5;
  inline const ::Medusa::CoreProto::Editor::Frame& frames(int index) const;
  inline ::Medusa::CoreProto::Editor::Frame* mutable_frames(int index);
  inline ::Medusa::CoreProto::Editor::Frame* add_frames();
  inline const ::google::protobuf::RepeatedPtrField< ::Medusa::CoreProto::Editor::Frame >&
      frames() const;
  inline ::google::protobuf::RepeatedPtrField< ::Medusa::CoreProto::Editor::Frame >*
      mutable_frames();

  // repeated .Medusa.CoreProto.Editor.Label Labels = 6;
  inline int labels_size() const;
  inline void clear_labels();
  static const int kLabelsFieldNumber = 6;
  inline const ::Medusa::CoreProto::Editor::Label& labels(int index) const;
  inline ::Medusa::CoreProto::Editor::Label* mutable_labels(int index);
  inline ::Medusa::CoreProto::Editor::Label* add_labels();
  inline const ::google::protobuf::RepeatedPtrField< ::Medusa::CoreProto::Editor::Label >&
      labels() const;
  inline ::google::protobuf::RepeatedPtrField< ::Medusa::CoreProto::Editor::Label >*
      mutable_labels();

  // repeated .Medusa.CoreProto.Editor.EditBox EditBoxs = 7;
  inline int editboxs_size() const;
  inline void clear_editboxs();
  static const int kEditBoxsFieldNumber = 7;
  inline const ::Medusa::CoreProto::Editor::EditBox& editboxs(int index) const;
  inline ::Medusa::CoreProto::Editor::EditBox* mutable_editboxs(int index);
  inline ::Medusa::CoreProto::Editor::EditBox* add_editboxs();
  inline const ::google::protobuf::RepeatedPtrField< ::Medusa::CoreProto::Editor::EditBox >&
      editboxs() const;
  inline ::google::protobuf::RepeatedPtrField< ::Medusa::CoreProto::Editor::EditBox >*
      mutable_editboxs();

  // repeated .Medusa.CoreProto.Editor.ProgressBar ProgressBars = 9;
  inline int progressbars_size() const;
  inline void clear_progressbars();
  static const int kProgressBarsFieldNumber = 9;
  inline const ::Medusa::CoreProto::Editor::ProgressBar& progressbars(int index) const;
  inline ::Medusa::CoreProto::Editor::ProgressBar* mutable_progressbars(int index);
  inline ::Medusa::CoreProto::Editor::ProgressBar* add_progressbars();
  inline const ::google::protobuf::RepeatedPtrField< ::Medusa::CoreProto::Editor::ProgressBar >&
      progressbars() const;
  inline ::google::protobuf::RepeatedPtrField< ::Medusa::CoreProto::Editor::ProgressBar >*
      mutable_progressbars();

  // repeated .Medusa.CoreProto.Editor.Trigger Triggers = 10;
  inline int triggers_size() const;
  inline void clear_triggers();
  static const int kTriggersFieldNumber = 10;
  inline const ::Medusa::CoreProto::Editor::Trigger& triggers(int index) const;
  inline ::Medusa::CoreProto::Editor::Trigger* mutable_triggers(int index);
  inline ::Medusa::CoreProto::Editor::Trigger* add_triggers();
  inline const ::google::protobuf::RepeatedPtrField< ::Medusa::CoreProto::Editor::Trigger >&
      triggers() const;
  inline ::google::protobuf::RepeatedPtrField< ::Medusa::CoreProto::Editor::Trigger >*
      mutable_triggers();

  // repeated .Medusa.CoreProto.Editor.TriggerRef TriggerRefs = 11;
  inline int triggerrefs_size() const;
  inline void clear_triggerrefs();
  static const int kTriggerRefsFieldNumber = 11;
  inline const ::Medusa::CoreProto::Editor::TriggerRef& triggerrefs(int index) const;
  inline ::Medusa::CoreProto::Editor::TriggerRef* mutable_triggerrefs(int index);
  inline ::Medusa::CoreProto::Editor::TriggerRef* add_triggerrefs();
  inline const ::google::protobuf::RepeatedPtrField< ::Medusa::CoreProto::Editor::TriggerRef >&
      triggerrefs() const;
  inline ::google::protobuf::RepeatedPtrField< ::Medusa::CoreProto::Editor::TriggerRef >*
      mutable_triggerrefs();

  // repeated .Medusa.CoreProto.Editor.LayerRef LayerRefs = 12;
  inline int layerrefs_size() const;
  inline void clear_layerrefs();
  static const int kLayerRefsFieldNumber = 12;
  inline const ::Medusa::CoreProto::Editor::LayerRef& layerrefs(int index) const;
  inline ::Medusa::CoreProto::Editor::LayerRef* mutable_layerrefs(int index);
  inline ::Medusa::CoreProto::Editor::LayerRef* add_layerrefs();
  inline const ::google::protobuf::RepeatedPtrField< ::Medusa::CoreProto::Editor::LayerRef >&
      layerrefs() const;
  inline ::google::protobuf::RepeatedPtrField< ::Medusa::CoreProto::Editor::LayerRef >*
      mutable_layerrefs();

  // optional string OnLoad = 13;
  inline bool has_onload() const;
  inline void clear_onload();
  static const int kOnLoadFieldNumber = 13;
  inline const ::std::string& onload() const;
  inline void set_onload(const ::std::string& value);
  inline void set_onload(const char* value);
  inline void set_onload(const char* value, size_t size);
  inline ::std::string* mutable_onload();
  inline ::std::string* release_onload();
  inline void set_allocated_onload(::std::string* onload);

  // optional string OnShow = 14;
  inline bool has_onshow() const;
  inline void clear_onshow();
  static const int kOnShowFieldNumber = 14;
  inline const ::std::string& onshow() const;
  inline void set_onshow(const ::std::string& value);
  inline void set_onshow(const char* value);
  inline void set_onshow(const char* value, size_t size);
  inline ::std::string* mutable_onshow();
  inline ::std::string* release_onshow();
  inline void set_allocated_onshow(::std::string* onshow);

  // optional string OnHide = 15;
  inline bool has_onhide() const;
  inline void clear_onhide();
  static const int kOnHideFieldNumber = 15;
  inline const ::std::string& onhide() const;
  inline void set_onhide(const ::std::string& value);
  inline void set_onhide(const char* value);
  inline void set_onhide(const char* value, size_t size);
  inline ::std::string* mutable_onhide();
  inline ::std::string* release_onhide();
  inline void set_allocated_onhide(::std::string* onhide);

  // optional string OnClosed = 16;
  inline bool has_onclosed() const;
  inline void clear_onclosed();
  static const int kOnClosedFieldNumber = 16;
  inline const ::std::string& onclosed() const;
  inline void set_onclosed(const ::std::string& value);
  inline void set_onclosed(const char* value);
  inline void set_onclosed(const char* value, size_t size);
  inline ::std::string* mutable_onclosed();
  inline ::std::string* release_onclosed();
  inline void set_allocated_onclosed(::std::string* onclosed);

  // optional string OnUpdate = 17;
  inline bool has_onupdate() const;
  inline void clear_onupdate();
  static const int kOnUpdateFieldNumber = 17;
  inline const ::std::string& onupdate() const;
  inline void set_onupdate(const ::std::string& value);
  inline void set_onupdate(const char* value);
  inline void set_onupdate(const char* value, size_t size);
  inline ::std::string* mutable_onupdate();
  inline ::std::string* release_onupdate();
  inline void set_allocated_onupdate(::std::string* onupdate);

  // optional string OnTouchBegan = 18;
  inline bool has_ontouchbegan() const;
  inline void clear_ontouchbegan();
  static const int kOnTouchBeganFieldNumber = 18;
  inline const ::std::string& ontouchbegan() const;
  inline void set_ontouchbegan(const ::std::string& value);
  inline void set_ontouchbegan(const char* value);
  inline void set_ontouchbegan(const char* value, size_t size);
  inline ::std::string* mutable_ontouchbegan();
  inline ::std::string* release_ontouchbegan();
  inline void set_allocated_ontouchbegan(::std::string* ontouchbegan);

  // optional string OnTouchMoved = 19;
  inline bool has_ontouchmoved() const;
  inline void clear_ontouchmoved();
  static const int kOnTouchMovedFieldNumber = 19;
  inline const ::std::string& ontouchmoved() const;
  inline void set_ontouchmoved(const ::std::string& value);
  inline void set_ontouchmoved(const char* value);
  inline void set_ontouchmoved(const char* value, size_t size);
  inline ::std::string* mutable_ontouchmoved();
  inline ::std::string* release_ontouchmoved();
  inline void set_allocated_ontouchmoved(::std::string* ontouchmoved);

  // optional string OnTouchEnd = 20;
  inline bool has_ontouchend() const;
  inline void clear_ontouchend();
  static const int kOnTouchEndFieldNumber = 20;
  inline const ::std::string& ontouchend() const;
  inline void set_ontouchend(const ::std::string& value);
  inline void set_ontouchend(const char* value);
  inline void set_ontouchend(const char* value, size_t size);
  inline ::std::string* mutable_ontouchend();
  inline ::std::string* release_ontouchend();
  inline void set_allocated_ontouchend(::std::string* ontouchend);

  // repeated .Medusa.CoreProto.Editor.ListBox Lists = 21;
  inline int lists_size() const;
  inline void clear_lists();
  static const int kListsFieldNumber = 21;
  inline const ::Medusa::CoreProto::Editor::ListBox& lists(int index) const;
  inline ::Medusa::CoreProto::Editor::ListBox* mutable_lists(int index);
  inline ::Medusa::CoreProto::Editor::ListBox* add_lists();
  inline const ::google::protobuf::RepeatedPtrField< ::Medusa::CoreProto::Editor::ListBox >&
      lists() const;
  inline ::google::protobuf::RepeatedPtrField< ::Medusa::CoreProto::Editor::ListBox >*
      mutable_lists();

  // optional .Medusa.CoreProto.RectF ScissorBox = 22;
  inline bool has_scissorbox() const;
  inline void clear_scissorbox();
  static const int kScissorBoxFieldNumber = 22;
  inline const ::Medusa::CoreProto::RectF& scissorbox() const;
  inline ::Medusa::CoreProto::RectF* mutable_scissorbox();
  inline ::Medusa::CoreProto::RectF* release_scissorbox();
  inline void set_allocated_scissorbox(::Medusa::CoreProto::RectF* scissorbox);

  // optional int32 Tag = 51;
  inline bool has_tag() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 51;
  inline ::google::protobuf::int32 tag() const;
  inline void set_tag(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Medusa.CoreProto.Editor.Layer)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_onload();
  inline void clear_has_onload();
  inline void set_has_onshow();
  inline void clear_has_onshow();
  inline void set_has_onhide();
  inline void clear_has_onhide();
  inline void set_has_onclosed();
  inline void clear_has_onclosed();
  inline void set_has_onupdate();
  inline void clear_has_onupdate();
  inline void set_has_ontouchbegan();
  inline void clear_has_ontouchbegan();
  inline void set_has_ontouchmoved();
  inline void clear_has_ontouchmoved();
  inline void set_has_ontouchend();
  inline void clear_has_ontouchend();
  inline void set_has_scissorbox();
  inline void clear_has_scissorbox();
  inline void set_has_tag();
  inline void clear_has_tag();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::Medusa::CoreProto::SizeU* size_;
  ::google::protobuf::RepeatedPtrField< ::Medusa::CoreProto::Editor::Image > images_;
  ::google::protobuf::RepeatedPtrField< ::Medusa::CoreProto::Editor::Button > buttons_;
  ::google::protobuf::RepeatedPtrField< ::Medusa::CoreProto::Editor::Frame > frames_;
  ::google::protobuf::RepeatedPtrField< ::Medusa::CoreProto::Editor::Label > labels_;
  ::google::protobuf::RepeatedPtrField< ::Medusa::CoreProto::Editor::EditBox > editboxs_;
  ::google::protobuf::RepeatedPtrField< ::Medusa::CoreProto::Editor::ProgressBar > progressbars_;
  ::google::protobuf::RepeatedPtrField< ::Medusa::CoreProto::Editor::Trigger > triggers_;
  ::google::protobuf::RepeatedPtrField< ::Medusa::CoreProto::Editor::TriggerRef > triggerrefs_;
  ::google::protobuf::RepeatedPtrField< ::Medusa::CoreProto::Editor::LayerRef > layerrefs_;
  ::std::string* onload_;
  ::std::string* onshow_;
  ::std::string* onhide_;
  ::std::string* onclosed_;
  ::std::string* onupdate_;
  ::std::string* ontouchbegan_;
  ::std::string* ontouchmoved_;
  ::std::string* ontouchend_;
  ::google::protobuf::RepeatedPtrField< ::Medusa::CoreProto::Editor::ListBox > lists_;
  ::Medusa::CoreProto::RectF* scissorbox_;
  ::google::protobuf::int32 tag_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(22 + 31) / 32];

  friend void  protobuf_AddDesc_LayerEditor_2eproto();
  friend void protobuf_AssignDesc_LayerEditor_2eproto();
  friend void protobuf_ShutdownFile_LayerEditor_2eproto();

  void InitAsDefaultInstance();
  static Layer* default_instance_;
};
// ===================================================================


// ===================================================================

// ImageFile

// required .Medusa.CoreProto.FileId File = 1;
inline bool ImageFile::has_file() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ImageFile::set_has_file() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ImageFile::clear_has_file() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ImageFile::clear_file() {
  if (file_ != NULL) file_->::Medusa::CoreProto::FileId::Clear();
  clear_has_file();
}
inline const ::Medusa::CoreProto::FileId& ImageFile::file() const {
  return file_ != NULL ? *file_ : *default_instance_->file_;
}
inline ::Medusa::CoreProto::FileId* ImageFile::mutable_file() {
  set_has_file();
  if (file_ == NULL) file_ = new ::Medusa::CoreProto::FileId;
  return file_;
}
inline ::Medusa::CoreProto::FileId* ImageFile::release_file() {
  clear_has_file();
  ::Medusa::CoreProto::FileId* temp = file_;
  file_ = NULL;
  return temp;
}
inline void ImageFile::set_allocated_file(::Medusa::CoreProto::FileId* file) {
  delete file_;
  file_ = file;
  if (file) {
    set_has_file();
  } else {
    clear_has_file();
  }
}

// optional .Medusa.CoreProto.BorderU Border = 2;
inline bool ImageFile::has_border() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ImageFile::set_has_border() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ImageFile::clear_has_border() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ImageFile::clear_border() {
  if (border_ != NULL) border_->::Medusa::CoreProto::BorderU::Clear();
  clear_has_border();
}
inline const ::Medusa::CoreProto::BorderU& ImageFile::border() const {
  return border_ != NULL ? *border_ : *default_instance_->border_;
}
inline ::Medusa::CoreProto::BorderU* ImageFile::mutable_border() {
  set_has_border();
  if (border_ == NULL) border_ = new ::Medusa::CoreProto::BorderU;
  return border_;
}
inline ::Medusa::CoreProto::BorderU* ImageFile::release_border() {
  clear_has_border();
  ::Medusa::CoreProto::BorderU* temp = border_;
  border_ = NULL;
  return temp;
}
inline void ImageFile::set_allocated_border(::Medusa::CoreProto::BorderU* border) {
  delete border_;
  border_ = border;
  if (border) {
    set_has_border();
  } else {
    clear_has_border();
  }
}

// -------------------------------------------------------------------

// Image

// required string ID = 1;
inline bool Image::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Image::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Image::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Image::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& Image::id() const {
  return *id_;
}
inline void Image::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void Image::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void Image::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Image::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* Image::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Image::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .Medusa.CoreProto.Editor.ImageFile OptionalImages = 2;
inline int Image::optionalimages_size() const {
  return optionalimages_.size();
}
inline void Image::clear_optionalimages() {
  optionalimages_.Clear();
}
inline const ::Medusa::CoreProto::Editor::ImageFile& Image::optionalimages(int index) const {
  return optionalimages_.Get(index);
}
inline ::Medusa::CoreProto::Editor::ImageFile* Image::mutable_optionalimages(int index) {
  return optionalimages_.Mutable(index);
}
inline ::Medusa::CoreProto::Editor::ImageFile* Image::add_optionalimages() {
  return optionalimages_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Medusa::CoreProto::Editor::ImageFile >&
Image::optionalimages() const {
  return optionalimages_;
}
inline ::google::protobuf::RepeatedPtrField< ::Medusa::CoreProto::Editor::ImageFile >*
Image::mutable_optionalimages() {
  return &optionalimages_;
}

// required .Medusa.CoreProto.SizeU Size = 3;
inline bool Image::has_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Image::set_has_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Image::clear_has_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Image::clear_size() {
  if (size_ != NULL) size_->::Medusa::CoreProto::SizeU::Clear();
  clear_has_size();
}
inline const ::Medusa::CoreProto::SizeU& Image::size() const {
  return size_ != NULL ? *size_ : *default_instance_->size_;
}
inline ::Medusa::CoreProto::SizeU* Image::mutable_size() {
  set_has_size();
  if (size_ == NULL) size_ = new ::Medusa::CoreProto::SizeU;
  return size_;
}
inline ::Medusa::CoreProto::SizeU* Image::release_size() {
  clear_has_size();
  ::Medusa::CoreProto::SizeU* temp = size_;
  size_ = NULL;
  return temp;
}
inline void Image::set_allocated_size(::Medusa::CoreProto::SizeU* size) {
  delete size_;
  size_ = size;
  if (size) {
    set_has_size();
  } else {
    clear_has_size();
  }
}

// required .Medusa.CoreProto.PointF Position = 4;
inline bool Image::has_position() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Image::set_has_position() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Image::clear_has_position() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Image::clear_position() {
  if (position_ != NULL) position_->::Medusa::CoreProto::PointF::Clear();
  clear_has_position();
}
inline const ::Medusa::CoreProto::PointF& Image::position() const {
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::Medusa::CoreProto::PointF* Image::mutable_position() {
  set_has_position();
  if (position_ == NULL) position_ = new ::Medusa::CoreProto::PointF;
  return position_;
}
inline ::Medusa::CoreProto::PointF* Image::release_position() {
  clear_has_position();
  ::Medusa::CoreProto::PointF* temp = position_;
  position_ = NULL;
  return temp;
}
inline void Image::set_allocated_position(::Medusa::CoreProto::PointF* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
}

// required bool IsProportionPoint = 5;
inline bool Image::has_isproportionpoint() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Image::set_has_isproportionpoint() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Image::clear_has_isproportionpoint() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Image::clear_isproportionpoint() {
  isproportionpoint_ = false;
  clear_has_isproportionpoint();
}
inline bool Image::isproportionpoint() const {
  return isproportionpoint_;
}
inline void Image::set_isproportionpoint(bool value) {
  set_has_isproportionpoint();
  isproportionpoint_ = value;
}

// required .Medusa.CoreProto.PointF Anchor = 6;
inline bool Image::has_anchor() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Image::set_has_anchor() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Image::clear_has_anchor() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Image::clear_anchor() {
  if (anchor_ != NULL) anchor_->::Medusa::CoreProto::PointF::Clear();
  clear_has_anchor();
}
inline const ::Medusa::CoreProto::PointF& Image::anchor() const {
  return anchor_ != NULL ? *anchor_ : *default_instance_->anchor_;
}
inline ::Medusa::CoreProto::PointF* Image::mutable_anchor() {
  set_has_anchor();
  if (anchor_ == NULL) anchor_ = new ::Medusa::CoreProto::PointF;
  return anchor_;
}
inline ::Medusa::CoreProto::PointF* Image::release_anchor() {
  clear_has_anchor();
  ::Medusa::CoreProto::PointF* temp = anchor_;
  anchor_ = NULL;
  return temp;
}
inline void Image::set_allocated_anchor(::Medusa::CoreProto::PointF* anchor) {
  delete anchor_;
  anchor_ = anchor;
  if (anchor) {
    set_has_anchor();
  } else {
    clear_has_anchor();
  }
}

// required int32 ZOrder = 7;
inline bool Image::has_zorder() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Image::set_has_zorder() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Image::clear_has_zorder() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Image::clear_zorder() {
  zorder_ = 0;
  clear_has_zorder();
}
inline ::google::protobuf::int32 Image::zorder() const {
  return zorder_;
}
inline void Image::set_zorder(::google::protobuf::int32 value) {
  set_has_zorder();
  zorder_ = value;
}

// optional float Rotation = 8;
inline bool Image::has_rotation() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Image::set_has_rotation() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Image::clear_has_rotation() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Image::clear_rotation() {
  rotation_ = 0;
  clear_has_rotation();
}
inline float Image::rotation() const {
  return rotation_;
}
inline void Image::set_rotation(float value) {
  set_has_rotation();
  rotation_ = value;
}

// optional .Medusa.CoreProto.ScaleF Scale = 9;
inline bool Image::has_scale() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Image::set_has_scale() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Image::clear_has_scale() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Image::clear_scale() {
  if (scale_ != NULL) scale_->::Medusa::CoreProto::ScaleF::Clear();
  clear_has_scale();
}
inline const ::Medusa::CoreProto::ScaleF& Image::scale() const {
  return scale_ != NULL ? *scale_ : *default_instance_->scale_;
}
inline ::Medusa::CoreProto::ScaleF* Image::mutable_scale() {
  set_has_scale();
  if (scale_ == NULL) scale_ = new ::Medusa::CoreProto::ScaleF;
  return scale_;
}
inline ::Medusa::CoreProto::ScaleF* Image::release_scale() {
  clear_has_scale();
  ::Medusa::CoreProto::ScaleF* temp = scale_;
  scale_ = NULL;
  return temp;
}
inline void Image::set_allocated_scale(::Medusa::CoreProto::ScaleF* scale) {
  delete scale_;
  scale_ = scale;
  if (scale) {
    set_has_scale();
  } else {
    clear_has_scale();
  }
}

// optional bool IsFilpX = 10;
inline bool Image::has_isfilpx() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Image::set_has_isfilpx() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Image::clear_has_isfilpx() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Image::clear_isfilpx() {
  isfilpx_ = false;
  clear_has_isfilpx();
}
inline bool Image::isfilpx() const {
  return isfilpx_;
}
inline void Image::set_isfilpx(bool value) {
  set_has_isfilpx();
  isfilpx_ = value;
}

// optional bool IsFilpY = 11;
inline bool Image::has_isfilpy() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Image::set_has_isfilpy() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Image::clear_has_isfilpy() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Image::clear_isfilpy() {
  isfilpy_ = false;
  clear_has_isfilpy();
}
inline bool Image::isfilpy() const {
  return isfilpy_;
}
inline void Image::set_isfilpy(bool value) {
  set_has_isfilpy();
  isfilpy_ = value;
}

// required bool IsVisible = 12;
inline bool Image::has_isvisible() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Image::set_has_isvisible() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Image::clear_has_isvisible() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Image::clear_isvisible() {
  isvisible_ = false;
  clear_has_isvisible();
}
inline bool Image::isvisible() const {
  return isvisible_;
}
inline void Image::set_isvisible(bool value) {
  set_has_isvisible();
  isvisible_ = value;
}

// required float Parallax = 13;
inline bool Image::has_parallax() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Image::set_has_parallax() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Image::clear_has_parallax() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Image::clear_parallax() {
  parallax_ = 0;
  clear_has_parallax();
}
inline float Image::parallax() const {
  return parallax_;
}
inline void Image::set_parallax(float value) {
  set_has_parallax();
  parallax_ = value;
}

// required .Medusa.CoreProto.Editor.ImageFile File = 14;
inline bool Image::has_file() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Image::set_has_file() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Image::clear_has_file() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Image::clear_file() {
  if (file_ != NULL) file_->::Medusa::CoreProto::Editor::ImageFile::Clear();
  clear_has_file();
}
inline const ::Medusa::CoreProto::Editor::ImageFile& Image::file() const {
  return file_ != NULL ? *file_ : *default_instance_->file_;
}
inline ::Medusa::CoreProto::Editor::ImageFile* Image::mutable_file() {
  set_has_file();
  if (file_ == NULL) file_ = new ::Medusa::CoreProto::Editor::ImageFile;
  return file_;
}
inline ::Medusa::CoreProto::Editor::ImageFile* Image::release_file() {
  clear_has_file();
  ::Medusa::CoreProto::Editor::ImageFile* temp = file_;
  file_ = NULL;
  return temp;
}
inline void Image::set_allocated_file(::Medusa::CoreProto::Editor::ImageFile* file) {
  delete file_;
  file_ = file;
  if (file) {
    set_has_file();
  } else {
    clear_has_file();
  }
}

// optional string OnLoad = 15;
inline bool Image::has_onload() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Image::set_has_onload() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Image::clear_has_onload() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Image::clear_onload() {
  if (onload_ != &::google::protobuf::internal::kEmptyString) {
    onload_->clear();
  }
  clear_has_onload();
}
inline const ::std::string& Image::onload() const {
  return *onload_;
}
inline void Image::set_onload(const ::std::string& value) {
  set_has_onload();
  if (onload_ == &::google::protobuf::internal::kEmptyString) {
    onload_ = new ::std::string;
  }
  onload_->assign(value);
}
inline void Image::set_onload(const char* value) {
  set_has_onload();
  if (onload_ == &::google::protobuf::internal::kEmptyString) {
    onload_ = new ::std::string;
  }
  onload_->assign(value);
}
inline void Image::set_onload(const char* value, size_t size) {
  set_has_onload();
  if (onload_ == &::google::protobuf::internal::kEmptyString) {
    onload_ = new ::std::string;
  }
  onload_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Image::mutable_onload() {
  set_has_onload();
  if (onload_ == &::google::protobuf::internal::kEmptyString) {
    onload_ = new ::std::string;
  }
  return onload_;
}
inline ::std::string* Image::release_onload() {
  clear_has_onload();
  if (onload_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = onload_;
    onload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Image::set_allocated_onload(::std::string* onload) {
  if (onload_ != &::google::protobuf::internal::kEmptyString) {
    delete onload_;
  }
  if (onload) {
    set_has_onload();
    onload_ = onload;
  } else {
    clear_has_onload();
    onload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string OnShow = 16;
inline bool Image::has_onshow() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Image::set_has_onshow() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Image::clear_has_onshow() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Image::clear_onshow() {
  if (onshow_ != &::google::protobuf::internal::kEmptyString) {
    onshow_->clear();
  }
  clear_has_onshow();
}
inline const ::std::string& Image::onshow() const {
  return *onshow_;
}
inline void Image::set_onshow(const ::std::string& value) {
  set_has_onshow();
  if (onshow_ == &::google::protobuf::internal::kEmptyString) {
    onshow_ = new ::std::string;
  }
  onshow_->assign(value);
}
inline void Image::set_onshow(const char* value) {
  set_has_onshow();
  if (onshow_ == &::google::protobuf::internal::kEmptyString) {
    onshow_ = new ::std::string;
  }
  onshow_->assign(value);
}
inline void Image::set_onshow(const char* value, size_t size) {
  set_has_onshow();
  if (onshow_ == &::google::protobuf::internal::kEmptyString) {
    onshow_ = new ::std::string;
  }
  onshow_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Image::mutable_onshow() {
  set_has_onshow();
  if (onshow_ == &::google::protobuf::internal::kEmptyString) {
    onshow_ = new ::std::string;
  }
  return onshow_;
}
inline ::std::string* Image::release_onshow() {
  clear_has_onshow();
  if (onshow_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = onshow_;
    onshow_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Image::set_allocated_onshow(::std::string* onshow) {
  if (onshow_ != &::google::protobuf::internal::kEmptyString) {
    delete onshow_;
  }
  if (onshow) {
    set_has_onshow();
    onshow_ = onshow;
  } else {
    clear_has_onshow();
    onshow_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string OnHide = 17;
inline bool Image::has_onhide() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Image::set_has_onhide() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Image::clear_has_onhide() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Image::clear_onhide() {
  if (onhide_ != &::google::protobuf::internal::kEmptyString) {
    onhide_->clear();
  }
  clear_has_onhide();
}
inline const ::std::string& Image::onhide() const {
  return *onhide_;
}
inline void Image::set_onhide(const ::std::string& value) {
  set_has_onhide();
  if (onhide_ == &::google::protobuf::internal::kEmptyString) {
    onhide_ = new ::std::string;
  }
  onhide_->assign(value);
}
inline void Image::set_onhide(const char* value) {
  set_has_onhide();
  if (onhide_ == &::google::protobuf::internal::kEmptyString) {
    onhide_ = new ::std::string;
  }
  onhide_->assign(value);
}
inline void Image::set_onhide(const char* value, size_t size) {
  set_has_onhide();
  if (onhide_ == &::google::protobuf::internal::kEmptyString) {
    onhide_ = new ::std::string;
  }
  onhide_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Image::mutable_onhide() {
  set_has_onhide();
  if (onhide_ == &::google::protobuf::internal::kEmptyString) {
    onhide_ = new ::std::string;
  }
  return onhide_;
}
inline ::std::string* Image::release_onhide() {
  clear_has_onhide();
  if (onhide_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = onhide_;
    onhide_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Image::set_allocated_onhide(::std::string* onhide) {
  if (onhide_ != &::google::protobuf::internal::kEmptyString) {
    delete onhide_;
  }
  if (onhide) {
    set_has_onhide();
    onhide_ = onhide;
  } else {
    clear_has_onhide();
    onhide_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string OnClosed = 18;
inline bool Image::has_onclosed() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Image::set_has_onclosed() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Image::clear_has_onclosed() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Image::clear_onclosed() {
  if (onclosed_ != &::google::protobuf::internal::kEmptyString) {
    onclosed_->clear();
  }
  clear_has_onclosed();
}
inline const ::std::string& Image::onclosed() const {
  return *onclosed_;
}
inline void Image::set_onclosed(const ::std::string& value) {
  set_has_onclosed();
  if (onclosed_ == &::google::protobuf::internal::kEmptyString) {
    onclosed_ = new ::std::string;
  }
  onclosed_->assign(value);
}
inline void Image::set_onclosed(const char* value) {
  set_has_onclosed();
  if (onclosed_ == &::google::protobuf::internal::kEmptyString) {
    onclosed_ = new ::std::string;
  }
  onclosed_->assign(value);
}
inline void Image::set_onclosed(const char* value, size_t size) {
  set_has_onclosed();
  if (onclosed_ == &::google::protobuf::internal::kEmptyString) {
    onclosed_ = new ::std::string;
  }
  onclosed_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Image::mutable_onclosed() {
  set_has_onclosed();
  if (onclosed_ == &::google::protobuf::internal::kEmptyString) {
    onclosed_ = new ::std::string;
  }
  return onclosed_;
}
inline ::std::string* Image::release_onclosed() {
  clear_has_onclosed();
  if (onclosed_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = onclosed_;
    onclosed_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Image::set_allocated_onclosed(::std::string* onclosed) {
  if (onclosed_ != &::google::protobuf::internal::kEmptyString) {
    delete onclosed_;
  }
  if (onclosed) {
    set_has_onclosed();
    onclosed_ = onclosed;
  } else {
    clear_has_onclosed();
    onclosed_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string OnUpdate = 19;
inline bool Image::has_onupdate() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Image::set_has_onupdate() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Image::clear_has_onupdate() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Image::clear_onupdate() {
  if (onupdate_ != &::google::protobuf::internal::kEmptyString) {
    onupdate_->clear();
  }
  clear_has_onupdate();
}
inline const ::std::string& Image::onupdate() const {
  return *onupdate_;
}
inline void Image::set_onupdate(const ::std::string& value) {
  set_has_onupdate();
  if (onupdate_ == &::google::protobuf::internal::kEmptyString) {
    onupdate_ = new ::std::string;
  }
  onupdate_->assign(value);
}
inline void Image::set_onupdate(const char* value) {
  set_has_onupdate();
  if (onupdate_ == &::google::protobuf::internal::kEmptyString) {
    onupdate_ = new ::std::string;
  }
  onupdate_->assign(value);
}
inline void Image::set_onupdate(const char* value, size_t size) {
  set_has_onupdate();
  if (onupdate_ == &::google::protobuf::internal::kEmptyString) {
    onupdate_ = new ::std::string;
  }
  onupdate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Image::mutable_onupdate() {
  set_has_onupdate();
  if (onupdate_ == &::google::protobuf::internal::kEmptyString) {
    onupdate_ = new ::std::string;
  }
  return onupdate_;
}
inline ::std::string* Image::release_onupdate() {
  clear_has_onupdate();
  if (onupdate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = onupdate_;
    onupdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Image::set_allocated_onupdate(::std::string* onupdate) {
  if (onupdate_ != &::google::protobuf::internal::kEmptyString) {
    delete onupdate_;
  }
  if (onupdate) {
    set_has_onupdate();
    onupdate_ = onupdate;
  } else {
    clear_has_onupdate();
    onupdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string OnEvent = 20;
inline bool Image::has_onevent() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void Image::set_has_onevent() {
  _has_bits_[0] |= 0x00080000u;
}
inline void Image::clear_has_onevent() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void Image::clear_onevent() {
  if (onevent_ != &::google::protobuf::internal::kEmptyString) {
    onevent_->clear();
  }
  clear_has_onevent();
}
inline const ::std::string& Image::onevent() const {
  return *onevent_;
}
inline void Image::set_onevent(const ::std::string& value) {
  set_has_onevent();
  if (onevent_ == &::google::protobuf::internal::kEmptyString) {
    onevent_ = new ::std::string;
  }
  onevent_->assign(value);
}
inline void Image::set_onevent(const char* value) {
  set_has_onevent();
  if (onevent_ == &::google::protobuf::internal::kEmptyString) {
    onevent_ = new ::std::string;
  }
  onevent_->assign(value);
}
inline void Image::set_onevent(const char* value, size_t size) {
  set_has_onevent();
  if (onevent_ == &::google::protobuf::internal::kEmptyString) {
    onevent_ = new ::std::string;
  }
  onevent_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Image::mutable_onevent() {
  set_has_onevent();
  if (onevent_ == &::google::protobuf::internal::kEmptyString) {
    onevent_ = new ::std::string;
  }
  return onevent_;
}
inline ::std::string* Image::release_onevent() {
  clear_has_onevent();
  if (onevent_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = onevent_;
    onevent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Image::set_allocated_onevent(::std::string* onevent) {
  if (onevent_ != &::google::protobuf::internal::kEmptyString) {
    delete onevent_;
  }
  if (onevent) {
    set_has_onevent();
    onevent_ = onevent;
  } else {
    clear_has_onevent();
    onevent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool IsLoop = 21;
inline bool Image::has_isloop() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void Image::set_has_isloop() {
  _has_bits_[0] |= 0x00100000u;
}
inline void Image::clear_has_isloop() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void Image::clear_isloop() {
  isloop_ = false;
  clear_has_isloop();
}
inline bool Image::isloop() const {
  return isloop_;
}
inline void Image::set_isloop(bool value) {
  set_has_isloop();
  isloop_ = value;
}

// optional .Medusa.CoreProto.RectF ScissorBox = 22;
inline bool Image::has_scissorbox() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void Image::set_has_scissorbox() {
  _has_bits_[0] |= 0x00200000u;
}
inline void Image::clear_has_scissorbox() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void Image::clear_scissorbox() {
  if (scissorbox_ != NULL) scissorbox_->::Medusa::CoreProto::RectF::Clear();
  clear_has_scissorbox();
}
inline const ::Medusa::CoreProto::RectF& Image::scissorbox() const {
  return scissorbox_ != NULL ? *scissorbox_ : *default_instance_->scissorbox_;
}
inline ::Medusa::CoreProto::RectF* Image::mutable_scissorbox() {
  set_has_scissorbox();
  if (scissorbox_ == NULL) scissorbox_ = new ::Medusa::CoreProto::RectF;
  return scissorbox_;
}
inline ::Medusa::CoreProto::RectF* Image::release_scissorbox() {
  clear_has_scissorbox();
  ::Medusa::CoreProto::RectF* temp = scissorbox_;
  scissorbox_ = NULL;
  return temp;
}
inline void Image::set_allocated_scissorbox(::Medusa::CoreProto::RectF* scissorbox) {
  delete scissorbox_;
  scissorbox_ = scissorbox;
  if (scissorbox) {
    set_has_scissorbox();
  } else {
    clear_has_scissorbox();
  }
}

// optional int32 RenderFlag = 50;
inline bool Image::has_renderflag() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void Image::set_has_renderflag() {
  _has_bits_[0] |= 0x00400000u;
}
inline void Image::clear_has_renderflag() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void Image::clear_renderflag() {
  renderflag_ = 0;
  clear_has_renderflag();
}
inline ::google::protobuf::int32 Image::renderflag() const {
  return renderflag_;
}
inline void Image::set_renderflag(::google::protobuf::int32 value) {
  set_has_renderflag();
  renderflag_ = value;
}

// optional int32 Tag = 51;
inline bool Image::has_tag() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void Image::set_has_tag() {
  _has_bits_[0] |= 0x00800000u;
}
inline void Image::clear_has_tag() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void Image::clear_tag() {
  tag_ = 0;
  clear_has_tag();
}
inline ::google::protobuf::int32 Image::tag() const {
  return tag_;
}
inline void Image::set_tag(::google::protobuf::int32 value) {
  set_has_tag();
  tag_ = value;
}

// optional string ClickEffect = 101;
inline bool Image::has_clickeffect() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void Image::set_has_clickeffect() {
  _has_bits_[0] |= 0x01000000u;
}
inline void Image::clear_has_clickeffect() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void Image::clear_clickeffect() {
  if (clickeffect_ != &::google::protobuf::internal::kEmptyString) {
    clickeffect_->clear();
  }
  clear_has_clickeffect();
}
inline const ::std::string& Image::clickeffect() const {
  return *clickeffect_;
}
inline void Image::set_clickeffect(const ::std::string& value) {
  set_has_clickeffect();
  if (clickeffect_ == &::google::protobuf::internal::kEmptyString) {
    clickeffect_ = new ::std::string;
  }
  clickeffect_->assign(value);
}
inline void Image::set_clickeffect(const char* value) {
  set_has_clickeffect();
  if (clickeffect_ == &::google::protobuf::internal::kEmptyString) {
    clickeffect_ = new ::std::string;
  }
  clickeffect_->assign(value);
}
inline void Image::set_clickeffect(const char* value, size_t size) {
  set_has_clickeffect();
  if (clickeffect_ == &::google::protobuf::internal::kEmptyString) {
    clickeffect_ = new ::std::string;
  }
  clickeffect_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Image::mutable_clickeffect() {
  set_has_clickeffect();
  if (clickeffect_ == &::google::protobuf::internal::kEmptyString) {
    clickeffect_ = new ::std::string;
  }
  return clickeffect_;
}
inline ::std::string* Image::release_clickeffect() {
  clear_has_clickeffect();
  if (clickeffect_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = clickeffect_;
    clickeffect_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Image::set_allocated_clickeffect(::std::string* clickeffect) {
  if (clickeffect_ != &::google::protobuf::internal::kEmptyString) {
    delete clickeffect_;
  }
  if (clickeffect) {
    set_has_clickeffect();
    clickeffect_ = clickeffect;
  } else {
    clear_has_clickeffect();
    clickeffect_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool IsLock = 201;
inline bool Image::has_islock() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void Image::set_has_islock() {
  _has_bits_[0] |= 0x02000000u;
}
inline void Image::clear_has_islock() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void Image::clear_islock() {
  islock_ = false;
  clear_has_islock();
}
inline bool Image::islock() const {
  return islock_;
}
inline void Image::set_islock(bool value) {
  set_has_islock();
  islock_ = value;
}

// optional bool IsHide = 202;
inline bool Image::has_ishide() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void Image::set_has_ishide() {
  _has_bits_[0] |= 0x04000000u;
}
inline void Image::clear_has_ishide() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void Image::clear_ishide() {
  ishide_ = false;
  clear_has_ishide();
}
inline bool Image::ishide() const {
  return ishide_;
}
inline void Image::set_ishide(bool value) {
  set_has_ishide();
  ishide_ = value;
}

// -------------------------------------------------------------------

// Button

// required string ID = 1;
inline bool Button::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Button::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Button::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Button::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& Button::id() const {
  return *id_;
}
inline void Button::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void Button::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void Button::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Button::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* Button::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Button::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .Medusa.CoreProto.SizeU Size = 2;
inline bool Button::has_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Button::set_has_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Button::clear_has_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Button::clear_size() {
  if (size_ != NULL) size_->::Medusa::CoreProto::SizeU::Clear();
  clear_has_size();
}
inline const ::Medusa::CoreProto::SizeU& Button::size() const {
  return size_ != NULL ? *size_ : *default_instance_->size_;
}
inline ::Medusa::CoreProto::SizeU* Button::mutable_size() {
  set_has_size();
  if (size_ == NULL) size_ = new ::Medusa::CoreProto::SizeU;
  return size_;
}
inline ::Medusa::CoreProto::SizeU* Button::release_size() {
  clear_has_size();
  ::Medusa::CoreProto::SizeU* temp = size_;
  size_ = NULL;
  return temp;
}
inline void Button::set_allocated_size(::Medusa::CoreProto::SizeU* size) {
  delete size_;
  size_ = size;
  if (size) {
    set_has_size();
  } else {
    clear_has_size();
  }
}

// required .Medusa.CoreProto.PointF Position = 3;
inline bool Button::has_position() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Button::set_has_position() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Button::clear_has_position() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Button::clear_position() {
  if (position_ != NULL) position_->::Medusa::CoreProto::PointF::Clear();
  clear_has_position();
}
inline const ::Medusa::CoreProto::PointF& Button::position() const {
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::Medusa::CoreProto::PointF* Button::mutable_position() {
  set_has_position();
  if (position_ == NULL) position_ = new ::Medusa::CoreProto::PointF;
  return position_;
}
inline ::Medusa::CoreProto::PointF* Button::release_position() {
  clear_has_position();
  ::Medusa::CoreProto::PointF* temp = position_;
  position_ = NULL;
  return temp;
}
inline void Button::set_allocated_position(::Medusa::CoreProto::PointF* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
}

// required bool IsProportionPoint = 4;
inline bool Button::has_isproportionpoint() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Button::set_has_isproportionpoint() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Button::clear_has_isproportionpoint() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Button::clear_isproportionpoint() {
  isproportionpoint_ = false;
  clear_has_isproportionpoint();
}
inline bool Button::isproportionpoint() const {
  return isproportionpoint_;
}
inline void Button::set_isproportionpoint(bool value) {
  set_has_isproportionpoint();
  isproportionpoint_ = value;
}

// required .Medusa.CoreProto.PointF Anchor = 5;
inline bool Button::has_anchor() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Button::set_has_anchor() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Button::clear_has_anchor() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Button::clear_anchor() {
  if (anchor_ != NULL) anchor_->::Medusa::CoreProto::PointF::Clear();
  clear_has_anchor();
}
inline const ::Medusa::CoreProto::PointF& Button::anchor() const {
  return anchor_ != NULL ? *anchor_ : *default_instance_->anchor_;
}
inline ::Medusa::CoreProto::PointF* Button::mutable_anchor() {
  set_has_anchor();
  if (anchor_ == NULL) anchor_ = new ::Medusa::CoreProto::PointF;
  return anchor_;
}
inline ::Medusa::CoreProto::PointF* Button::release_anchor() {
  clear_has_anchor();
  ::Medusa::CoreProto::PointF* temp = anchor_;
  anchor_ = NULL;
  return temp;
}
inline void Button::set_allocated_anchor(::Medusa::CoreProto::PointF* anchor) {
  delete anchor_;
  anchor_ = anchor;
  if (anchor) {
    set_has_anchor();
  } else {
    clear_has_anchor();
  }
}

// required int32 ZOrder = 6;
inline bool Button::has_zorder() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Button::set_has_zorder() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Button::clear_has_zorder() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Button::clear_zorder() {
  zorder_ = 0;
  clear_has_zorder();
}
inline ::google::protobuf::int32 Button::zorder() const {
  return zorder_;
}
inline void Button::set_zorder(::google::protobuf::int32 value) {
  set_has_zorder();
  zorder_ = value;
}

// optional float Rotation = 7;
inline bool Button::has_rotation() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Button::set_has_rotation() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Button::clear_has_rotation() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Button::clear_rotation() {
  rotation_ = 0;
  clear_has_rotation();
}
inline float Button::rotation() const {
  return rotation_;
}
inline void Button::set_rotation(float value) {
  set_has_rotation();
  rotation_ = value;
}

// optional .Medusa.CoreProto.ScaleF Scale = 8;
inline bool Button::has_scale() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Button::set_has_scale() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Button::clear_has_scale() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Button::clear_scale() {
  if (scale_ != NULL) scale_->::Medusa::CoreProto::ScaleF::Clear();
  clear_has_scale();
}
inline const ::Medusa::CoreProto::ScaleF& Button::scale() const {
  return scale_ != NULL ? *scale_ : *default_instance_->scale_;
}
inline ::Medusa::CoreProto::ScaleF* Button::mutable_scale() {
  set_has_scale();
  if (scale_ == NULL) scale_ = new ::Medusa::CoreProto::ScaleF;
  return scale_;
}
inline ::Medusa::CoreProto::ScaleF* Button::release_scale() {
  clear_has_scale();
  ::Medusa::CoreProto::ScaleF* temp = scale_;
  scale_ = NULL;
  return temp;
}
inline void Button::set_allocated_scale(::Medusa::CoreProto::ScaleF* scale) {
  delete scale_;
  scale_ = scale;
  if (scale) {
    set_has_scale();
  } else {
    clear_has_scale();
  }
}

// optional bool IsFilpX = 9;
inline bool Button::has_isfilpx() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Button::set_has_isfilpx() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Button::clear_has_isfilpx() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Button::clear_isfilpx() {
  isfilpx_ = false;
  clear_has_isfilpx();
}
inline bool Button::isfilpx() const {
  return isfilpx_;
}
inline void Button::set_isfilpx(bool value) {
  set_has_isfilpx();
  isfilpx_ = value;
}

// optional bool IsFilpY = 10;
inline bool Button::has_isfilpy() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Button::set_has_isfilpy() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Button::clear_has_isfilpy() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Button::clear_isfilpy() {
  isfilpy_ = false;
  clear_has_isfilpy();
}
inline bool Button::isfilpy() const {
  return isfilpy_;
}
inline void Button::set_isfilpy(bool value) {
  set_has_isfilpy();
  isfilpy_ = value;
}

// required bool IsVisible = 11;
inline bool Button::has_isvisible() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Button::set_has_isvisible() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Button::clear_has_isvisible() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Button::clear_isvisible() {
  isvisible_ = false;
  clear_has_isvisible();
}
inline bool Button::isvisible() const {
  return isvisible_;
}
inline void Button::set_isvisible(bool value) {
  set_has_isvisible();
  isvisible_ = value;
}

// optional .Medusa.CoreProto.Editor.ImageFile NormalImage = 12;
inline bool Button::has_normalimage() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Button::set_has_normalimage() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Button::clear_has_normalimage() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Button::clear_normalimage() {
  if (normalimage_ != NULL) normalimage_->::Medusa::CoreProto::Editor::ImageFile::Clear();
  clear_has_normalimage();
}
inline const ::Medusa::CoreProto::Editor::ImageFile& Button::normalimage() const {
  return normalimage_ != NULL ? *normalimage_ : *default_instance_->normalimage_;
}
inline ::Medusa::CoreProto::Editor::ImageFile* Button::mutable_normalimage() {
  set_has_normalimage();
  if (normalimage_ == NULL) normalimage_ = new ::Medusa::CoreProto::Editor::ImageFile;
  return normalimage_;
}
inline ::Medusa::CoreProto::Editor::ImageFile* Button::release_normalimage() {
  clear_has_normalimage();
  ::Medusa::CoreProto::Editor::ImageFile* temp = normalimage_;
  normalimage_ = NULL;
  return temp;
}
inline void Button::set_allocated_normalimage(::Medusa::CoreProto::Editor::ImageFile* normalimage) {
  delete normalimage_;
  normalimage_ = normalimage;
  if (normalimage) {
    set_has_normalimage();
  } else {
    clear_has_normalimage();
  }
}

// optional .Medusa.CoreProto.Editor.ImageFile SelectedImage = 13;
inline bool Button::has_selectedimage() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Button::set_has_selectedimage() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Button::clear_has_selectedimage() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Button::clear_selectedimage() {
  if (selectedimage_ != NULL) selectedimage_->::Medusa::CoreProto::Editor::ImageFile::Clear();
  clear_has_selectedimage();
}
inline const ::Medusa::CoreProto::Editor::ImageFile& Button::selectedimage() const {
  return selectedimage_ != NULL ? *selectedimage_ : *default_instance_->selectedimage_;
}
inline ::Medusa::CoreProto::Editor::ImageFile* Button::mutable_selectedimage() {
  set_has_selectedimage();
  if (selectedimage_ == NULL) selectedimage_ = new ::Medusa::CoreProto::Editor::ImageFile;
  return selectedimage_;
}
inline ::Medusa::CoreProto::Editor::ImageFile* Button::release_selectedimage() {
  clear_has_selectedimage();
  ::Medusa::CoreProto::Editor::ImageFile* temp = selectedimage_;
  selectedimage_ = NULL;
  return temp;
}
inline void Button::set_allocated_selectedimage(::Medusa::CoreProto::Editor::ImageFile* selectedimage) {
  delete selectedimage_;
  selectedimage_ = selectedimage;
  if (selectedimage) {
    set_has_selectedimage();
  } else {
    clear_has_selectedimage();
  }
}

// optional .Medusa.CoreProto.Editor.ImageFile DisabledImage = 14;
inline bool Button::has_disabledimage() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Button::set_has_disabledimage() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Button::clear_has_disabledimage() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Button::clear_disabledimage() {
  if (disabledimage_ != NULL) disabledimage_->::Medusa::CoreProto::Editor::ImageFile::Clear();
  clear_has_disabledimage();
}
inline const ::Medusa::CoreProto::Editor::ImageFile& Button::disabledimage() const {
  return disabledimage_ != NULL ? *disabledimage_ : *default_instance_->disabledimage_;
}
inline ::Medusa::CoreProto::Editor::ImageFile* Button::mutable_disabledimage() {
  set_has_disabledimage();
  if (disabledimage_ == NULL) disabledimage_ = new ::Medusa::CoreProto::Editor::ImageFile;
  return disabledimage_;
}
inline ::Medusa::CoreProto::Editor::ImageFile* Button::release_disabledimage() {
  clear_has_disabledimage();
  ::Medusa::CoreProto::Editor::ImageFile* temp = disabledimage_;
  disabledimage_ = NULL;
  return temp;
}
inline void Button::set_allocated_disabledimage(::Medusa::CoreProto::Editor::ImageFile* disabledimage) {
  delete disabledimage_;
  disabledimage_ = disabledimage;
  if (disabledimage) {
    set_has_disabledimage();
  } else {
    clear_has_disabledimage();
  }
}

// optional .Medusa.CoreProto.Editor.ImageFile DisabledSelectedImage = 15;
inline bool Button::has_disabledselectedimage() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Button::set_has_disabledselectedimage() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Button::clear_has_disabledselectedimage() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Button::clear_disabledselectedimage() {
  if (disabledselectedimage_ != NULL) disabledselectedimage_->::Medusa::CoreProto::Editor::ImageFile::Clear();
  clear_has_disabledselectedimage();
}
inline const ::Medusa::CoreProto::Editor::ImageFile& Button::disabledselectedimage() const {
  return disabledselectedimage_ != NULL ? *disabledselectedimage_ : *default_instance_->disabledselectedimage_;
}
inline ::Medusa::CoreProto::Editor::ImageFile* Button::mutable_disabledselectedimage() {
  set_has_disabledselectedimage();
  if (disabledselectedimage_ == NULL) disabledselectedimage_ = new ::Medusa::CoreProto::Editor::ImageFile;
  return disabledselectedimage_;
}
inline ::Medusa::CoreProto::Editor::ImageFile* Button::release_disabledselectedimage() {
  clear_has_disabledselectedimage();
  ::Medusa::CoreProto::Editor::ImageFile* temp = disabledselectedimage_;
  disabledselectedimage_ = NULL;
  return temp;
}
inline void Button::set_allocated_disabledselectedimage(::Medusa::CoreProto::Editor::ImageFile* disabledselectedimage) {
  delete disabledselectedimage_;
  disabledselectedimage_ = disabledselectedimage;
  if (disabledselectedimage) {
    set_has_disabledselectedimage();
  } else {
    clear_has_disabledselectedimage();
  }
}

// optional string OnLoad = 16;
inline bool Button::has_onload() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Button::set_has_onload() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Button::clear_has_onload() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Button::clear_onload() {
  if (onload_ != &::google::protobuf::internal::kEmptyString) {
    onload_->clear();
  }
  clear_has_onload();
}
inline const ::std::string& Button::onload() const {
  return *onload_;
}
inline void Button::set_onload(const ::std::string& value) {
  set_has_onload();
  if (onload_ == &::google::protobuf::internal::kEmptyString) {
    onload_ = new ::std::string;
  }
  onload_->assign(value);
}
inline void Button::set_onload(const char* value) {
  set_has_onload();
  if (onload_ == &::google::protobuf::internal::kEmptyString) {
    onload_ = new ::std::string;
  }
  onload_->assign(value);
}
inline void Button::set_onload(const char* value, size_t size) {
  set_has_onload();
  if (onload_ == &::google::protobuf::internal::kEmptyString) {
    onload_ = new ::std::string;
  }
  onload_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Button::mutable_onload() {
  set_has_onload();
  if (onload_ == &::google::protobuf::internal::kEmptyString) {
    onload_ = new ::std::string;
  }
  return onload_;
}
inline ::std::string* Button::release_onload() {
  clear_has_onload();
  if (onload_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = onload_;
    onload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Button::set_allocated_onload(::std::string* onload) {
  if (onload_ != &::google::protobuf::internal::kEmptyString) {
    delete onload_;
  }
  if (onload) {
    set_has_onload();
    onload_ = onload;
  } else {
    clear_has_onload();
    onload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string OnShow = 17;
inline bool Button::has_onshow() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Button::set_has_onshow() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Button::clear_has_onshow() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Button::clear_onshow() {
  if (onshow_ != &::google::protobuf::internal::kEmptyString) {
    onshow_->clear();
  }
  clear_has_onshow();
}
inline const ::std::string& Button::onshow() const {
  return *onshow_;
}
inline void Button::set_onshow(const ::std::string& value) {
  set_has_onshow();
  if (onshow_ == &::google::protobuf::internal::kEmptyString) {
    onshow_ = new ::std::string;
  }
  onshow_->assign(value);
}
inline void Button::set_onshow(const char* value) {
  set_has_onshow();
  if (onshow_ == &::google::protobuf::internal::kEmptyString) {
    onshow_ = new ::std::string;
  }
  onshow_->assign(value);
}
inline void Button::set_onshow(const char* value, size_t size) {
  set_has_onshow();
  if (onshow_ == &::google::protobuf::internal::kEmptyString) {
    onshow_ = new ::std::string;
  }
  onshow_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Button::mutable_onshow() {
  set_has_onshow();
  if (onshow_ == &::google::protobuf::internal::kEmptyString) {
    onshow_ = new ::std::string;
  }
  return onshow_;
}
inline ::std::string* Button::release_onshow() {
  clear_has_onshow();
  if (onshow_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = onshow_;
    onshow_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Button::set_allocated_onshow(::std::string* onshow) {
  if (onshow_ != &::google::protobuf::internal::kEmptyString) {
    delete onshow_;
  }
  if (onshow) {
    set_has_onshow();
    onshow_ = onshow;
  } else {
    clear_has_onshow();
    onshow_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string OnHide = 18;
inline bool Button::has_onhide() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Button::set_has_onhide() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Button::clear_has_onhide() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Button::clear_onhide() {
  if (onhide_ != &::google::protobuf::internal::kEmptyString) {
    onhide_->clear();
  }
  clear_has_onhide();
}
inline const ::std::string& Button::onhide() const {
  return *onhide_;
}
inline void Button::set_onhide(const ::std::string& value) {
  set_has_onhide();
  if (onhide_ == &::google::protobuf::internal::kEmptyString) {
    onhide_ = new ::std::string;
  }
  onhide_->assign(value);
}
inline void Button::set_onhide(const char* value) {
  set_has_onhide();
  if (onhide_ == &::google::protobuf::internal::kEmptyString) {
    onhide_ = new ::std::string;
  }
  onhide_->assign(value);
}
inline void Button::set_onhide(const char* value, size_t size) {
  set_has_onhide();
  if (onhide_ == &::google::protobuf::internal::kEmptyString) {
    onhide_ = new ::std::string;
  }
  onhide_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Button::mutable_onhide() {
  set_has_onhide();
  if (onhide_ == &::google::protobuf::internal::kEmptyString) {
    onhide_ = new ::std::string;
  }
  return onhide_;
}
inline ::std::string* Button::release_onhide() {
  clear_has_onhide();
  if (onhide_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = onhide_;
    onhide_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Button::set_allocated_onhide(::std::string* onhide) {
  if (onhide_ != &::google::protobuf::internal::kEmptyString) {
    delete onhide_;
  }
  if (onhide) {
    set_has_onhide();
    onhide_ = onhide;
  } else {
    clear_has_onhide();
    onhide_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string OnClosed = 19;
inline bool Button::has_onclosed() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Button::set_has_onclosed() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Button::clear_has_onclosed() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Button::clear_onclosed() {
  if (onclosed_ != &::google::protobuf::internal::kEmptyString) {
    onclosed_->clear();
  }
  clear_has_onclosed();
}
inline const ::std::string& Button::onclosed() const {
  return *onclosed_;
}
inline void Button::set_onclosed(const ::std::string& value) {
  set_has_onclosed();
  if (onclosed_ == &::google::protobuf::internal::kEmptyString) {
    onclosed_ = new ::std::string;
  }
  onclosed_->assign(value);
}
inline void Button::set_onclosed(const char* value) {
  set_has_onclosed();
  if (onclosed_ == &::google::protobuf::internal::kEmptyString) {
    onclosed_ = new ::std::string;
  }
  onclosed_->assign(value);
}
inline void Button::set_onclosed(const char* value, size_t size) {
  set_has_onclosed();
  if (onclosed_ == &::google::protobuf::internal::kEmptyString) {
    onclosed_ = new ::std::string;
  }
  onclosed_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Button::mutable_onclosed() {
  set_has_onclosed();
  if (onclosed_ == &::google::protobuf::internal::kEmptyString) {
    onclosed_ = new ::std::string;
  }
  return onclosed_;
}
inline ::std::string* Button::release_onclosed() {
  clear_has_onclosed();
  if (onclosed_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = onclosed_;
    onclosed_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Button::set_allocated_onclosed(::std::string* onclosed) {
  if (onclosed_ != &::google::protobuf::internal::kEmptyString) {
    delete onclosed_;
  }
  if (onclosed) {
    set_has_onclosed();
    onclosed_ = onclosed;
  } else {
    clear_has_onclosed();
    onclosed_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string OnUpdate = 20;
inline bool Button::has_onupdate() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void Button::set_has_onupdate() {
  _has_bits_[0] |= 0x00080000u;
}
inline void Button::clear_has_onupdate() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void Button::clear_onupdate() {
  if (onupdate_ != &::google::protobuf::internal::kEmptyString) {
    onupdate_->clear();
  }
  clear_has_onupdate();
}
inline const ::std::string& Button::onupdate() const {
  return *onupdate_;
}
inline void Button::set_onupdate(const ::std::string& value) {
  set_has_onupdate();
  if (onupdate_ == &::google::protobuf::internal::kEmptyString) {
    onupdate_ = new ::std::string;
  }
  onupdate_->assign(value);
}
inline void Button::set_onupdate(const char* value) {
  set_has_onupdate();
  if (onupdate_ == &::google::protobuf::internal::kEmptyString) {
    onupdate_ = new ::std::string;
  }
  onupdate_->assign(value);
}
inline void Button::set_onupdate(const char* value, size_t size) {
  set_has_onupdate();
  if (onupdate_ == &::google::protobuf::internal::kEmptyString) {
    onupdate_ = new ::std::string;
  }
  onupdate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Button::mutable_onupdate() {
  set_has_onupdate();
  if (onupdate_ == &::google::protobuf::internal::kEmptyString) {
    onupdate_ = new ::std::string;
  }
  return onupdate_;
}
inline ::std::string* Button::release_onupdate() {
  clear_has_onupdate();
  if (onupdate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = onupdate_;
    onupdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Button::set_allocated_onupdate(::std::string* onupdate) {
  if (onupdate_ != &::google::protobuf::internal::kEmptyString) {
    delete onupdate_;
  }
  if (onupdate) {
    set_has_onupdate();
    onupdate_ = onupdate;
  } else {
    clear_has_onupdate();
    onupdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string OnTouchBegan = 21;
inline bool Button::has_ontouchbegan() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void Button::set_has_ontouchbegan() {
  _has_bits_[0] |= 0x00100000u;
}
inline void Button::clear_has_ontouchbegan() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void Button::clear_ontouchbegan() {
  if (ontouchbegan_ != &::google::protobuf::internal::kEmptyString) {
    ontouchbegan_->clear();
  }
  clear_has_ontouchbegan();
}
inline const ::std::string& Button::ontouchbegan() const {
  return *ontouchbegan_;
}
inline void Button::set_ontouchbegan(const ::std::string& value) {
  set_has_ontouchbegan();
  if (ontouchbegan_ == &::google::protobuf::internal::kEmptyString) {
    ontouchbegan_ = new ::std::string;
  }
  ontouchbegan_->assign(value);
}
inline void Button::set_ontouchbegan(const char* value) {
  set_has_ontouchbegan();
  if (ontouchbegan_ == &::google::protobuf::internal::kEmptyString) {
    ontouchbegan_ = new ::std::string;
  }
  ontouchbegan_->assign(value);
}
inline void Button::set_ontouchbegan(const char* value, size_t size) {
  set_has_ontouchbegan();
  if (ontouchbegan_ == &::google::protobuf::internal::kEmptyString) {
    ontouchbegan_ = new ::std::string;
  }
  ontouchbegan_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Button::mutable_ontouchbegan() {
  set_has_ontouchbegan();
  if (ontouchbegan_ == &::google::protobuf::internal::kEmptyString) {
    ontouchbegan_ = new ::std::string;
  }
  return ontouchbegan_;
}
inline ::std::string* Button::release_ontouchbegan() {
  clear_has_ontouchbegan();
  if (ontouchbegan_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ontouchbegan_;
    ontouchbegan_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Button::set_allocated_ontouchbegan(::std::string* ontouchbegan) {
  if (ontouchbegan_ != &::google::protobuf::internal::kEmptyString) {
    delete ontouchbegan_;
  }
  if (ontouchbegan) {
    set_has_ontouchbegan();
    ontouchbegan_ = ontouchbegan;
  } else {
    clear_has_ontouchbegan();
    ontouchbegan_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string OnTouchMoved = 22;
inline bool Button::has_ontouchmoved() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void Button::set_has_ontouchmoved() {
  _has_bits_[0] |= 0x00200000u;
}
inline void Button::clear_has_ontouchmoved() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void Button::clear_ontouchmoved() {
  if (ontouchmoved_ != &::google::protobuf::internal::kEmptyString) {
    ontouchmoved_->clear();
  }
  clear_has_ontouchmoved();
}
inline const ::std::string& Button::ontouchmoved() const {
  return *ontouchmoved_;
}
inline void Button::set_ontouchmoved(const ::std::string& value) {
  set_has_ontouchmoved();
  if (ontouchmoved_ == &::google::protobuf::internal::kEmptyString) {
    ontouchmoved_ = new ::std::string;
  }
  ontouchmoved_->assign(value);
}
inline void Button::set_ontouchmoved(const char* value) {
  set_has_ontouchmoved();
  if (ontouchmoved_ == &::google::protobuf::internal::kEmptyString) {
    ontouchmoved_ = new ::std::string;
  }
  ontouchmoved_->assign(value);
}
inline void Button::set_ontouchmoved(const char* value, size_t size) {
  set_has_ontouchmoved();
  if (ontouchmoved_ == &::google::protobuf::internal::kEmptyString) {
    ontouchmoved_ = new ::std::string;
  }
  ontouchmoved_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Button::mutable_ontouchmoved() {
  set_has_ontouchmoved();
  if (ontouchmoved_ == &::google::protobuf::internal::kEmptyString) {
    ontouchmoved_ = new ::std::string;
  }
  return ontouchmoved_;
}
inline ::std::string* Button::release_ontouchmoved() {
  clear_has_ontouchmoved();
  if (ontouchmoved_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ontouchmoved_;
    ontouchmoved_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Button::set_allocated_ontouchmoved(::std::string* ontouchmoved) {
  if (ontouchmoved_ != &::google::protobuf::internal::kEmptyString) {
    delete ontouchmoved_;
  }
  if (ontouchmoved) {
    set_has_ontouchmoved();
    ontouchmoved_ = ontouchmoved;
  } else {
    clear_has_ontouchmoved();
    ontouchmoved_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string OnTouchEnd = 23;
inline bool Button::has_ontouchend() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void Button::set_has_ontouchend() {
  _has_bits_[0] |= 0x00400000u;
}
inline void Button::clear_has_ontouchend() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void Button::clear_ontouchend() {
  if (ontouchend_ != &::google::protobuf::internal::kEmptyString) {
    ontouchend_->clear();
  }
  clear_has_ontouchend();
}
inline const ::std::string& Button::ontouchend() const {
  return *ontouchend_;
}
inline void Button::set_ontouchend(const ::std::string& value) {
  set_has_ontouchend();
  if (ontouchend_ == &::google::protobuf::internal::kEmptyString) {
    ontouchend_ = new ::std::string;
  }
  ontouchend_->assign(value);
}
inline void Button::set_ontouchend(const char* value) {
  set_has_ontouchend();
  if (ontouchend_ == &::google::protobuf::internal::kEmptyString) {
    ontouchend_ = new ::std::string;
  }
  ontouchend_->assign(value);
}
inline void Button::set_ontouchend(const char* value, size_t size) {
  set_has_ontouchend();
  if (ontouchend_ == &::google::protobuf::internal::kEmptyString) {
    ontouchend_ = new ::std::string;
  }
  ontouchend_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Button::mutable_ontouchend() {
  set_has_ontouchend();
  if (ontouchend_ == &::google::protobuf::internal::kEmptyString) {
    ontouchend_ = new ::std::string;
  }
  return ontouchend_;
}
inline ::std::string* Button::release_ontouchend() {
  clear_has_ontouchend();
  if (ontouchend_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ontouchend_;
    ontouchend_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Button::set_allocated_ontouchend(::std::string* ontouchend) {
  if (ontouchend_ != &::google::protobuf::internal::kEmptyString) {
    delete ontouchend_;
  }
  if (ontouchend) {
    set_has_ontouchend();
    ontouchend_ = ontouchend;
  } else {
    clear_has_ontouchend();
    ontouchend_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string OnClick = 24;
inline bool Button::has_onclick() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void Button::set_has_onclick() {
  _has_bits_[0] |= 0x00800000u;
}
inline void Button::clear_has_onclick() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void Button::clear_onclick() {
  if (onclick_ != &::google::protobuf::internal::kEmptyString) {
    onclick_->clear();
  }
  clear_has_onclick();
}
inline const ::std::string& Button::onclick() const {
  return *onclick_;
}
inline void Button::set_onclick(const ::std::string& value) {
  set_has_onclick();
  if (onclick_ == &::google::protobuf::internal::kEmptyString) {
    onclick_ = new ::std::string;
  }
  onclick_->assign(value);
}
inline void Button::set_onclick(const char* value) {
  set_has_onclick();
  if (onclick_ == &::google::protobuf::internal::kEmptyString) {
    onclick_ = new ::std::string;
  }
  onclick_->assign(value);
}
inline void Button::set_onclick(const char* value, size_t size) {
  set_has_onclick();
  if (onclick_ == &::google::protobuf::internal::kEmptyString) {
    onclick_ = new ::std::string;
  }
  onclick_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Button::mutable_onclick() {
  set_has_onclick();
  if (onclick_ == &::google::protobuf::internal::kEmptyString) {
    onclick_ = new ::std::string;
  }
  return onclick_;
}
inline ::std::string* Button::release_onclick() {
  clear_has_onclick();
  if (onclick_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = onclick_;
    onclick_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Button::set_allocated_onclick(::std::string* onclick) {
  if (onclick_ != &::google::protobuf::internal::kEmptyString) {
    delete onclick_;
  }
  if (onclick) {
    set_has_onclick();
    onclick_ = onclick;
  } else {
    clear_has_onclick();
    onclick_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string OnEvent = 25;
inline bool Button::has_onevent() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void Button::set_has_onevent() {
  _has_bits_[0] |= 0x01000000u;
}
inline void Button::clear_has_onevent() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void Button::clear_onevent() {
  if (onevent_ != &::google::protobuf::internal::kEmptyString) {
    onevent_->clear();
  }
  clear_has_onevent();
}
inline const ::std::string& Button::onevent() const {
  return *onevent_;
}
inline void Button::set_onevent(const ::std::string& value) {
  set_has_onevent();
  if (onevent_ == &::google::protobuf::internal::kEmptyString) {
    onevent_ = new ::std::string;
  }
  onevent_->assign(value);
}
inline void Button::set_onevent(const char* value) {
  set_has_onevent();
  if (onevent_ == &::google::protobuf::internal::kEmptyString) {
    onevent_ = new ::std::string;
  }
  onevent_->assign(value);
}
inline void Button::set_onevent(const char* value, size_t size) {
  set_has_onevent();
  if (onevent_ == &::google::protobuf::internal::kEmptyString) {
    onevent_ = new ::std::string;
  }
  onevent_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Button::mutable_onevent() {
  set_has_onevent();
  if (onevent_ == &::google::protobuf::internal::kEmptyString) {
    onevent_ = new ::std::string;
  }
  return onevent_;
}
inline ::std::string* Button::release_onevent() {
  clear_has_onevent();
  if (onevent_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = onevent_;
    onevent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Button::set_allocated_onevent(::std::string* onevent) {
  if (onevent_ != &::google::protobuf::internal::kEmptyString) {
    delete onevent_;
  }
  if (onevent) {
    set_has_onevent();
    onevent_ = onevent;
  } else {
    clear_has_onevent();
    onevent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .Medusa.CoreProto.RectF ScissorBox = 26;
inline bool Button::has_scissorbox() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void Button::set_has_scissorbox() {
  _has_bits_[0] |= 0x02000000u;
}
inline void Button::clear_has_scissorbox() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void Button::clear_scissorbox() {
  if (scissorbox_ != NULL) scissorbox_->::Medusa::CoreProto::RectF::Clear();
  clear_has_scissorbox();
}
inline const ::Medusa::CoreProto::RectF& Button::scissorbox() const {
  return scissorbox_ != NULL ? *scissorbox_ : *default_instance_->scissorbox_;
}
inline ::Medusa::CoreProto::RectF* Button::mutable_scissorbox() {
  set_has_scissorbox();
  if (scissorbox_ == NULL) scissorbox_ = new ::Medusa::CoreProto::RectF;
  return scissorbox_;
}
inline ::Medusa::CoreProto::RectF* Button::release_scissorbox() {
  clear_has_scissorbox();
  ::Medusa::CoreProto::RectF* temp = scissorbox_;
  scissorbox_ = NULL;
  return temp;
}
inline void Button::set_allocated_scissorbox(::Medusa::CoreProto::RectF* scissorbox) {
  delete scissorbox_;
  scissorbox_ = scissorbox;
  if (scissorbox) {
    set_has_scissorbox();
  } else {
    clear_has_scissorbox();
  }
}

// optional int32 RenderFlag = 50;
inline bool Button::has_renderflag() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void Button::set_has_renderflag() {
  _has_bits_[0] |= 0x04000000u;
}
inline void Button::clear_has_renderflag() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void Button::clear_renderflag() {
  renderflag_ = 0;
  clear_has_renderflag();
}
inline ::google::protobuf::int32 Button::renderflag() const {
  return renderflag_;
}
inline void Button::set_renderflag(::google::protobuf::int32 value) {
  set_has_renderflag();
  renderflag_ = value;
}

// optional int32 Tag = 51;
inline bool Button::has_tag() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void Button::set_has_tag() {
  _has_bits_[0] |= 0x08000000u;
}
inline void Button::clear_has_tag() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void Button::clear_tag() {
  tag_ = 0;
  clear_has_tag();
}
inline ::google::protobuf::int32 Button::tag() const {
  return tag_;
}
inline void Button::set_tag(::google::protobuf::int32 value) {
  set_has_tag();
  tag_ = value;
}

// optional string ClickEffect = 101;
inline bool Button::has_clickeffect() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void Button::set_has_clickeffect() {
  _has_bits_[0] |= 0x10000000u;
}
inline void Button::clear_has_clickeffect() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void Button::clear_clickeffect() {
  if (clickeffect_ != &::google::protobuf::internal::kEmptyString) {
    clickeffect_->clear();
  }
  clear_has_clickeffect();
}
inline const ::std::string& Button::clickeffect() const {
  return *clickeffect_;
}
inline void Button::set_clickeffect(const ::std::string& value) {
  set_has_clickeffect();
  if (clickeffect_ == &::google::protobuf::internal::kEmptyString) {
    clickeffect_ = new ::std::string;
  }
  clickeffect_->assign(value);
}
inline void Button::set_clickeffect(const char* value) {
  set_has_clickeffect();
  if (clickeffect_ == &::google::protobuf::internal::kEmptyString) {
    clickeffect_ = new ::std::string;
  }
  clickeffect_->assign(value);
}
inline void Button::set_clickeffect(const char* value, size_t size) {
  set_has_clickeffect();
  if (clickeffect_ == &::google::protobuf::internal::kEmptyString) {
    clickeffect_ = new ::std::string;
  }
  clickeffect_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Button::mutable_clickeffect() {
  set_has_clickeffect();
  if (clickeffect_ == &::google::protobuf::internal::kEmptyString) {
    clickeffect_ = new ::std::string;
  }
  return clickeffect_;
}
inline ::std::string* Button::release_clickeffect() {
  clear_has_clickeffect();
  if (clickeffect_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = clickeffect_;
    clickeffect_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Button::set_allocated_clickeffect(::std::string* clickeffect) {
  if (clickeffect_ != &::google::protobuf::internal::kEmptyString) {
    delete clickeffect_;
  }
  if (clickeffect) {
    set_has_clickeffect();
    clickeffect_ = clickeffect;
  } else {
    clear_has_clickeffect();
    clickeffect_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool IsLock = 201;
inline bool Button::has_islock() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void Button::set_has_islock() {
  _has_bits_[0] |= 0x20000000u;
}
inline void Button::clear_has_islock() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void Button::clear_islock() {
  islock_ = false;
  clear_has_islock();
}
inline bool Button::islock() const {
  return islock_;
}
inline void Button::set_islock(bool value) {
  set_has_islock();
  islock_ = value;
}

// optional bool IsHide = 202;
inline bool Button::has_ishide() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void Button::set_has_ishide() {
  _has_bits_[0] |= 0x40000000u;
}
inline void Button::clear_has_ishide() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void Button::clear_ishide() {
  ishide_ = false;
  clear_has_ishide();
}
inline bool Button::ishide() const {
  return ishide_;
}
inline void Button::set_ishide(bool value) {
  set_has_ishide();
  ishide_ = value;
}

// -------------------------------------------------------------------

// Frame

// required string ID = 1;
inline bool Frame::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Frame::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Frame::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Frame::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& Frame::id() const {
  return *id_;
}
inline void Frame::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void Frame::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void Frame::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Frame::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* Frame::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Frame::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .Medusa.CoreProto.SizeU Size = 2;
inline bool Frame::has_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Frame::set_has_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Frame::clear_has_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Frame::clear_size() {
  if (size_ != NULL) size_->::Medusa::CoreProto::SizeU::Clear();
  clear_has_size();
}
inline const ::Medusa::CoreProto::SizeU& Frame::size() const {
  return size_ != NULL ? *size_ : *default_instance_->size_;
}
inline ::Medusa::CoreProto::SizeU* Frame::mutable_size() {
  set_has_size();
  if (size_ == NULL) size_ = new ::Medusa::CoreProto::SizeU;
  return size_;
}
inline ::Medusa::CoreProto::SizeU* Frame::release_size() {
  clear_has_size();
  ::Medusa::CoreProto::SizeU* temp = size_;
  size_ = NULL;
  return temp;
}
inline void Frame::set_allocated_size(::Medusa::CoreProto::SizeU* size) {
  delete size_;
  size_ = size;
  if (size) {
    set_has_size();
  } else {
    clear_has_size();
  }
}

// required .Medusa.CoreProto.PointF Position = 3;
inline bool Frame::has_position() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Frame::set_has_position() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Frame::clear_has_position() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Frame::clear_position() {
  if (position_ != NULL) position_->::Medusa::CoreProto::PointF::Clear();
  clear_has_position();
}
inline const ::Medusa::CoreProto::PointF& Frame::position() const {
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::Medusa::CoreProto::PointF* Frame::mutable_position() {
  set_has_position();
  if (position_ == NULL) position_ = new ::Medusa::CoreProto::PointF;
  return position_;
}
inline ::Medusa::CoreProto::PointF* Frame::release_position() {
  clear_has_position();
  ::Medusa::CoreProto::PointF* temp = position_;
  position_ = NULL;
  return temp;
}
inline void Frame::set_allocated_position(::Medusa::CoreProto::PointF* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
}

// required bool IsProportionPoint = 4;
inline bool Frame::has_isproportionpoint() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Frame::set_has_isproportionpoint() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Frame::clear_has_isproportionpoint() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Frame::clear_isproportionpoint() {
  isproportionpoint_ = false;
  clear_has_isproportionpoint();
}
inline bool Frame::isproportionpoint() const {
  return isproportionpoint_;
}
inline void Frame::set_isproportionpoint(bool value) {
  set_has_isproportionpoint();
  isproportionpoint_ = value;
}

// required .Medusa.CoreProto.PointF Anchor = 5;
inline bool Frame::has_anchor() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Frame::set_has_anchor() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Frame::clear_has_anchor() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Frame::clear_anchor() {
  if (anchor_ != NULL) anchor_->::Medusa::CoreProto::PointF::Clear();
  clear_has_anchor();
}
inline const ::Medusa::CoreProto::PointF& Frame::anchor() const {
  return anchor_ != NULL ? *anchor_ : *default_instance_->anchor_;
}
inline ::Medusa::CoreProto::PointF* Frame::mutable_anchor() {
  set_has_anchor();
  if (anchor_ == NULL) anchor_ = new ::Medusa::CoreProto::PointF;
  return anchor_;
}
inline ::Medusa::CoreProto::PointF* Frame::release_anchor() {
  clear_has_anchor();
  ::Medusa::CoreProto::PointF* temp = anchor_;
  anchor_ = NULL;
  return temp;
}
inline void Frame::set_allocated_anchor(::Medusa::CoreProto::PointF* anchor) {
  delete anchor_;
  anchor_ = anchor;
  if (anchor) {
    set_has_anchor();
  } else {
    clear_has_anchor();
  }
}

// required int32 ZOrder = 6;
inline bool Frame::has_zorder() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Frame::set_has_zorder() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Frame::clear_has_zorder() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Frame::clear_zorder() {
  zorder_ = 0;
  clear_has_zorder();
}
inline ::google::protobuf::int32 Frame::zorder() const {
  return zorder_;
}
inline void Frame::set_zorder(::google::protobuf::int32 value) {
  set_has_zorder();
  zorder_ = value;
}

// optional float Rotation = 7;
inline bool Frame::has_rotation() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Frame::set_has_rotation() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Frame::clear_has_rotation() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Frame::clear_rotation() {
  rotation_ = 0;
  clear_has_rotation();
}
inline float Frame::rotation() const {
  return rotation_;
}
inline void Frame::set_rotation(float value) {
  set_has_rotation();
  rotation_ = value;
}

// optional .Medusa.CoreProto.ScaleF Scale = 8;
inline bool Frame::has_scale() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Frame::set_has_scale() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Frame::clear_has_scale() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Frame::clear_scale() {
  if (scale_ != NULL) scale_->::Medusa::CoreProto::ScaleF::Clear();
  clear_has_scale();
}
inline const ::Medusa::CoreProto::ScaleF& Frame::scale() const {
  return scale_ != NULL ? *scale_ : *default_instance_->scale_;
}
inline ::Medusa::CoreProto::ScaleF* Frame::mutable_scale() {
  set_has_scale();
  if (scale_ == NULL) scale_ = new ::Medusa::CoreProto::ScaleF;
  return scale_;
}
inline ::Medusa::CoreProto::ScaleF* Frame::release_scale() {
  clear_has_scale();
  ::Medusa::CoreProto::ScaleF* temp = scale_;
  scale_ = NULL;
  return temp;
}
inline void Frame::set_allocated_scale(::Medusa::CoreProto::ScaleF* scale) {
  delete scale_;
  scale_ = scale;
  if (scale) {
    set_has_scale();
  } else {
    clear_has_scale();
  }
}

// optional bool IsFilpX = 9;
inline bool Frame::has_isfilpx() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Frame::set_has_isfilpx() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Frame::clear_has_isfilpx() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Frame::clear_isfilpx() {
  isfilpx_ = false;
  clear_has_isfilpx();
}
inline bool Frame::isfilpx() const {
  return isfilpx_;
}
inline void Frame::set_isfilpx(bool value) {
  set_has_isfilpx();
  isfilpx_ = value;
}

// optional bool IsFilpY = 10;
inline bool Frame::has_isfilpy() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Frame::set_has_isfilpy() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Frame::clear_has_isfilpy() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Frame::clear_isfilpy() {
  isfilpy_ = false;
  clear_has_isfilpy();
}
inline bool Frame::isfilpy() const {
  return isfilpy_;
}
inline void Frame::set_isfilpy(bool value) {
  set_has_isfilpy();
  isfilpy_ = value;
}

// optional float Parallax = 11;
inline bool Frame::has_parallax() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Frame::set_has_parallax() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Frame::clear_has_parallax() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Frame::clear_parallax() {
  parallax_ = 0;
  clear_has_parallax();
}
inline float Frame::parallax() const {
  return parallax_;
}
inline void Frame::set_parallax(float value) {
  set_has_parallax();
  parallax_ = value;
}

// optional int32 UserValue = 20;
inline bool Frame::has_uservalue() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Frame::set_has_uservalue() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Frame::clear_has_uservalue() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Frame::clear_uservalue() {
  uservalue_ = 0;
  clear_has_uservalue();
}
inline ::google::protobuf::int32 Frame::uservalue() const {
  return uservalue_;
}
inline void Frame::set_uservalue(::google::protobuf::int32 value) {
  set_has_uservalue();
  uservalue_ = value;
}

// optional string UserString = 21;
inline bool Frame::has_userstring() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Frame::set_has_userstring() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Frame::clear_has_userstring() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Frame::clear_userstring() {
  if (userstring_ != &::google::protobuf::internal::kEmptyString) {
    userstring_->clear();
  }
  clear_has_userstring();
}
inline const ::std::string& Frame::userstring() const {
  return *userstring_;
}
inline void Frame::set_userstring(const ::std::string& value) {
  set_has_userstring();
  if (userstring_ == &::google::protobuf::internal::kEmptyString) {
    userstring_ = new ::std::string;
  }
  userstring_->assign(value);
}
inline void Frame::set_userstring(const char* value) {
  set_has_userstring();
  if (userstring_ == &::google::protobuf::internal::kEmptyString) {
    userstring_ = new ::std::string;
  }
  userstring_->assign(value);
}
inline void Frame::set_userstring(const char* value, size_t size) {
  set_has_userstring();
  if (userstring_ == &::google::protobuf::internal::kEmptyString) {
    userstring_ = new ::std::string;
  }
  userstring_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Frame::mutable_userstring() {
  set_has_userstring();
  if (userstring_ == &::google::protobuf::internal::kEmptyString) {
    userstring_ = new ::std::string;
  }
  return userstring_;
}
inline ::std::string* Frame::release_userstring() {
  clear_has_userstring();
  if (userstring_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = userstring_;
    userstring_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Frame::set_allocated_userstring(::std::string* userstring) {
  if (userstring_ != &::google::protobuf::internal::kEmptyString) {
    delete userstring_;
  }
  if (userstring) {
    set_has_userstring();
    userstring_ = userstring;
  } else {
    clear_has_userstring();
    userstring_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .Medusa.CoreProto.RectF ScissorBox = 22;
inline bool Frame::has_scissorbox() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Frame::set_has_scissorbox() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Frame::clear_has_scissorbox() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Frame::clear_scissorbox() {
  if (scissorbox_ != NULL) scissorbox_->::Medusa::CoreProto::RectF::Clear();
  clear_has_scissorbox();
}
inline const ::Medusa::CoreProto::RectF& Frame::scissorbox() const {
  return scissorbox_ != NULL ? *scissorbox_ : *default_instance_->scissorbox_;
}
inline ::Medusa::CoreProto::RectF* Frame::mutable_scissorbox() {
  set_has_scissorbox();
  if (scissorbox_ == NULL) scissorbox_ = new ::Medusa::CoreProto::RectF;
  return scissorbox_;
}
inline ::Medusa::CoreProto::RectF* Frame::release_scissorbox() {
  clear_has_scissorbox();
  ::Medusa::CoreProto::RectF* temp = scissorbox_;
  scissorbox_ = NULL;
  return temp;
}
inline void Frame::set_allocated_scissorbox(::Medusa::CoreProto::RectF* scissorbox) {
  delete scissorbox_;
  scissorbox_ = scissorbox;
  if (scissorbox) {
    set_has_scissorbox();
  } else {
    clear_has_scissorbox();
  }
}

// optional int32 RenderFlag = 50;
inline bool Frame::has_renderflag() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Frame::set_has_renderflag() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Frame::clear_has_renderflag() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Frame::clear_renderflag() {
  renderflag_ = 0;
  clear_has_renderflag();
}
inline ::google::protobuf::int32 Frame::renderflag() const {
  return renderflag_;
}
inline void Frame::set_renderflag(::google::protobuf::int32 value) {
  set_has_renderflag();
  renderflag_ = value;
}

// optional int32 Tag = 51;
inline bool Frame::has_tag() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Frame::set_has_tag() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Frame::clear_has_tag() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Frame::clear_tag() {
  tag_ = 0;
  clear_has_tag();
}
inline ::google::protobuf::int32 Frame::tag() const {
  return tag_;
}
inline void Frame::set_tag(::google::protobuf::int32 value) {
  set_has_tag();
  tag_ = value;
}

// optional string ClickEffect = 101;
inline bool Frame::has_clickeffect() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Frame::set_has_clickeffect() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Frame::clear_has_clickeffect() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Frame::clear_clickeffect() {
  if (clickeffect_ != &::google::protobuf::internal::kEmptyString) {
    clickeffect_->clear();
  }
  clear_has_clickeffect();
}
inline const ::std::string& Frame::clickeffect() const {
  return *clickeffect_;
}
inline void Frame::set_clickeffect(const ::std::string& value) {
  set_has_clickeffect();
  if (clickeffect_ == &::google::protobuf::internal::kEmptyString) {
    clickeffect_ = new ::std::string;
  }
  clickeffect_->assign(value);
}
inline void Frame::set_clickeffect(const char* value) {
  set_has_clickeffect();
  if (clickeffect_ == &::google::protobuf::internal::kEmptyString) {
    clickeffect_ = new ::std::string;
  }
  clickeffect_->assign(value);
}
inline void Frame::set_clickeffect(const char* value, size_t size) {
  set_has_clickeffect();
  if (clickeffect_ == &::google::protobuf::internal::kEmptyString) {
    clickeffect_ = new ::std::string;
  }
  clickeffect_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Frame::mutable_clickeffect() {
  set_has_clickeffect();
  if (clickeffect_ == &::google::protobuf::internal::kEmptyString) {
    clickeffect_ = new ::std::string;
  }
  return clickeffect_;
}
inline ::std::string* Frame::release_clickeffect() {
  clear_has_clickeffect();
  if (clickeffect_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = clickeffect_;
    clickeffect_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Frame::set_allocated_clickeffect(::std::string* clickeffect) {
  if (clickeffect_ != &::google::protobuf::internal::kEmptyString) {
    delete clickeffect_;
  }
  if (clickeffect) {
    set_has_clickeffect();
    clickeffect_ = clickeffect;
  } else {
    clear_has_clickeffect();
    clickeffect_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool IsLock = 201;
inline bool Frame::has_islock() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Frame::set_has_islock() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Frame::clear_has_islock() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Frame::clear_islock() {
  islock_ = false;
  clear_has_islock();
}
inline bool Frame::islock() const {
  return islock_;
}
inline void Frame::set_islock(bool value) {
  set_has_islock();
  islock_ = value;
}

// optional bool IsHide = 202;
inline bool Frame::has_ishide() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Frame::set_has_ishide() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Frame::clear_has_ishide() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Frame::clear_ishide() {
  ishide_ = false;
  clear_has_ishide();
}
inline bool Frame::ishide() const {
  return ishide_;
}
inline void Frame::set_ishide(bool value) {
  set_has_ishide();
  ishide_ = value;
}

// -------------------------------------------------------------------

// Label

// required string ID = 1;
inline bool Label::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Label::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Label::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Label::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& Label::id() const {
  return *id_;
}
inline void Label::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void Label::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void Label::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Label::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* Label::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Label::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .Medusa.CoreProto.SizeU Size = 2;
inline bool Label::has_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Label::set_has_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Label::clear_has_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Label::clear_size() {
  if (size_ != NULL) size_->::Medusa::CoreProto::SizeU::Clear();
  clear_has_size();
}
inline const ::Medusa::CoreProto::SizeU& Label::size() const {
  return size_ != NULL ? *size_ : *default_instance_->size_;
}
inline ::Medusa::CoreProto::SizeU* Label::mutable_size() {
  set_has_size();
  if (size_ == NULL) size_ = new ::Medusa::CoreProto::SizeU;
  return size_;
}
inline ::Medusa::CoreProto::SizeU* Label::release_size() {
  clear_has_size();
  ::Medusa::CoreProto::SizeU* temp = size_;
  size_ = NULL;
  return temp;
}
inline void Label::set_allocated_size(::Medusa::CoreProto::SizeU* size) {
  delete size_;
  size_ = size;
  if (size) {
    set_has_size();
  } else {
    clear_has_size();
  }
}

// required .Medusa.CoreProto.PointF Position = 3;
inline bool Label::has_position() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Label::set_has_position() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Label::clear_has_position() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Label::clear_position() {
  if (position_ != NULL) position_->::Medusa::CoreProto::PointF::Clear();
  clear_has_position();
}
inline const ::Medusa::CoreProto::PointF& Label::position() const {
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::Medusa::CoreProto::PointF* Label::mutable_position() {
  set_has_position();
  if (position_ == NULL) position_ = new ::Medusa::CoreProto::PointF;
  return position_;
}
inline ::Medusa::CoreProto::PointF* Label::release_position() {
  clear_has_position();
  ::Medusa::CoreProto::PointF* temp = position_;
  position_ = NULL;
  return temp;
}
inline void Label::set_allocated_position(::Medusa::CoreProto::PointF* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
}

// required bool IsProportionPoint = 4;
inline bool Label::has_isproportionpoint() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Label::set_has_isproportionpoint() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Label::clear_has_isproportionpoint() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Label::clear_isproportionpoint() {
  isproportionpoint_ = false;
  clear_has_isproportionpoint();
}
inline bool Label::isproportionpoint() const {
  return isproportionpoint_;
}
inline void Label::set_isproportionpoint(bool value) {
  set_has_isproportionpoint();
  isproportionpoint_ = value;
}

// required .Medusa.CoreProto.PointF Anchor = 5;
inline bool Label::has_anchor() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Label::set_has_anchor() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Label::clear_has_anchor() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Label::clear_anchor() {
  if (anchor_ != NULL) anchor_->::Medusa::CoreProto::PointF::Clear();
  clear_has_anchor();
}
inline const ::Medusa::CoreProto::PointF& Label::anchor() const {
  return anchor_ != NULL ? *anchor_ : *default_instance_->anchor_;
}
inline ::Medusa::CoreProto::PointF* Label::mutable_anchor() {
  set_has_anchor();
  if (anchor_ == NULL) anchor_ = new ::Medusa::CoreProto::PointF;
  return anchor_;
}
inline ::Medusa::CoreProto::PointF* Label::release_anchor() {
  clear_has_anchor();
  ::Medusa::CoreProto::PointF* temp = anchor_;
  anchor_ = NULL;
  return temp;
}
inline void Label::set_allocated_anchor(::Medusa::CoreProto::PointF* anchor) {
  delete anchor_;
  anchor_ = anchor;
  if (anchor) {
    set_has_anchor();
  } else {
    clear_has_anchor();
  }
}

// required int32 ZOrder = 6;
inline bool Label::has_zorder() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Label::set_has_zorder() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Label::clear_has_zorder() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Label::clear_zorder() {
  zorder_ = 0;
  clear_has_zorder();
}
inline ::google::protobuf::int32 Label::zorder() const {
  return zorder_;
}
inline void Label::set_zorder(::google::protobuf::int32 value) {
  set_has_zorder();
  zorder_ = value;
}

// optional float Rotation = 7;
inline bool Label::has_rotation() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Label::set_has_rotation() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Label::clear_has_rotation() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Label::clear_rotation() {
  rotation_ = 0;
  clear_has_rotation();
}
inline float Label::rotation() const {
  return rotation_;
}
inline void Label::set_rotation(float value) {
  set_has_rotation();
  rotation_ = value;
}

// optional .Medusa.CoreProto.ScaleF Scale = 8;
inline bool Label::has_scale() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Label::set_has_scale() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Label::clear_has_scale() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Label::clear_scale() {
  if (scale_ != NULL) scale_->::Medusa::CoreProto::ScaleF::Clear();
  clear_has_scale();
}
inline const ::Medusa::CoreProto::ScaleF& Label::scale() const {
  return scale_ != NULL ? *scale_ : *default_instance_->scale_;
}
inline ::Medusa::CoreProto::ScaleF* Label::mutable_scale() {
  set_has_scale();
  if (scale_ == NULL) scale_ = new ::Medusa::CoreProto::ScaleF;
  return scale_;
}
inline ::Medusa::CoreProto::ScaleF* Label::release_scale() {
  clear_has_scale();
  ::Medusa::CoreProto::ScaleF* temp = scale_;
  scale_ = NULL;
  return temp;
}
inline void Label::set_allocated_scale(::Medusa::CoreProto::ScaleF* scale) {
  delete scale_;
  scale_ = scale;
  if (scale) {
    set_has_scale();
  } else {
    clear_has_scale();
  }
}

// required bool IsVisible = 9;
inline bool Label::has_isvisible() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Label::set_has_isvisible() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Label::clear_has_isvisible() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Label::clear_isvisible() {
  isvisible_ = false;
  clear_has_isvisible();
}
inline bool Label::isvisible() const {
  return isvisible_;
}
inline void Label::set_isvisible(bool value) {
  set_has_isvisible();
  isvisible_ = value;
}

// required .Medusa.CoreProto.FileId FontName = 11;
inline bool Label::has_fontname() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Label::set_has_fontname() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Label::clear_has_fontname() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Label::clear_fontname() {
  if (fontname_ != NULL) fontname_->::Medusa::CoreProto::FileId::Clear();
  clear_has_fontname();
}
inline const ::Medusa::CoreProto::FileId& Label::fontname() const {
  return fontname_ != NULL ? *fontname_ : *default_instance_->fontname_;
}
inline ::Medusa::CoreProto::FileId* Label::mutable_fontname() {
  set_has_fontname();
  if (fontname_ == NULL) fontname_ = new ::Medusa::CoreProto::FileId;
  return fontname_;
}
inline ::Medusa::CoreProto::FileId* Label::release_fontname() {
  clear_has_fontname();
  ::Medusa::CoreProto::FileId* temp = fontname_;
  fontname_ = NULL;
  return temp;
}
inline void Label::set_allocated_fontname(::Medusa::CoreProto::FileId* fontname) {
  delete fontname_;
  fontname_ = fontname;
  if (fontname) {
    set_has_fontname();
  } else {
    clear_has_fontname();
  }
}

// required uint32 FontSize = 12;
inline bool Label::has_fontsize() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Label::set_has_fontsize() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Label::clear_has_fontsize() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Label::clear_fontsize() {
  fontsize_ = 0u;
  clear_has_fontsize();
}
inline ::google::protobuf::uint32 Label::fontsize() const {
  return fontsize_;
}
inline void Label::set_fontsize(::google::protobuf::uint32 value) {
  set_has_fontsize();
  fontsize_ = value;
}

// required string Text = 13;
inline bool Label::has_text() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Label::set_has_text() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Label::clear_has_text() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Label::clear_text() {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& Label::text() const {
  return *text_;
}
inline void Label::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void Label::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void Label::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Label::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  return text_;
}
inline ::std::string* Label::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Label::set_allocated_text(::std::string* text) {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    delete text_;
  }
  if (text) {
    set_has_text();
    text_ = text;
  } else {
    clear_has_text();
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .Medusa.CoreProto.ColorF Color = 14;
inline bool Label::has_color() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Label::set_has_color() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Label::clear_has_color() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Label::clear_color() {
  if (color_ != NULL) color_->::Medusa::CoreProto::ColorF::Clear();
  clear_has_color();
}
inline const ::Medusa::CoreProto::ColorF& Label::color() const {
  return color_ != NULL ? *color_ : *default_instance_->color_;
}
inline ::Medusa::CoreProto::ColorF* Label::mutable_color() {
  set_has_color();
  if (color_ == NULL) color_ = new ::Medusa::CoreProto::ColorF;
  return color_;
}
inline ::Medusa::CoreProto::ColorF* Label::release_color() {
  clear_has_color();
  ::Medusa::CoreProto::ColorF* temp = color_;
  color_ = NULL;
  return temp;
}
inline void Label::set_allocated_color(::Medusa::CoreProto::ColorF* color) {
  delete color_;
  color_ = color;
  if (color) {
    set_has_color();
  } else {
    clear_has_color();
  }
}

// required .Medusa.CoreProto.Editor.TextAlignmentType AlignmentType = 10;
inline bool Label::has_alignmenttype() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Label::set_has_alignmenttype() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Label::clear_has_alignmenttype() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Label::clear_alignmenttype() {
  alignmenttype_ = 1;
  clear_has_alignmenttype();
}
inline ::Medusa::CoreProto::Editor::TextAlignmentType Label::alignmenttype() const {
  return static_cast< ::Medusa::CoreProto::Editor::TextAlignmentType >(alignmenttype_);
}
inline void Label::set_alignmenttype(::Medusa::CoreProto::Editor::TextAlignmentType value) {
  assert(::Medusa::CoreProto::Editor::TextAlignmentType_IsValid(value));
  set_has_alignmenttype();
  alignmenttype_ = value;
}

// optional string OnLoad = 15;
inline bool Label::has_onload() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Label::set_has_onload() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Label::clear_has_onload() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Label::clear_onload() {
  if (onload_ != &::google::protobuf::internal::kEmptyString) {
    onload_->clear();
  }
  clear_has_onload();
}
inline const ::std::string& Label::onload() const {
  return *onload_;
}
inline void Label::set_onload(const ::std::string& value) {
  set_has_onload();
  if (onload_ == &::google::protobuf::internal::kEmptyString) {
    onload_ = new ::std::string;
  }
  onload_->assign(value);
}
inline void Label::set_onload(const char* value) {
  set_has_onload();
  if (onload_ == &::google::protobuf::internal::kEmptyString) {
    onload_ = new ::std::string;
  }
  onload_->assign(value);
}
inline void Label::set_onload(const char* value, size_t size) {
  set_has_onload();
  if (onload_ == &::google::protobuf::internal::kEmptyString) {
    onload_ = new ::std::string;
  }
  onload_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Label::mutable_onload() {
  set_has_onload();
  if (onload_ == &::google::protobuf::internal::kEmptyString) {
    onload_ = new ::std::string;
  }
  return onload_;
}
inline ::std::string* Label::release_onload() {
  clear_has_onload();
  if (onload_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = onload_;
    onload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Label::set_allocated_onload(::std::string* onload) {
  if (onload_ != &::google::protobuf::internal::kEmptyString) {
    delete onload_;
  }
  if (onload) {
    set_has_onload();
    onload_ = onload;
  } else {
    clear_has_onload();
    onload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string OnShow = 16;
inline bool Label::has_onshow() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Label::set_has_onshow() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Label::clear_has_onshow() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Label::clear_onshow() {
  if (onshow_ != &::google::protobuf::internal::kEmptyString) {
    onshow_->clear();
  }
  clear_has_onshow();
}
inline const ::std::string& Label::onshow() const {
  return *onshow_;
}
inline void Label::set_onshow(const ::std::string& value) {
  set_has_onshow();
  if (onshow_ == &::google::protobuf::internal::kEmptyString) {
    onshow_ = new ::std::string;
  }
  onshow_->assign(value);
}
inline void Label::set_onshow(const char* value) {
  set_has_onshow();
  if (onshow_ == &::google::protobuf::internal::kEmptyString) {
    onshow_ = new ::std::string;
  }
  onshow_->assign(value);
}
inline void Label::set_onshow(const char* value, size_t size) {
  set_has_onshow();
  if (onshow_ == &::google::protobuf::internal::kEmptyString) {
    onshow_ = new ::std::string;
  }
  onshow_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Label::mutable_onshow() {
  set_has_onshow();
  if (onshow_ == &::google::protobuf::internal::kEmptyString) {
    onshow_ = new ::std::string;
  }
  return onshow_;
}
inline ::std::string* Label::release_onshow() {
  clear_has_onshow();
  if (onshow_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = onshow_;
    onshow_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Label::set_allocated_onshow(::std::string* onshow) {
  if (onshow_ != &::google::protobuf::internal::kEmptyString) {
    delete onshow_;
  }
  if (onshow) {
    set_has_onshow();
    onshow_ = onshow;
  } else {
    clear_has_onshow();
    onshow_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string OnHide = 17;
inline bool Label::has_onhide() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Label::set_has_onhide() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Label::clear_has_onhide() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Label::clear_onhide() {
  if (onhide_ != &::google::protobuf::internal::kEmptyString) {
    onhide_->clear();
  }
  clear_has_onhide();
}
inline const ::std::string& Label::onhide() const {
  return *onhide_;
}
inline void Label::set_onhide(const ::std::string& value) {
  set_has_onhide();
  if (onhide_ == &::google::protobuf::internal::kEmptyString) {
    onhide_ = new ::std::string;
  }
  onhide_->assign(value);
}
inline void Label::set_onhide(const char* value) {
  set_has_onhide();
  if (onhide_ == &::google::protobuf::internal::kEmptyString) {
    onhide_ = new ::std::string;
  }
  onhide_->assign(value);
}
inline void Label::set_onhide(const char* value, size_t size) {
  set_has_onhide();
  if (onhide_ == &::google::protobuf::internal::kEmptyString) {
    onhide_ = new ::std::string;
  }
  onhide_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Label::mutable_onhide() {
  set_has_onhide();
  if (onhide_ == &::google::protobuf::internal::kEmptyString) {
    onhide_ = new ::std::string;
  }
  return onhide_;
}
inline ::std::string* Label::release_onhide() {
  clear_has_onhide();
  if (onhide_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = onhide_;
    onhide_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Label::set_allocated_onhide(::std::string* onhide) {
  if (onhide_ != &::google::protobuf::internal::kEmptyString) {
    delete onhide_;
  }
  if (onhide) {
    set_has_onhide();
    onhide_ = onhide;
  } else {
    clear_has_onhide();
    onhide_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string OnClosed = 18;
inline bool Label::has_onclosed() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Label::set_has_onclosed() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Label::clear_has_onclosed() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Label::clear_onclosed() {
  if (onclosed_ != &::google::protobuf::internal::kEmptyString) {
    onclosed_->clear();
  }
  clear_has_onclosed();
}
inline const ::std::string& Label::onclosed() const {
  return *onclosed_;
}
inline void Label::set_onclosed(const ::std::string& value) {
  set_has_onclosed();
  if (onclosed_ == &::google::protobuf::internal::kEmptyString) {
    onclosed_ = new ::std::string;
  }
  onclosed_->assign(value);
}
inline void Label::set_onclosed(const char* value) {
  set_has_onclosed();
  if (onclosed_ == &::google::protobuf::internal::kEmptyString) {
    onclosed_ = new ::std::string;
  }
  onclosed_->assign(value);
}
inline void Label::set_onclosed(const char* value, size_t size) {
  set_has_onclosed();
  if (onclosed_ == &::google::protobuf::internal::kEmptyString) {
    onclosed_ = new ::std::string;
  }
  onclosed_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Label::mutable_onclosed() {
  set_has_onclosed();
  if (onclosed_ == &::google::protobuf::internal::kEmptyString) {
    onclosed_ = new ::std::string;
  }
  return onclosed_;
}
inline ::std::string* Label::release_onclosed() {
  clear_has_onclosed();
  if (onclosed_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = onclosed_;
    onclosed_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Label::set_allocated_onclosed(::std::string* onclosed) {
  if (onclosed_ != &::google::protobuf::internal::kEmptyString) {
    delete onclosed_;
  }
  if (onclosed) {
    set_has_onclosed();
    onclosed_ = onclosed;
  } else {
    clear_has_onclosed();
    onclosed_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string OnUpdate = 19;
inline bool Label::has_onupdate() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Label::set_has_onupdate() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Label::clear_has_onupdate() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Label::clear_onupdate() {
  if (onupdate_ != &::google::protobuf::internal::kEmptyString) {
    onupdate_->clear();
  }
  clear_has_onupdate();
}
inline const ::std::string& Label::onupdate() const {
  return *onupdate_;
}
inline void Label::set_onupdate(const ::std::string& value) {
  set_has_onupdate();
  if (onupdate_ == &::google::protobuf::internal::kEmptyString) {
    onupdate_ = new ::std::string;
  }
  onupdate_->assign(value);
}
inline void Label::set_onupdate(const char* value) {
  set_has_onupdate();
  if (onupdate_ == &::google::protobuf::internal::kEmptyString) {
    onupdate_ = new ::std::string;
  }
  onupdate_->assign(value);
}
inline void Label::set_onupdate(const char* value, size_t size) {
  set_has_onupdate();
  if (onupdate_ == &::google::protobuf::internal::kEmptyString) {
    onupdate_ = new ::std::string;
  }
  onupdate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Label::mutable_onupdate() {
  set_has_onupdate();
  if (onupdate_ == &::google::protobuf::internal::kEmptyString) {
    onupdate_ = new ::std::string;
  }
  return onupdate_;
}
inline ::std::string* Label::release_onupdate() {
  clear_has_onupdate();
  if (onupdate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = onupdate_;
    onupdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Label::set_allocated_onupdate(::std::string* onupdate) {
  if (onupdate_ != &::google::protobuf::internal::kEmptyString) {
    delete onupdate_;
  }
  if (onupdate) {
    set_has_onupdate();
    onupdate_ = onupdate;
  } else {
    clear_has_onupdate();
    onupdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string OnEvent = 20;
inline bool Label::has_onevent() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void Label::set_has_onevent() {
  _has_bits_[0] |= 0x00080000u;
}
inline void Label::clear_has_onevent() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void Label::clear_onevent() {
  if (onevent_ != &::google::protobuf::internal::kEmptyString) {
    onevent_->clear();
  }
  clear_has_onevent();
}
inline const ::std::string& Label::onevent() const {
  return *onevent_;
}
inline void Label::set_onevent(const ::std::string& value) {
  set_has_onevent();
  if (onevent_ == &::google::protobuf::internal::kEmptyString) {
    onevent_ = new ::std::string;
  }
  onevent_->assign(value);
}
inline void Label::set_onevent(const char* value) {
  set_has_onevent();
  if (onevent_ == &::google::protobuf::internal::kEmptyString) {
    onevent_ = new ::std::string;
  }
  onevent_->assign(value);
}
inline void Label::set_onevent(const char* value, size_t size) {
  set_has_onevent();
  if (onevent_ == &::google::protobuf::internal::kEmptyString) {
    onevent_ = new ::std::string;
  }
  onevent_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Label::mutable_onevent() {
  set_has_onevent();
  if (onevent_ == &::google::protobuf::internal::kEmptyString) {
    onevent_ = new ::std::string;
  }
  return onevent_;
}
inline ::std::string* Label::release_onevent() {
  clear_has_onevent();
  if (onevent_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = onevent_;
    onevent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Label::set_allocated_onevent(::std::string* onevent) {
  if (onevent_ != &::google::protobuf::internal::kEmptyString) {
    delete onevent_;
  }
  if (onevent) {
    set_has_onevent();
    onevent_ = onevent;
  } else {
    clear_has_onevent();
    onevent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .Medusa.CoreProto.RectF ScissorBox = 21;
inline bool Label::has_scissorbox() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void Label::set_has_scissorbox() {
  _has_bits_[0] |= 0x00100000u;
}
inline void Label::clear_has_scissorbox() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void Label::clear_scissorbox() {
  if (scissorbox_ != NULL) scissorbox_->::Medusa::CoreProto::RectF::Clear();
  clear_has_scissorbox();
}
inline const ::Medusa::CoreProto::RectF& Label::scissorbox() const {
  return scissorbox_ != NULL ? *scissorbox_ : *default_instance_->scissorbox_;
}
inline ::Medusa::CoreProto::RectF* Label::mutable_scissorbox() {
  set_has_scissorbox();
  if (scissorbox_ == NULL) scissorbox_ = new ::Medusa::CoreProto::RectF;
  return scissorbox_;
}
inline ::Medusa::CoreProto::RectF* Label::release_scissorbox() {
  clear_has_scissorbox();
  ::Medusa::CoreProto::RectF* temp = scissorbox_;
  scissorbox_ = NULL;
  return temp;
}
inline void Label::set_allocated_scissorbox(::Medusa::CoreProto::RectF* scissorbox) {
  delete scissorbox_;
  scissorbox_ = scissorbox;
  if (scissorbox) {
    set_has_scissorbox();
  } else {
    clear_has_scissorbox();
  }
}

// optional int32 Tag = 51;
inline bool Label::has_tag() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void Label::set_has_tag() {
  _has_bits_[0] |= 0x00200000u;
}
inline void Label::clear_has_tag() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void Label::clear_tag() {
  tag_ = 0;
  clear_has_tag();
}
inline ::google::protobuf::int32 Label::tag() const {
  return tag_;
}
inline void Label::set_tag(::google::protobuf::int32 value) {
  set_has_tag();
  tag_ = value;
}

// optional float StrokeSize = 52;
inline bool Label::has_strokesize() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void Label::set_has_strokesize() {
  _has_bits_[0] |= 0x00400000u;
}
inline void Label::clear_has_strokesize() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void Label::clear_strokesize() {
  strokesize_ = 0;
  clear_has_strokesize();
}
inline float Label::strokesize() const {
  return strokesize_;
}
inline void Label::set_strokesize(float value) {
  set_has_strokesize();
  strokesize_ = value;
}

// optional .Medusa.CoreProto.PointF ShadowOffset = 53;
inline bool Label::has_shadowoffset() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void Label::set_has_shadowoffset() {
  _has_bits_[0] |= 0x00800000u;
}
inline void Label::clear_has_shadowoffset() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void Label::clear_shadowoffset() {
  if (shadowoffset_ != NULL) shadowoffset_->::Medusa::CoreProto::PointF::Clear();
  clear_has_shadowoffset();
}
inline const ::Medusa::CoreProto::PointF& Label::shadowoffset() const {
  return shadowoffset_ != NULL ? *shadowoffset_ : *default_instance_->shadowoffset_;
}
inline ::Medusa::CoreProto::PointF* Label::mutable_shadowoffset() {
  set_has_shadowoffset();
  if (shadowoffset_ == NULL) shadowoffset_ = new ::Medusa::CoreProto::PointF;
  return shadowoffset_;
}
inline ::Medusa::CoreProto::PointF* Label::release_shadowoffset() {
  clear_has_shadowoffset();
  ::Medusa::CoreProto::PointF* temp = shadowoffset_;
  shadowoffset_ = NULL;
  return temp;
}
inline void Label::set_allocated_shadowoffset(::Medusa::CoreProto::PointF* shadowoffset) {
  delete shadowoffset_;
  shadowoffset_ = shadowoffset;
  if (shadowoffset) {
    set_has_shadowoffset();
  } else {
    clear_has_shadowoffset();
  }
}

// optional .Medusa.CoreProto.ColorF ShadowColor = 54;
inline bool Label::has_shadowcolor() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void Label::set_has_shadowcolor() {
  _has_bits_[0] |= 0x01000000u;
}
inline void Label::clear_has_shadowcolor() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void Label::clear_shadowcolor() {
  if (shadowcolor_ != NULL) shadowcolor_->::Medusa::CoreProto::ColorF::Clear();
  clear_has_shadowcolor();
}
inline const ::Medusa::CoreProto::ColorF& Label::shadowcolor() const {
  return shadowcolor_ != NULL ? *shadowcolor_ : *default_instance_->shadowcolor_;
}
inline ::Medusa::CoreProto::ColorF* Label::mutable_shadowcolor() {
  set_has_shadowcolor();
  if (shadowcolor_ == NULL) shadowcolor_ = new ::Medusa::CoreProto::ColorF;
  return shadowcolor_;
}
inline ::Medusa::CoreProto::ColorF* Label::release_shadowcolor() {
  clear_has_shadowcolor();
  ::Medusa::CoreProto::ColorF* temp = shadowcolor_;
  shadowcolor_ = NULL;
  return temp;
}
inline void Label::set_allocated_shadowcolor(::Medusa::CoreProto::ColorF* shadowcolor) {
  delete shadowcolor_;
  shadowcolor_ = shadowcolor;
  if (shadowcolor) {
    set_has_shadowcolor();
  } else {
    clear_has_shadowcolor();
  }
}

// optional float ShadowBlur = 55;
inline bool Label::has_shadowblur() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void Label::set_has_shadowblur() {
  _has_bits_[0] |= 0x02000000u;
}
inline void Label::clear_has_shadowblur() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void Label::clear_shadowblur() {
  shadowblur_ = 0;
  clear_has_shadowblur();
}
inline float Label::shadowblur() const {
  return shadowblur_;
}
inline void Label::set_shadowblur(float value) {
  set_has_shadowblur();
  shadowblur_ = value;
}

// optional bool IsLock = 201;
inline bool Label::has_islock() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void Label::set_has_islock() {
  _has_bits_[0] |= 0x04000000u;
}
inline void Label::clear_has_islock() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void Label::clear_islock() {
  islock_ = false;
  clear_has_islock();
}
inline bool Label::islock() const {
  return islock_;
}
inline void Label::set_islock(bool value) {
  set_has_islock();
  islock_ = value;
}

// optional bool IsHide = 202;
inline bool Label::has_ishide() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void Label::set_has_ishide() {
  _has_bits_[0] |= 0x08000000u;
}
inline void Label::clear_has_ishide() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void Label::clear_ishide() {
  ishide_ = false;
  clear_has_ishide();
}
inline bool Label::ishide() const {
  return ishide_;
}
inline void Label::set_ishide(bool value) {
  set_has_ishide();
  ishide_ = value;
}

// -------------------------------------------------------------------

// EditBox

// required string ID = 1;
inline bool EditBox::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EditBox::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EditBox::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EditBox::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& EditBox::id() const {
  return *id_;
}
inline void EditBox::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void EditBox::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void EditBox::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EditBox::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* EditBox::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EditBox::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .Medusa.CoreProto.SizeU Size = 2;
inline bool EditBox::has_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EditBox::set_has_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EditBox::clear_has_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EditBox::clear_size() {
  if (size_ != NULL) size_->::Medusa::CoreProto::SizeU::Clear();
  clear_has_size();
}
inline const ::Medusa::CoreProto::SizeU& EditBox::size() const {
  return size_ != NULL ? *size_ : *default_instance_->size_;
}
inline ::Medusa::CoreProto::SizeU* EditBox::mutable_size() {
  set_has_size();
  if (size_ == NULL) size_ = new ::Medusa::CoreProto::SizeU;
  return size_;
}
inline ::Medusa::CoreProto::SizeU* EditBox::release_size() {
  clear_has_size();
  ::Medusa::CoreProto::SizeU* temp = size_;
  size_ = NULL;
  return temp;
}
inline void EditBox::set_allocated_size(::Medusa::CoreProto::SizeU* size) {
  delete size_;
  size_ = size;
  if (size) {
    set_has_size();
  } else {
    clear_has_size();
  }
}

// required .Medusa.CoreProto.PointF Position = 3;
inline bool EditBox::has_position() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EditBox::set_has_position() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EditBox::clear_has_position() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EditBox::clear_position() {
  if (position_ != NULL) position_->::Medusa::CoreProto::PointF::Clear();
  clear_has_position();
}
inline const ::Medusa::CoreProto::PointF& EditBox::position() const {
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::Medusa::CoreProto::PointF* EditBox::mutable_position() {
  set_has_position();
  if (position_ == NULL) position_ = new ::Medusa::CoreProto::PointF;
  return position_;
}
inline ::Medusa::CoreProto::PointF* EditBox::release_position() {
  clear_has_position();
  ::Medusa::CoreProto::PointF* temp = position_;
  position_ = NULL;
  return temp;
}
inline void EditBox::set_allocated_position(::Medusa::CoreProto::PointF* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
}

// required bool IsProportionPoint = 4;
inline bool EditBox::has_isproportionpoint() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EditBox::set_has_isproportionpoint() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EditBox::clear_has_isproportionpoint() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EditBox::clear_isproportionpoint() {
  isproportionpoint_ = false;
  clear_has_isproportionpoint();
}
inline bool EditBox::isproportionpoint() const {
  return isproportionpoint_;
}
inline void EditBox::set_isproportionpoint(bool value) {
  set_has_isproportionpoint();
  isproportionpoint_ = value;
}

// required .Medusa.CoreProto.PointF Anchor = 5;
inline bool EditBox::has_anchor() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EditBox::set_has_anchor() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EditBox::clear_has_anchor() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EditBox::clear_anchor() {
  if (anchor_ != NULL) anchor_->::Medusa::CoreProto::PointF::Clear();
  clear_has_anchor();
}
inline const ::Medusa::CoreProto::PointF& EditBox::anchor() const {
  return anchor_ != NULL ? *anchor_ : *default_instance_->anchor_;
}
inline ::Medusa::CoreProto::PointF* EditBox::mutable_anchor() {
  set_has_anchor();
  if (anchor_ == NULL) anchor_ = new ::Medusa::CoreProto::PointF;
  return anchor_;
}
inline ::Medusa::CoreProto::PointF* EditBox::release_anchor() {
  clear_has_anchor();
  ::Medusa::CoreProto::PointF* temp = anchor_;
  anchor_ = NULL;
  return temp;
}
inline void EditBox::set_allocated_anchor(::Medusa::CoreProto::PointF* anchor) {
  delete anchor_;
  anchor_ = anchor;
  if (anchor) {
    set_has_anchor();
  } else {
    clear_has_anchor();
  }
}

// required int32 ZOrder = 6;
inline bool EditBox::has_zorder() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void EditBox::set_has_zorder() {
  _has_bits_[0] |= 0x00000020u;
}
inline void EditBox::clear_has_zorder() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void EditBox::clear_zorder() {
  zorder_ = 0;
  clear_has_zorder();
}
inline ::google::protobuf::int32 EditBox::zorder() const {
  return zorder_;
}
inline void EditBox::set_zorder(::google::protobuf::int32 value) {
  set_has_zorder();
  zorder_ = value;
}

// optional float Rotation = 7;
inline bool EditBox::has_rotation() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void EditBox::set_has_rotation() {
  _has_bits_[0] |= 0x00000040u;
}
inline void EditBox::clear_has_rotation() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void EditBox::clear_rotation() {
  rotation_ = 0;
  clear_has_rotation();
}
inline float EditBox::rotation() const {
  return rotation_;
}
inline void EditBox::set_rotation(float value) {
  set_has_rotation();
  rotation_ = value;
}

// optional .Medusa.CoreProto.ScaleF Scale = 8;
inline bool EditBox::has_scale() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void EditBox::set_has_scale() {
  _has_bits_[0] |= 0x00000080u;
}
inline void EditBox::clear_has_scale() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void EditBox::clear_scale() {
  if (scale_ != NULL) scale_->::Medusa::CoreProto::ScaleF::Clear();
  clear_has_scale();
}
inline const ::Medusa::CoreProto::ScaleF& EditBox::scale() const {
  return scale_ != NULL ? *scale_ : *default_instance_->scale_;
}
inline ::Medusa::CoreProto::ScaleF* EditBox::mutable_scale() {
  set_has_scale();
  if (scale_ == NULL) scale_ = new ::Medusa::CoreProto::ScaleF;
  return scale_;
}
inline ::Medusa::CoreProto::ScaleF* EditBox::release_scale() {
  clear_has_scale();
  ::Medusa::CoreProto::ScaleF* temp = scale_;
  scale_ = NULL;
  return temp;
}
inline void EditBox::set_allocated_scale(::Medusa::CoreProto::ScaleF* scale) {
  delete scale_;
  scale_ = scale;
  if (scale) {
    set_has_scale();
  } else {
    clear_has_scale();
  }
}

// required bool IsVisible = 9;
inline bool EditBox::has_isvisible() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void EditBox::set_has_isvisible() {
  _has_bits_[0] |= 0x00000100u;
}
inline void EditBox::clear_has_isvisible() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void EditBox::clear_isvisible() {
  isvisible_ = false;
  clear_has_isvisible();
}
inline bool EditBox::isvisible() const {
  return isvisible_;
}
inline void EditBox::set_isvisible(bool value) {
  set_has_isvisible();
  isvisible_ = value;
}

// required .Medusa.CoreProto.FileId FontName = 10;
inline bool EditBox::has_fontname() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void EditBox::set_has_fontname() {
  _has_bits_[0] |= 0x00000200u;
}
inline void EditBox::clear_has_fontname() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void EditBox::clear_fontname() {
  if (fontname_ != NULL) fontname_->::Medusa::CoreProto::FileId::Clear();
  clear_has_fontname();
}
inline const ::Medusa::CoreProto::FileId& EditBox::fontname() const {
  return fontname_ != NULL ? *fontname_ : *default_instance_->fontname_;
}
inline ::Medusa::CoreProto::FileId* EditBox::mutable_fontname() {
  set_has_fontname();
  if (fontname_ == NULL) fontname_ = new ::Medusa::CoreProto::FileId;
  return fontname_;
}
inline ::Medusa::CoreProto::FileId* EditBox::release_fontname() {
  clear_has_fontname();
  ::Medusa::CoreProto::FileId* temp = fontname_;
  fontname_ = NULL;
  return temp;
}
inline void EditBox::set_allocated_fontname(::Medusa::CoreProto::FileId* fontname) {
  delete fontname_;
  fontname_ = fontname;
  if (fontname) {
    set_has_fontname();
  } else {
    clear_has_fontname();
  }
}

// required uint32 FontSize = 11;
inline bool EditBox::has_fontsize() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void EditBox::set_has_fontsize() {
  _has_bits_[0] |= 0x00000400u;
}
inline void EditBox::clear_has_fontsize() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void EditBox::clear_fontsize() {
  fontsize_ = 0u;
  clear_has_fontsize();
}
inline ::google::protobuf::uint32 EditBox::fontsize() const {
  return fontsize_;
}
inline void EditBox::set_fontsize(::google::protobuf::uint32 value) {
  set_has_fontsize();
  fontsize_ = value;
}

// optional string Text = 12;
inline bool EditBox::has_text() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void EditBox::set_has_text() {
  _has_bits_[0] |= 0x00000800u;
}
inline void EditBox::clear_has_text() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void EditBox::clear_text() {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& EditBox::text() const {
  return *text_;
}
inline void EditBox::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void EditBox::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void EditBox::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EditBox::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  return text_;
}
inline ::std::string* EditBox::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EditBox::set_allocated_text(::std::string* text) {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    delete text_;
  }
  if (text) {
    set_has_text();
    text_ = text;
  } else {
    clear_has_text();
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .Medusa.CoreProto.ColorF Color = 13;
inline bool EditBox::has_color() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void EditBox::set_has_color() {
  _has_bits_[0] |= 0x00001000u;
}
inline void EditBox::clear_has_color() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void EditBox::clear_color() {
  if (color_ != NULL) color_->::Medusa::CoreProto::ColorF::Clear();
  clear_has_color();
}
inline const ::Medusa::CoreProto::ColorF& EditBox::color() const {
  return color_ != NULL ? *color_ : *default_instance_->color_;
}
inline ::Medusa::CoreProto::ColorF* EditBox::mutable_color() {
  set_has_color();
  if (color_ == NULL) color_ = new ::Medusa::CoreProto::ColorF;
  return color_;
}
inline ::Medusa::CoreProto::ColorF* EditBox::release_color() {
  clear_has_color();
  ::Medusa::CoreProto::ColorF* temp = color_;
  color_ = NULL;
  return temp;
}
inline void EditBox::set_allocated_color(::Medusa::CoreProto::ColorF* color) {
  delete color_;
  color_ = color;
  if (color) {
    set_has_color();
  } else {
    clear_has_color();
  }
}

// required .Medusa.CoreProto.Editor.ImageFile BackgroundImage = 14;
inline bool EditBox::has_backgroundimage() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void EditBox::set_has_backgroundimage() {
  _has_bits_[0] |= 0x00002000u;
}
inline void EditBox::clear_has_backgroundimage() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void EditBox::clear_backgroundimage() {
  if (backgroundimage_ != NULL) backgroundimage_->::Medusa::CoreProto::Editor::ImageFile::Clear();
  clear_has_backgroundimage();
}
inline const ::Medusa::CoreProto::Editor::ImageFile& EditBox::backgroundimage() const {
  return backgroundimage_ != NULL ? *backgroundimage_ : *default_instance_->backgroundimage_;
}
inline ::Medusa::CoreProto::Editor::ImageFile* EditBox::mutable_backgroundimage() {
  set_has_backgroundimage();
  if (backgroundimage_ == NULL) backgroundimage_ = new ::Medusa::CoreProto::Editor::ImageFile;
  return backgroundimage_;
}
inline ::Medusa::CoreProto::Editor::ImageFile* EditBox::release_backgroundimage() {
  clear_has_backgroundimage();
  ::Medusa::CoreProto::Editor::ImageFile* temp = backgroundimage_;
  backgroundimage_ = NULL;
  return temp;
}
inline void EditBox::set_allocated_backgroundimage(::Medusa::CoreProto::Editor::ImageFile* backgroundimage) {
  delete backgroundimage_;
  backgroundimage_ = backgroundimage;
  if (backgroundimage) {
    set_has_backgroundimage();
  } else {
    clear_has_backgroundimage();
  }
}

// required .Medusa.CoreProto.Editor.TextAlignmentType AlignmentType = 18;
inline bool EditBox::has_alignmenttype() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void EditBox::set_has_alignmenttype() {
  _has_bits_[0] |= 0x00004000u;
}
inline void EditBox::clear_has_alignmenttype() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void EditBox::clear_alignmenttype() {
  alignmenttype_ = 1;
  clear_has_alignmenttype();
}
inline ::Medusa::CoreProto::Editor::TextAlignmentType EditBox::alignmenttype() const {
  return static_cast< ::Medusa::CoreProto::Editor::TextAlignmentType >(alignmenttype_);
}
inline void EditBox::set_alignmenttype(::Medusa::CoreProto::Editor::TextAlignmentType value) {
  assert(::Medusa::CoreProto::Editor::TextAlignmentType_IsValid(value));
  set_has_alignmenttype();
  alignmenttype_ = value;
}

// required .Medusa.CoreProto.Editor.EditBox.EditBoxKeyboardReturnType KeyboardReturnType = 19;
inline bool EditBox::has_keyboardreturntype() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void EditBox::set_has_keyboardreturntype() {
  _has_bits_[0] |= 0x00008000u;
}
inline void EditBox::clear_has_keyboardreturntype() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void EditBox::clear_keyboardreturntype() {
  keyboardreturntype_ = 0;
  clear_has_keyboardreturntype();
}
inline ::Medusa::CoreProto::Editor::EditBox_EditBoxKeyboardReturnType EditBox::keyboardreturntype() const {
  return static_cast< ::Medusa::CoreProto::Editor::EditBox_EditBoxKeyboardReturnType >(keyboardreturntype_);
}
inline void EditBox::set_keyboardreturntype(::Medusa::CoreProto::Editor::EditBox_EditBoxKeyboardReturnType value) {
  assert(::Medusa::CoreProto::Editor::EditBox_EditBoxKeyboardReturnType_IsValid(value));
  set_has_keyboardreturntype();
  keyboardreturntype_ = value;
}

// required .Medusa.CoreProto.Editor.EditBox.EditBoxInputMode InputMode = 20;
inline bool EditBox::has_inputmode() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void EditBox::set_has_inputmode() {
  _has_bits_[0] |= 0x00010000u;
}
inline void EditBox::clear_has_inputmode() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void EditBox::clear_inputmode() {
  inputmode_ = 0;
  clear_has_inputmode();
}
inline ::Medusa::CoreProto::Editor::EditBox_EditBoxInputMode EditBox::inputmode() const {
  return static_cast< ::Medusa::CoreProto::Editor::EditBox_EditBoxInputMode >(inputmode_);
}
inline void EditBox::set_inputmode(::Medusa::CoreProto::Editor::EditBox_EditBoxInputMode value) {
  assert(::Medusa::CoreProto::Editor::EditBox_EditBoxInputMode_IsValid(value));
  set_has_inputmode();
  inputmode_ = value;
}

// required .Medusa.CoreProto.Editor.EditBox.EditBoxInputFlag InputFlag = 21;
inline bool EditBox::has_inputflag() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void EditBox::set_has_inputflag() {
  _has_bits_[0] |= 0x00020000u;
}
inline void EditBox::clear_has_inputflag() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void EditBox::clear_inputflag() {
  inputflag_ = 0;
  clear_has_inputflag();
}
inline ::Medusa::CoreProto::Editor::EditBox_EditBoxInputFlag EditBox::inputflag() const {
  return static_cast< ::Medusa::CoreProto::Editor::EditBox_EditBoxInputFlag >(inputflag_);
}
inline void EditBox::set_inputflag(::Medusa::CoreProto::Editor::EditBox_EditBoxInputFlag value) {
  assert(::Medusa::CoreProto::Editor::EditBox_EditBoxInputFlag_IsValid(value));
  set_has_inputflag();
  inputflag_ = value;
}

// optional uint32 CharacterNum = 25;
inline bool EditBox::has_characternum() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void EditBox::set_has_characternum() {
  _has_bits_[0] |= 0x00040000u;
}
inline void EditBox::clear_has_characternum() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void EditBox::clear_characternum() {
  characternum_ = 0u;
  clear_has_characternum();
}
inline ::google::protobuf::uint32 EditBox::characternum() const {
  return characternum_;
}
inline void EditBox::set_characternum(::google::protobuf::uint32 value) {
  set_has_characternum();
  characternum_ = value;
}

// optional string MinLineNum = 26;
inline bool EditBox::has_minlinenum() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void EditBox::set_has_minlinenum() {
  _has_bits_[0] |= 0x00080000u;
}
inline void EditBox::clear_has_minlinenum() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void EditBox::clear_minlinenum() {
  if (minlinenum_ != &::google::protobuf::internal::kEmptyString) {
    minlinenum_->clear();
  }
  clear_has_minlinenum();
}
inline const ::std::string& EditBox::minlinenum() const {
  return *minlinenum_;
}
inline void EditBox::set_minlinenum(const ::std::string& value) {
  set_has_minlinenum();
  if (minlinenum_ == &::google::protobuf::internal::kEmptyString) {
    minlinenum_ = new ::std::string;
  }
  minlinenum_->assign(value);
}
inline void EditBox::set_minlinenum(const char* value) {
  set_has_minlinenum();
  if (minlinenum_ == &::google::protobuf::internal::kEmptyString) {
    minlinenum_ = new ::std::string;
  }
  minlinenum_->assign(value);
}
inline void EditBox::set_minlinenum(const char* value, size_t size) {
  set_has_minlinenum();
  if (minlinenum_ == &::google::protobuf::internal::kEmptyString) {
    minlinenum_ = new ::std::string;
  }
  minlinenum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EditBox::mutable_minlinenum() {
  set_has_minlinenum();
  if (minlinenum_ == &::google::protobuf::internal::kEmptyString) {
    minlinenum_ = new ::std::string;
  }
  return minlinenum_;
}
inline ::std::string* EditBox::release_minlinenum() {
  clear_has_minlinenum();
  if (minlinenum_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = minlinenum_;
    minlinenum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EditBox::set_allocated_minlinenum(::std::string* minlinenum) {
  if (minlinenum_ != &::google::protobuf::internal::kEmptyString) {
    delete minlinenum_;
  }
  if (minlinenum) {
    set_has_minlinenum();
    minlinenum_ = minlinenum;
  } else {
    clear_has_minlinenum();
    minlinenum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string MaxLineNum = 27;
inline bool EditBox::has_maxlinenum() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void EditBox::set_has_maxlinenum() {
  _has_bits_[0] |= 0x00100000u;
}
inline void EditBox::clear_has_maxlinenum() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void EditBox::clear_maxlinenum() {
  if (maxlinenum_ != &::google::protobuf::internal::kEmptyString) {
    maxlinenum_->clear();
  }
  clear_has_maxlinenum();
}
inline const ::std::string& EditBox::maxlinenum() const {
  return *maxlinenum_;
}
inline void EditBox::set_maxlinenum(const ::std::string& value) {
  set_has_maxlinenum();
  if (maxlinenum_ == &::google::protobuf::internal::kEmptyString) {
    maxlinenum_ = new ::std::string;
  }
  maxlinenum_->assign(value);
}
inline void EditBox::set_maxlinenum(const char* value) {
  set_has_maxlinenum();
  if (maxlinenum_ == &::google::protobuf::internal::kEmptyString) {
    maxlinenum_ = new ::std::string;
  }
  maxlinenum_->assign(value);
}
inline void EditBox::set_maxlinenum(const char* value, size_t size) {
  set_has_maxlinenum();
  if (maxlinenum_ == &::google::protobuf::internal::kEmptyString) {
    maxlinenum_ = new ::std::string;
  }
  maxlinenum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EditBox::mutable_maxlinenum() {
  set_has_maxlinenum();
  if (maxlinenum_ == &::google::protobuf::internal::kEmptyString) {
    maxlinenum_ = new ::std::string;
  }
  return maxlinenum_;
}
inline ::std::string* EditBox::release_maxlinenum() {
  clear_has_maxlinenum();
  if (maxlinenum_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = maxlinenum_;
    maxlinenum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EditBox::set_allocated_maxlinenum(::std::string* maxlinenum) {
  if (maxlinenum_ != &::google::protobuf::internal::kEmptyString) {
    delete maxlinenum_;
  }
  if (maxlinenum) {
    set_has_maxlinenum();
    maxlinenum_ = maxlinenum;
  } else {
    clear_has_maxlinenum();
    maxlinenum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string OnLoad = 30;
inline bool EditBox::has_onload() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void EditBox::set_has_onload() {
  _has_bits_[0] |= 0x00200000u;
}
inline void EditBox::clear_has_onload() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void EditBox::clear_onload() {
  if (onload_ != &::google::protobuf::internal::kEmptyString) {
    onload_->clear();
  }
  clear_has_onload();
}
inline const ::std::string& EditBox::onload() const {
  return *onload_;
}
inline void EditBox::set_onload(const ::std::string& value) {
  set_has_onload();
  if (onload_ == &::google::protobuf::internal::kEmptyString) {
    onload_ = new ::std::string;
  }
  onload_->assign(value);
}
inline void EditBox::set_onload(const char* value) {
  set_has_onload();
  if (onload_ == &::google::protobuf::internal::kEmptyString) {
    onload_ = new ::std::string;
  }
  onload_->assign(value);
}
inline void EditBox::set_onload(const char* value, size_t size) {
  set_has_onload();
  if (onload_ == &::google::protobuf::internal::kEmptyString) {
    onload_ = new ::std::string;
  }
  onload_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EditBox::mutable_onload() {
  set_has_onload();
  if (onload_ == &::google::protobuf::internal::kEmptyString) {
    onload_ = new ::std::string;
  }
  return onload_;
}
inline ::std::string* EditBox::release_onload() {
  clear_has_onload();
  if (onload_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = onload_;
    onload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EditBox::set_allocated_onload(::std::string* onload) {
  if (onload_ != &::google::protobuf::internal::kEmptyString) {
    delete onload_;
  }
  if (onload) {
    set_has_onload();
    onload_ = onload;
  } else {
    clear_has_onload();
    onload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string OnShow = 31;
inline bool EditBox::has_onshow() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void EditBox::set_has_onshow() {
  _has_bits_[0] |= 0x00400000u;
}
inline void EditBox::clear_has_onshow() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void EditBox::clear_onshow() {
  if (onshow_ != &::google::protobuf::internal::kEmptyString) {
    onshow_->clear();
  }
  clear_has_onshow();
}
inline const ::std::string& EditBox::onshow() const {
  return *onshow_;
}
inline void EditBox::set_onshow(const ::std::string& value) {
  set_has_onshow();
  if (onshow_ == &::google::protobuf::internal::kEmptyString) {
    onshow_ = new ::std::string;
  }
  onshow_->assign(value);
}
inline void EditBox::set_onshow(const char* value) {
  set_has_onshow();
  if (onshow_ == &::google::protobuf::internal::kEmptyString) {
    onshow_ = new ::std::string;
  }
  onshow_->assign(value);
}
inline void EditBox::set_onshow(const char* value, size_t size) {
  set_has_onshow();
  if (onshow_ == &::google::protobuf::internal::kEmptyString) {
    onshow_ = new ::std::string;
  }
  onshow_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EditBox::mutable_onshow() {
  set_has_onshow();
  if (onshow_ == &::google::protobuf::internal::kEmptyString) {
    onshow_ = new ::std::string;
  }
  return onshow_;
}
inline ::std::string* EditBox::release_onshow() {
  clear_has_onshow();
  if (onshow_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = onshow_;
    onshow_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EditBox::set_allocated_onshow(::std::string* onshow) {
  if (onshow_ != &::google::protobuf::internal::kEmptyString) {
    delete onshow_;
  }
  if (onshow) {
    set_has_onshow();
    onshow_ = onshow;
  } else {
    clear_has_onshow();
    onshow_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string OnHide = 32;
inline bool EditBox::has_onhide() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void EditBox::set_has_onhide() {
  _has_bits_[0] |= 0x00800000u;
}
inline void EditBox::clear_has_onhide() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void EditBox::clear_onhide() {
  if (onhide_ != &::google::protobuf::internal::kEmptyString) {
    onhide_->clear();
  }
  clear_has_onhide();
}
inline const ::std::string& EditBox::onhide() const {
  return *onhide_;
}
inline void EditBox::set_onhide(const ::std::string& value) {
  set_has_onhide();
  if (onhide_ == &::google::protobuf::internal::kEmptyString) {
    onhide_ = new ::std::string;
  }
  onhide_->assign(value);
}
inline void EditBox::set_onhide(const char* value) {
  set_has_onhide();
  if (onhide_ == &::google::protobuf::internal::kEmptyString) {
    onhide_ = new ::std::string;
  }
  onhide_->assign(value);
}
inline void EditBox::set_onhide(const char* value, size_t size) {
  set_has_onhide();
  if (onhide_ == &::google::protobuf::internal::kEmptyString) {
    onhide_ = new ::std::string;
  }
  onhide_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EditBox::mutable_onhide() {
  set_has_onhide();
  if (onhide_ == &::google::protobuf::internal::kEmptyString) {
    onhide_ = new ::std::string;
  }
  return onhide_;
}
inline ::std::string* EditBox::release_onhide() {
  clear_has_onhide();
  if (onhide_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = onhide_;
    onhide_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EditBox::set_allocated_onhide(::std::string* onhide) {
  if (onhide_ != &::google::protobuf::internal::kEmptyString) {
    delete onhide_;
  }
  if (onhide) {
    set_has_onhide();
    onhide_ = onhide;
  } else {
    clear_has_onhide();
    onhide_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string OnClosed = 33;
inline bool EditBox::has_onclosed() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void EditBox::set_has_onclosed() {
  _has_bits_[0] |= 0x01000000u;
}
inline void EditBox::clear_has_onclosed() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void EditBox::clear_onclosed() {
  if (onclosed_ != &::google::protobuf::internal::kEmptyString) {
    onclosed_->clear();
  }
  clear_has_onclosed();
}
inline const ::std::string& EditBox::onclosed() const {
  return *onclosed_;
}
inline void EditBox::set_onclosed(const ::std::string& value) {
  set_has_onclosed();
  if (onclosed_ == &::google::protobuf::internal::kEmptyString) {
    onclosed_ = new ::std::string;
  }
  onclosed_->assign(value);
}
inline void EditBox::set_onclosed(const char* value) {
  set_has_onclosed();
  if (onclosed_ == &::google::protobuf::internal::kEmptyString) {
    onclosed_ = new ::std::string;
  }
  onclosed_->assign(value);
}
inline void EditBox::set_onclosed(const char* value, size_t size) {
  set_has_onclosed();
  if (onclosed_ == &::google::protobuf::internal::kEmptyString) {
    onclosed_ = new ::std::string;
  }
  onclosed_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EditBox::mutable_onclosed() {
  set_has_onclosed();
  if (onclosed_ == &::google::protobuf::internal::kEmptyString) {
    onclosed_ = new ::std::string;
  }
  return onclosed_;
}
inline ::std::string* EditBox::release_onclosed() {
  clear_has_onclosed();
  if (onclosed_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = onclosed_;
    onclosed_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EditBox::set_allocated_onclosed(::std::string* onclosed) {
  if (onclosed_ != &::google::protobuf::internal::kEmptyString) {
    delete onclosed_;
  }
  if (onclosed) {
    set_has_onclosed();
    onclosed_ = onclosed;
  } else {
    clear_has_onclosed();
    onclosed_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string OnUpdate = 34;
inline bool EditBox::has_onupdate() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void EditBox::set_has_onupdate() {
  _has_bits_[0] |= 0x02000000u;
}
inline void EditBox::clear_has_onupdate() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void EditBox::clear_onupdate() {
  if (onupdate_ != &::google::protobuf::internal::kEmptyString) {
    onupdate_->clear();
  }
  clear_has_onupdate();
}
inline const ::std::string& EditBox::onupdate() const {
  return *onupdate_;
}
inline void EditBox::set_onupdate(const ::std::string& value) {
  set_has_onupdate();
  if (onupdate_ == &::google::protobuf::internal::kEmptyString) {
    onupdate_ = new ::std::string;
  }
  onupdate_->assign(value);
}
inline void EditBox::set_onupdate(const char* value) {
  set_has_onupdate();
  if (onupdate_ == &::google::protobuf::internal::kEmptyString) {
    onupdate_ = new ::std::string;
  }
  onupdate_->assign(value);
}
inline void EditBox::set_onupdate(const char* value, size_t size) {
  set_has_onupdate();
  if (onupdate_ == &::google::protobuf::internal::kEmptyString) {
    onupdate_ = new ::std::string;
  }
  onupdate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EditBox::mutable_onupdate() {
  set_has_onupdate();
  if (onupdate_ == &::google::protobuf::internal::kEmptyString) {
    onupdate_ = new ::std::string;
  }
  return onupdate_;
}
inline ::std::string* EditBox::release_onupdate() {
  clear_has_onupdate();
  if (onupdate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = onupdate_;
    onupdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EditBox::set_allocated_onupdate(::std::string* onupdate) {
  if (onupdate_ != &::google::protobuf::internal::kEmptyString) {
    delete onupdate_;
  }
  if (onupdate) {
    set_has_onupdate();
    onupdate_ = onupdate;
  } else {
    clear_has_onupdate();
    onupdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string OnChar = 35;
inline bool EditBox::has_onchar() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void EditBox::set_has_onchar() {
  _has_bits_[0] |= 0x04000000u;
}
inline void EditBox::clear_has_onchar() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void EditBox::clear_onchar() {
  if (onchar_ != &::google::protobuf::internal::kEmptyString) {
    onchar_->clear();
  }
  clear_has_onchar();
}
inline const ::std::string& EditBox::onchar() const {
  return *onchar_;
}
inline void EditBox::set_onchar(const ::std::string& value) {
  set_has_onchar();
  if (onchar_ == &::google::protobuf::internal::kEmptyString) {
    onchar_ = new ::std::string;
  }
  onchar_->assign(value);
}
inline void EditBox::set_onchar(const char* value) {
  set_has_onchar();
  if (onchar_ == &::google::protobuf::internal::kEmptyString) {
    onchar_ = new ::std::string;
  }
  onchar_->assign(value);
}
inline void EditBox::set_onchar(const char* value, size_t size) {
  set_has_onchar();
  if (onchar_ == &::google::protobuf::internal::kEmptyString) {
    onchar_ = new ::std::string;
  }
  onchar_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EditBox::mutable_onchar() {
  set_has_onchar();
  if (onchar_ == &::google::protobuf::internal::kEmptyString) {
    onchar_ = new ::std::string;
  }
  return onchar_;
}
inline ::std::string* EditBox::release_onchar() {
  clear_has_onchar();
  if (onchar_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = onchar_;
    onchar_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EditBox::set_allocated_onchar(::std::string* onchar) {
  if (onchar_ != &::google::protobuf::internal::kEmptyString) {
    delete onchar_;
  }
  if (onchar) {
    set_has_onchar();
    onchar_ = onchar;
  } else {
    clear_has_onchar();
    onchar_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string OnEvent = 36;
inline bool EditBox::has_onevent() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void EditBox::set_has_onevent() {
  _has_bits_[0] |= 0x08000000u;
}
inline void EditBox::clear_has_onevent() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void EditBox::clear_onevent() {
  if (onevent_ != &::google::protobuf::internal::kEmptyString) {
    onevent_->clear();
  }
  clear_has_onevent();
}
inline const ::std::string& EditBox::onevent() const {
  return *onevent_;
}
inline void EditBox::set_onevent(const ::std::string& value) {
  set_has_onevent();
  if (onevent_ == &::google::protobuf::internal::kEmptyString) {
    onevent_ = new ::std::string;
  }
  onevent_->assign(value);
}
inline void EditBox::set_onevent(const char* value) {
  set_has_onevent();
  if (onevent_ == &::google::protobuf::internal::kEmptyString) {
    onevent_ = new ::std::string;
  }
  onevent_->assign(value);
}
inline void EditBox::set_onevent(const char* value, size_t size) {
  set_has_onevent();
  if (onevent_ == &::google::protobuf::internal::kEmptyString) {
    onevent_ = new ::std::string;
  }
  onevent_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EditBox::mutable_onevent() {
  set_has_onevent();
  if (onevent_ == &::google::protobuf::internal::kEmptyString) {
    onevent_ = new ::std::string;
  }
  return onevent_;
}
inline ::std::string* EditBox::release_onevent() {
  clear_has_onevent();
  if (onevent_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = onevent_;
    onevent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EditBox::set_allocated_onevent(::std::string* onevent) {
  if (onevent_ != &::google::protobuf::internal::kEmptyString) {
    delete onevent_;
  }
  if (onevent) {
    set_has_onevent();
    onevent_ = onevent;
  } else {
    clear_has_onevent();
    onevent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .Medusa.CoreProto.RectF ScissorBox = 37;
inline bool EditBox::has_scissorbox() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void EditBox::set_has_scissorbox() {
  _has_bits_[0] |= 0x10000000u;
}
inline void EditBox::clear_has_scissorbox() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void EditBox::clear_scissorbox() {
  if (scissorbox_ != NULL) scissorbox_->::Medusa::CoreProto::RectF::Clear();
  clear_has_scissorbox();
}
inline const ::Medusa::CoreProto::RectF& EditBox::scissorbox() const {
  return scissorbox_ != NULL ? *scissorbox_ : *default_instance_->scissorbox_;
}
inline ::Medusa::CoreProto::RectF* EditBox::mutable_scissorbox() {
  set_has_scissorbox();
  if (scissorbox_ == NULL) scissorbox_ = new ::Medusa::CoreProto::RectF;
  return scissorbox_;
}
inline ::Medusa::CoreProto::RectF* EditBox::release_scissorbox() {
  clear_has_scissorbox();
  ::Medusa::CoreProto::RectF* temp = scissorbox_;
  scissorbox_ = NULL;
  return temp;
}
inline void EditBox::set_allocated_scissorbox(::Medusa::CoreProto::RectF* scissorbox) {
  delete scissorbox_;
  scissorbox_ = scissorbox;
  if (scissorbox) {
    set_has_scissorbox();
  } else {
    clear_has_scissorbox();
  }
}

// optional int32 Tag = 51;
inline bool EditBox::has_tag() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void EditBox::set_has_tag() {
  _has_bits_[0] |= 0x20000000u;
}
inline void EditBox::clear_has_tag() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void EditBox::clear_tag() {
  tag_ = 0;
  clear_has_tag();
}
inline ::google::protobuf::int32 EditBox::tag() const {
  return tag_;
}
inline void EditBox::set_tag(::google::protobuf::int32 value) {
  set_has_tag();
  tag_ = value;
}

// optional bool IsLock = 201;
inline bool EditBox::has_islock() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void EditBox::set_has_islock() {
  _has_bits_[0] |= 0x40000000u;
}
inline void EditBox::clear_has_islock() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void EditBox::clear_islock() {
  islock_ = false;
  clear_has_islock();
}
inline bool EditBox::islock() const {
  return islock_;
}
inline void EditBox::set_islock(bool value) {
  set_has_islock();
  islock_ = value;
}

// optional bool IsHide = 202;
inline bool EditBox::has_ishide() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void EditBox::set_has_ishide() {
  _has_bits_[0] |= 0x80000000u;
}
inline void EditBox::clear_has_ishide() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void EditBox::clear_ishide() {
  ishide_ = false;
  clear_has_ishide();
}
inline bool EditBox::ishide() const {
  return ishide_;
}
inline void EditBox::set_ishide(bool value) {
  set_has_ishide();
  ishide_ = value;
}

// -------------------------------------------------------------------

// ProgressBar

// required string ID = 1;
inline bool ProgressBar::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProgressBar::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProgressBar::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProgressBar::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& ProgressBar::id() const {
  return *id_;
}
inline void ProgressBar::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void ProgressBar::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void ProgressBar::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProgressBar::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* ProgressBar::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProgressBar::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .Medusa.CoreProto.PointF Position = 2;
inline bool ProgressBar::has_position() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProgressBar::set_has_position() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProgressBar::clear_has_position() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProgressBar::clear_position() {
  if (position_ != NULL) position_->::Medusa::CoreProto::PointF::Clear();
  clear_has_position();
}
inline const ::Medusa::CoreProto::PointF& ProgressBar::position() const {
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::Medusa::CoreProto::PointF* ProgressBar::mutable_position() {
  set_has_position();
  if (position_ == NULL) position_ = new ::Medusa::CoreProto::PointF;
  return position_;
}
inline ::Medusa::CoreProto::PointF* ProgressBar::release_position() {
  clear_has_position();
  ::Medusa::CoreProto::PointF* temp = position_;
  position_ = NULL;
  return temp;
}
inline void ProgressBar::set_allocated_position(::Medusa::CoreProto::PointF* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
}

// required bool IsProportionPoint = 3;
inline bool ProgressBar::has_isproportionpoint() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProgressBar::set_has_isproportionpoint() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProgressBar::clear_has_isproportionpoint() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProgressBar::clear_isproportionpoint() {
  isproportionpoint_ = false;
  clear_has_isproportionpoint();
}
inline bool ProgressBar::isproportionpoint() const {
  return isproportionpoint_;
}
inline void ProgressBar::set_isproportionpoint(bool value) {
  set_has_isproportionpoint();
  isproportionpoint_ = value;
}

// required .Medusa.CoreProto.PointF Anchor = 4;
inline bool ProgressBar::has_anchor() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ProgressBar::set_has_anchor() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ProgressBar::clear_has_anchor() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ProgressBar::clear_anchor() {
  if (anchor_ != NULL) anchor_->::Medusa::CoreProto::PointF::Clear();
  clear_has_anchor();
}
inline const ::Medusa::CoreProto::PointF& ProgressBar::anchor() const {
  return anchor_ != NULL ? *anchor_ : *default_instance_->anchor_;
}
inline ::Medusa::CoreProto::PointF* ProgressBar::mutable_anchor() {
  set_has_anchor();
  if (anchor_ == NULL) anchor_ = new ::Medusa::CoreProto::PointF;
  return anchor_;
}
inline ::Medusa::CoreProto::PointF* ProgressBar::release_anchor() {
  clear_has_anchor();
  ::Medusa::CoreProto::PointF* temp = anchor_;
  anchor_ = NULL;
  return temp;
}
inline void ProgressBar::set_allocated_anchor(::Medusa::CoreProto::PointF* anchor) {
  delete anchor_;
  anchor_ = anchor;
  if (anchor) {
    set_has_anchor();
  } else {
    clear_has_anchor();
  }
}

// required int32 ZOrder = 5;
inline bool ProgressBar::has_zorder() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ProgressBar::set_has_zorder() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ProgressBar::clear_has_zorder() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ProgressBar::clear_zorder() {
  zorder_ = 0;
  clear_has_zorder();
}
inline ::google::protobuf::int32 ProgressBar::zorder() const {
  return zorder_;
}
inline void ProgressBar::set_zorder(::google::protobuf::int32 value) {
  set_has_zorder();
  zorder_ = value;
}

// optional float Rotation = 6;
inline bool ProgressBar::has_rotation() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ProgressBar::set_has_rotation() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ProgressBar::clear_has_rotation() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ProgressBar::clear_rotation() {
  rotation_ = 0;
  clear_has_rotation();
}
inline float ProgressBar::rotation() const {
  return rotation_;
}
inline void ProgressBar::set_rotation(float value) {
  set_has_rotation();
  rotation_ = value;
}

// optional .Medusa.CoreProto.ScaleF Scale = 7;
inline bool ProgressBar::has_scale() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ProgressBar::set_has_scale() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ProgressBar::clear_has_scale() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ProgressBar::clear_scale() {
  if (scale_ != NULL) scale_->::Medusa::CoreProto::ScaleF::Clear();
  clear_has_scale();
}
inline const ::Medusa::CoreProto::ScaleF& ProgressBar::scale() const {
  return scale_ != NULL ? *scale_ : *default_instance_->scale_;
}
inline ::Medusa::CoreProto::ScaleF* ProgressBar::mutable_scale() {
  set_has_scale();
  if (scale_ == NULL) scale_ = new ::Medusa::CoreProto::ScaleF;
  return scale_;
}
inline ::Medusa::CoreProto::ScaleF* ProgressBar::release_scale() {
  clear_has_scale();
  ::Medusa::CoreProto::ScaleF* temp = scale_;
  scale_ = NULL;
  return temp;
}
inline void ProgressBar::set_allocated_scale(::Medusa::CoreProto::ScaleF* scale) {
  delete scale_;
  scale_ = scale;
  if (scale) {
    set_has_scale();
  } else {
    clear_has_scale();
  }
}

// required bool IsVisible = 8;
inline bool ProgressBar::has_isvisible() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ProgressBar::set_has_isvisible() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ProgressBar::clear_has_isvisible() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ProgressBar::clear_isvisible() {
  isvisible_ = false;
  clear_has_isvisible();
}
inline bool ProgressBar::isvisible() const {
  return isvisible_;
}
inline void ProgressBar::set_isvisible(bool value) {
  set_has_isvisible();
  isvisible_ = value;
}

// required .Medusa.CoreProto.SizeU Size = 9;
inline bool ProgressBar::has_size() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ProgressBar::set_has_size() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ProgressBar::clear_has_size() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ProgressBar::clear_size() {
  if (size_ != NULL) size_->::Medusa::CoreProto::SizeU::Clear();
  clear_has_size();
}
inline const ::Medusa::CoreProto::SizeU& ProgressBar::size() const {
  return size_ != NULL ? *size_ : *default_instance_->size_;
}
inline ::Medusa::CoreProto::SizeU* ProgressBar::mutable_size() {
  set_has_size();
  if (size_ == NULL) size_ = new ::Medusa::CoreProto::SizeU;
  return size_;
}
inline ::Medusa::CoreProto::SizeU* ProgressBar::release_size() {
  clear_has_size();
  ::Medusa::CoreProto::SizeU* temp = size_;
  size_ = NULL;
  return temp;
}
inline void ProgressBar::set_allocated_size(::Medusa::CoreProto::SizeU* size) {
  delete size_;
  size_ = size;
  if (size) {
    set_has_size();
  } else {
    clear_has_size();
  }
}

// optional .Medusa.CoreProto.Editor.ImageFile Image = 10;
inline bool ProgressBar::has_image() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ProgressBar::set_has_image() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ProgressBar::clear_has_image() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ProgressBar::clear_image() {
  if (image_ != NULL) image_->::Medusa::CoreProto::Editor::ImageFile::Clear();
  clear_has_image();
}
inline const ::Medusa::CoreProto::Editor::ImageFile& ProgressBar::image() const {
  return image_ != NULL ? *image_ : *default_instance_->image_;
}
inline ::Medusa::CoreProto::Editor::ImageFile* ProgressBar::mutable_image() {
  set_has_image();
  if (image_ == NULL) image_ = new ::Medusa::CoreProto::Editor::ImageFile;
  return image_;
}
inline ::Medusa::CoreProto::Editor::ImageFile* ProgressBar::release_image() {
  clear_has_image();
  ::Medusa::CoreProto::Editor::ImageFile* temp = image_;
  image_ = NULL;
  return temp;
}
inline void ProgressBar::set_allocated_image(::Medusa::CoreProto::Editor::ImageFile* image) {
  delete image_;
  image_ = image;
  if (image) {
    set_has_image();
  } else {
    clear_has_image();
  }
}

// optional string OnLoad = 12;
inline bool ProgressBar::has_onload() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ProgressBar::set_has_onload() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ProgressBar::clear_has_onload() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ProgressBar::clear_onload() {
  if (onload_ != &::google::protobuf::internal::kEmptyString) {
    onload_->clear();
  }
  clear_has_onload();
}
inline const ::std::string& ProgressBar::onload() const {
  return *onload_;
}
inline void ProgressBar::set_onload(const ::std::string& value) {
  set_has_onload();
  if (onload_ == &::google::protobuf::internal::kEmptyString) {
    onload_ = new ::std::string;
  }
  onload_->assign(value);
}
inline void ProgressBar::set_onload(const char* value) {
  set_has_onload();
  if (onload_ == &::google::protobuf::internal::kEmptyString) {
    onload_ = new ::std::string;
  }
  onload_->assign(value);
}
inline void ProgressBar::set_onload(const char* value, size_t size) {
  set_has_onload();
  if (onload_ == &::google::protobuf::internal::kEmptyString) {
    onload_ = new ::std::string;
  }
  onload_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProgressBar::mutable_onload() {
  set_has_onload();
  if (onload_ == &::google::protobuf::internal::kEmptyString) {
    onload_ = new ::std::string;
  }
  return onload_;
}
inline ::std::string* ProgressBar::release_onload() {
  clear_has_onload();
  if (onload_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = onload_;
    onload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProgressBar::set_allocated_onload(::std::string* onload) {
  if (onload_ != &::google::protobuf::internal::kEmptyString) {
    delete onload_;
  }
  if (onload) {
    set_has_onload();
    onload_ = onload;
  } else {
    clear_has_onload();
    onload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string OnShow = 13;
inline bool ProgressBar::has_onshow() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ProgressBar::set_has_onshow() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ProgressBar::clear_has_onshow() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ProgressBar::clear_onshow() {
  if (onshow_ != &::google::protobuf::internal::kEmptyString) {
    onshow_->clear();
  }
  clear_has_onshow();
}
inline const ::std::string& ProgressBar::onshow() const {
  return *onshow_;
}
inline void ProgressBar::set_onshow(const ::std::string& value) {
  set_has_onshow();
  if (onshow_ == &::google::protobuf::internal::kEmptyString) {
    onshow_ = new ::std::string;
  }
  onshow_->assign(value);
}
inline void ProgressBar::set_onshow(const char* value) {
  set_has_onshow();
  if (onshow_ == &::google::protobuf::internal::kEmptyString) {
    onshow_ = new ::std::string;
  }
  onshow_->assign(value);
}
inline void ProgressBar::set_onshow(const char* value, size_t size) {
  set_has_onshow();
  if (onshow_ == &::google::protobuf::internal::kEmptyString) {
    onshow_ = new ::std::string;
  }
  onshow_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProgressBar::mutable_onshow() {
  set_has_onshow();
  if (onshow_ == &::google::protobuf::internal::kEmptyString) {
    onshow_ = new ::std::string;
  }
  return onshow_;
}
inline ::std::string* ProgressBar::release_onshow() {
  clear_has_onshow();
  if (onshow_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = onshow_;
    onshow_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProgressBar::set_allocated_onshow(::std::string* onshow) {
  if (onshow_ != &::google::protobuf::internal::kEmptyString) {
    delete onshow_;
  }
  if (onshow) {
    set_has_onshow();
    onshow_ = onshow;
  } else {
    clear_has_onshow();
    onshow_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string OnHide = 14;
inline bool ProgressBar::has_onhide() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ProgressBar::set_has_onhide() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ProgressBar::clear_has_onhide() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ProgressBar::clear_onhide() {
  if (onhide_ != &::google::protobuf::internal::kEmptyString) {
    onhide_->clear();
  }
  clear_has_onhide();
}
inline const ::std::string& ProgressBar::onhide() const {
  return *onhide_;
}
inline void ProgressBar::set_onhide(const ::std::string& value) {
  set_has_onhide();
  if (onhide_ == &::google::protobuf::internal::kEmptyString) {
    onhide_ = new ::std::string;
  }
  onhide_->assign(value);
}
inline void ProgressBar::set_onhide(const char* value) {
  set_has_onhide();
  if (onhide_ == &::google::protobuf::internal::kEmptyString) {
    onhide_ = new ::std::string;
  }
  onhide_->assign(value);
}
inline void ProgressBar::set_onhide(const char* value, size_t size) {
  set_has_onhide();
  if (onhide_ == &::google::protobuf::internal::kEmptyString) {
    onhide_ = new ::std::string;
  }
  onhide_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProgressBar::mutable_onhide() {
  set_has_onhide();
  if (onhide_ == &::google::protobuf::internal::kEmptyString) {
    onhide_ = new ::std::string;
  }
  return onhide_;
}
inline ::std::string* ProgressBar::release_onhide() {
  clear_has_onhide();
  if (onhide_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = onhide_;
    onhide_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProgressBar::set_allocated_onhide(::std::string* onhide) {
  if (onhide_ != &::google::protobuf::internal::kEmptyString) {
    delete onhide_;
  }
  if (onhide) {
    set_has_onhide();
    onhide_ = onhide;
  } else {
    clear_has_onhide();
    onhide_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string OnClosed = 15;
inline bool ProgressBar::has_onclosed() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ProgressBar::set_has_onclosed() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ProgressBar::clear_has_onclosed() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ProgressBar::clear_onclosed() {
  if (onclosed_ != &::google::protobuf::internal::kEmptyString) {
    onclosed_->clear();
  }
  clear_has_onclosed();
}
inline const ::std::string& ProgressBar::onclosed() const {
  return *onclosed_;
}
inline void ProgressBar::set_onclosed(const ::std::string& value) {
  set_has_onclosed();
  if (onclosed_ == &::google::protobuf::internal::kEmptyString) {
    onclosed_ = new ::std::string;
  }
  onclosed_->assign(value);
}
inline void ProgressBar::set_onclosed(const char* value) {
  set_has_onclosed();
  if (onclosed_ == &::google::protobuf::internal::kEmptyString) {
    onclosed_ = new ::std::string;
  }
  onclosed_->assign(value);
}
inline void ProgressBar::set_onclosed(const char* value, size_t size) {
  set_has_onclosed();
  if (onclosed_ == &::google::protobuf::internal::kEmptyString) {
    onclosed_ = new ::std::string;
  }
  onclosed_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProgressBar::mutable_onclosed() {
  set_has_onclosed();
  if (onclosed_ == &::google::protobuf::internal::kEmptyString) {
    onclosed_ = new ::std::string;
  }
  return onclosed_;
}
inline ::std::string* ProgressBar::release_onclosed() {
  clear_has_onclosed();
  if (onclosed_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = onclosed_;
    onclosed_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProgressBar::set_allocated_onclosed(::std::string* onclosed) {
  if (onclosed_ != &::google::protobuf::internal::kEmptyString) {
    delete onclosed_;
  }
  if (onclosed) {
    set_has_onclosed();
    onclosed_ = onclosed;
  } else {
    clear_has_onclosed();
    onclosed_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string OnUpdate = 16;
inline bool ProgressBar::has_onupdate() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void ProgressBar::set_has_onupdate() {
  _has_bits_[0] |= 0x00004000u;
}
inline void ProgressBar::clear_has_onupdate() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void ProgressBar::clear_onupdate() {
  if (onupdate_ != &::google::protobuf::internal::kEmptyString) {
    onupdate_->clear();
  }
  clear_has_onupdate();
}
inline const ::std::string& ProgressBar::onupdate() const {
  return *onupdate_;
}
inline void ProgressBar::set_onupdate(const ::std::string& value) {
  set_has_onupdate();
  if (onupdate_ == &::google::protobuf::internal::kEmptyString) {
    onupdate_ = new ::std::string;
  }
  onupdate_->assign(value);
}
inline void ProgressBar::set_onupdate(const char* value) {
  set_has_onupdate();
  if (onupdate_ == &::google::protobuf::internal::kEmptyString) {
    onupdate_ = new ::std::string;
  }
  onupdate_->assign(value);
}
inline void ProgressBar::set_onupdate(const char* value, size_t size) {
  set_has_onupdate();
  if (onupdate_ == &::google::protobuf::internal::kEmptyString) {
    onupdate_ = new ::std::string;
  }
  onupdate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProgressBar::mutable_onupdate() {
  set_has_onupdate();
  if (onupdate_ == &::google::protobuf::internal::kEmptyString) {
    onupdate_ = new ::std::string;
  }
  return onupdate_;
}
inline ::std::string* ProgressBar::release_onupdate() {
  clear_has_onupdate();
  if (onupdate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = onupdate_;
    onupdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProgressBar::set_allocated_onupdate(::std::string* onupdate) {
  if (onupdate_ != &::google::protobuf::internal::kEmptyString) {
    delete onupdate_;
  }
  if (onupdate) {
    set_has_onupdate();
    onupdate_ = onupdate;
  } else {
    clear_has_onupdate();
    onupdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string OnEvent = 17;
inline bool ProgressBar::has_onevent() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void ProgressBar::set_has_onevent() {
  _has_bits_[0] |= 0x00008000u;
}
inline void ProgressBar::clear_has_onevent() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void ProgressBar::clear_onevent() {
  if (onevent_ != &::google::protobuf::internal::kEmptyString) {
    onevent_->clear();
  }
  clear_has_onevent();
}
inline const ::std::string& ProgressBar::onevent() const {
  return *onevent_;
}
inline void ProgressBar::set_onevent(const ::std::string& value) {
  set_has_onevent();
  if (onevent_ == &::google::protobuf::internal::kEmptyString) {
    onevent_ = new ::std::string;
  }
  onevent_->assign(value);
}
inline void ProgressBar::set_onevent(const char* value) {
  set_has_onevent();
  if (onevent_ == &::google::protobuf::internal::kEmptyString) {
    onevent_ = new ::std::string;
  }
  onevent_->assign(value);
}
inline void ProgressBar::set_onevent(const char* value, size_t size) {
  set_has_onevent();
  if (onevent_ == &::google::protobuf::internal::kEmptyString) {
    onevent_ = new ::std::string;
  }
  onevent_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProgressBar::mutable_onevent() {
  set_has_onevent();
  if (onevent_ == &::google::protobuf::internal::kEmptyString) {
    onevent_ = new ::std::string;
  }
  return onevent_;
}
inline ::std::string* ProgressBar::release_onevent() {
  clear_has_onevent();
  if (onevent_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = onevent_;
    onevent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProgressBar::set_allocated_onevent(::std::string* onevent) {
  if (onevent_ != &::google::protobuf::internal::kEmptyString) {
    delete onevent_;
  }
  if (onevent) {
    set_has_onevent();
    onevent_ = onevent;
  } else {
    clear_has_onevent();
    onevent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required float Duration = 18;
inline bool ProgressBar::has_duration() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void ProgressBar::set_has_duration() {
  _has_bits_[0] |= 0x00010000u;
}
inline void ProgressBar::clear_has_duration() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void ProgressBar::clear_duration() {
  duration_ = 0;
  clear_has_duration();
}
inline float ProgressBar::duration() const {
  return duration_;
}
inline void ProgressBar::set_duration(float value) {
  set_has_duration();
  duration_ = value;
}

// optional .Medusa.CoreProto.Editor.ProgressBar.ProgressBarType Type = 19;
inline bool ProgressBar::has_type() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void ProgressBar::set_has_type() {
  _has_bits_[0] |= 0x00020000u;
}
inline void ProgressBar::clear_has_type() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void ProgressBar::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::Medusa::CoreProto::Editor::ProgressBar_ProgressBarType ProgressBar::type() const {
  return static_cast< ::Medusa::CoreProto::Editor::ProgressBar_ProgressBarType >(type_);
}
inline void ProgressBar::set_type(::Medusa::CoreProto::Editor::ProgressBar_ProgressBarType value) {
  assert(::Medusa::CoreProto::Editor::ProgressBar_ProgressBarType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .Medusa.CoreProto.PointF Midpoint = 20;
inline bool ProgressBar::has_midpoint() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void ProgressBar::set_has_midpoint() {
  _has_bits_[0] |= 0x00040000u;
}
inline void ProgressBar::clear_has_midpoint() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void ProgressBar::clear_midpoint() {
  if (midpoint_ != NULL) midpoint_->::Medusa::CoreProto::PointF::Clear();
  clear_has_midpoint();
}
inline const ::Medusa::CoreProto::PointF& ProgressBar::midpoint() const {
  return midpoint_ != NULL ? *midpoint_ : *default_instance_->midpoint_;
}
inline ::Medusa::CoreProto::PointF* ProgressBar::mutable_midpoint() {
  set_has_midpoint();
  if (midpoint_ == NULL) midpoint_ = new ::Medusa::CoreProto::PointF;
  return midpoint_;
}
inline ::Medusa::CoreProto::PointF* ProgressBar::release_midpoint() {
  clear_has_midpoint();
  ::Medusa::CoreProto::PointF* temp = midpoint_;
  midpoint_ = NULL;
  return temp;
}
inline void ProgressBar::set_allocated_midpoint(::Medusa::CoreProto::PointF* midpoint) {
  delete midpoint_;
  midpoint_ = midpoint;
  if (midpoint) {
    set_has_midpoint();
  } else {
    clear_has_midpoint();
  }
}

// optional .Medusa.CoreProto.PointF ChangeRate = 21;
inline bool ProgressBar::has_changerate() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void ProgressBar::set_has_changerate() {
  _has_bits_[0] |= 0x00080000u;
}
inline void ProgressBar::clear_has_changerate() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void ProgressBar::clear_changerate() {
  if (changerate_ != NULL) changerate_->::Medusa::CoreProto::PointF::Clear();
  clear_has_changerate();
}
inline const ::Medusa::CoreProto::PointF& ProgressBar::changerate() const {
  return changerate_ != NULL ? *changerate_ : *default_instance_->changerate_;
}
inline ::Medusa::CoreProto::PointF* ProgressBar::mutable_changerate() {
  set_has_changerate();
  if (changerate_ == NULL) changerate_ = new ::Medusa::CoreProto::PointF;
  return changerate_;
}
inline ::Medusa::CoreProto::PointF* ProgressBar::release_changerate() {
  clear_has_changerate();
  ::Medusa::CoreProto::PointF* temp = changerate_;
  changerate_ = NULL;
  return temp;
}
inline void ProgressBar::set_allocated_changerate(::Medusa::CoreProto::PointF* changerate) {
  delete changerate_;
  changerate_ = changerate;
  if (changerate) {
    set_has_changerate();
  } else {
    clear_has_changerate();
  }
}

// optional .Medusa.CoreProto.RectF ScissorBox = 22;
inline bool ProgressBar::has_scissorbox() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void ProgressBar::set_has_scissorbox() {
  _has_bits_[0] |= 0x00100000u;
}
inline void ProgressBar::clear_has_scissorbox() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void ProgressBar::clear_scissorbox() {
  if (scissorbox_ != NULL) scissorbox_->::Medusa::CoreProto::RectF::Clear();
  clear_has_scissorbox();
}
inline const ::Medusa::CoreProto::RectF& ProgressBar::scissorbox() const {
  return scissorbox_ != NULL ? *scissorbox_ : *default_instance_->scissorbox_;
}
inline ::Medusa::CoreProto::RectF* ProgressBar::mutable_scissorbox() {
  set_has_scissorbox();
  if (scissorbox_ == NULL) scissorbox_ = new ::Medusa::CoreProto::RectF;
  return scissorbox_;
}
inline ::Medusa::CoreProto::RectF* ProgressBar::release_scissorbox() {
  clear_has_scissorbox();
  ::Medusa::CoreProto::RectF* temp = scissorbox_;
  scissorbox_ = NULL;
  return temp;
}
inline void ProgressBar::set_allocated_scissorbox(::Medusa::CoreProto::RectF* scissorbox) {
  delete scissorbox_;
  scissorbox_ = scissorbox;
  if (scissorbox) {
    set_has_scissorbox();
  } else {
    clear_has_scissorbox();
  }
}

// optional int32 RenderFlag = 50;
inline bool ProgressBar::has_renderflag() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void ProgressBar::set_has_renderflag() {
  _has_bits_[0] |= 0x00200000u;
}
inline void ProgressBar::clear_has_renderflag() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void ProgressBar::clear_renderflag() {
  renderflag_ = 0;
  clear_has_renderflag();
}
inline ::google::protobuf::int32 ProgressBar::renderflag() const {
  return renderflag_;
}
inline void ProgressBar::set_renderflag(::google::protobuf::int32 value) {
  set_has_renderflag();
  renderflag_ = value;
}

// optional int32 Tag = 51;
inline bool ProgressBar::has_tag() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void ProgressBar::set_has_tag() {
  _has_bits_[0] |= 0x00400000u;
}
inline void ProgressBar::clear_has_tag() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void ProgressBar::clear_tag() {
  tag_ = 0;
  clear_has_tag();
}
inline ::google::protobuf::int32 ProgressBar::tag() const {
  return tag_;
}
inline void ProgressBar::set_tag(::google::protobuf::int32 value) {
  set_has_tag();
  tag_ = value;
}

// optional bool IsLock = 201;
inline bool ProgressBar::has_islock() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void ProgressBar::set_has_islock() {
  _has_bits_[0] |= 0x00800000u;
}
inline void ProgressBar::clear_has_islock() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void ProgressBar::clear_islock() {
  islock_ = false;
  clear_has_islock();
}
inline bool ProgressBar::islock() const {
  return islock_;
}
inline void ProgressBar::set_islock(bool value) {
  set_has_islock();
  islock_ = value;
}

// optional bool IsHide = 202;
inline bool ProgressBar::has_ishide() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void ProgressBar::set_has_ishide() {
  _has_bits_[0] |= 0x01000000u;
}
inline void ProgressBar::clear_has_ishide() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void ProgressBar::clear_ishide() {
  ishide_ = false;
  clear_has_ishide();
}
inline bool ProgressBar::ishide() const {
  return ishide_;
}
inline void ProgressBar::set_ishide(bool value) {
  set_has_ishide();
  ishide_ = value;
}

// -------------------------------------------------------------------

// Trigger

// required string ID = 1;
inline bool Trigger::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Trigger::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Trigger::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Trigger::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& Trigger::id() const {
  return *id_;
}
inline void Trigger::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void Trigger::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void Trigger::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Trigger::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* Trigger::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Trigger::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string OnUpdate = 2;
inline bool Trigger::has_onupdate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Trigger::set_has_onupdate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Trigger::clear_has_onupdate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Trigger::clear_onupdate() {
  if (onupdate_ != &::google::protobuf::internal::kEmptyString) {
    onupdate_->clear();
  }
  clear_has_onupdate();
}
inline const ::std::string& Trigger::onupdate() const {
  return *onupdate_;
}
inline void Trigger::set_onupdate(const ::std::string& value) {
  set_has_onupdate();
  if (onupdate_ == &::google::protobuf::internal::kEmptyString) {
    onupdate_ = new ::std::string;
  }
  onupdate_->assign(value);
}
inline void Trigger::set_onupdate(const char* value) {
  set_has_onupdate();
  if (onupdate_ == &::google::protobuf::internal::kEmptyString) {
    onupdate_ = new ::std::string;
  }
  onupdate_->assign(value);
}
inline void Trigger::set_onupdate(const char* value, size_t size) {
  set_has_onupdate();
  if (onupdate_ == &::google::protobuf::internal::kEmptyString) {
    onupdate_ = new ::std::string;
  }
  onupdate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Trigger::mutable_onupdate() {
  set_has_onupdate();
  if (onupdate_ == &::google::protobuf::internal::kEmptyString) {
    onupdate_ = new ::std::string;
  }
  return onupdate_;
}
inline ::std::string* Trigger::release_onupdate() {
  clear_has_onupdate();
  if (onupdate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = onupdate_;
    onupdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Trigger::set_allocated_onupdate(::std::string* onupdate) {
  if (onupdate_ != &::google::protobuf::internal::kEmptyString) {
    delete onupdate_;
  }
  if (onupdate) {
    set_has_onupdate();
    onupdate_ = onupdate;
  } else {
    clear_has_onupdate();
    onupdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string OnEvent = 3;
inline bool Trigger::has_onevent() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Trigger::set_has_onevent() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Trigger::clear_has_onevent() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Trigger::clear_onevent() {
  if (onevent_ != &::google::protobuf::internal::kEmptyString) {
    onevent_->clear();
  }
  clear_has_onevent();
}
inline const ::std::string& Trigger::onevent() const {
  return *onevent_;
}
inline void Trigger::set_onevent(const ::std::string& value) {
  set_has_onevent();
  if (onevent_ == &::google::protobuf::internal::kEmptyString) {
    onevent_ = new ::std::string;
  }
  onevent_->assign(value);
}
inline void Trigger::set_onevent(const char* value) {
  set_has_onevent();
  if (onevent_ == &::google::protobuf::internal::kEmptyString) {
    onevent_ = new ::std::string;
  }
  onevent_->assign(value);
}
inline void Trigger::set_onevent(const char* value, size_t size) {
  set_has_onevent();
  if (onevent_ == &::google::protobuf::internal::kEmptyString) {
    onevent_ = new ::std::string;
  }
  onevent_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Trigger::mutable_onevent() {
  set_has_onevent();
  if (onevent_ == &::google::protobuf::internal::kEmptyString) {
    onevent_ = new ::std::string;
  }
  return onevent_;
}
inline ::std::string* Trigger::release_onevent() {
  clear_has_onevent();
  if (onevent_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = onevent_;
    onevent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Trigger::set_allocated_onevent(::std::string* onevent) {
  if (onevent_ != &::google::protobuf::internal::kEmptyString) {
    delete onevent_;
  }
  if (onevent) {
    set_has_onevent();
    onevent_ = onevent;
  } else {
    clear_has_onevent();
    onevent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .Medusa.CoreProto.SizeU Size = 4;
inline bool Trigger::has_size() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Trigger::set_has_size() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Trigger::clear_has_size() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Trigger::clear_size() {
  if (size_ != NULL) size_->::Medusa::CoreProto::SizeU::Clear();
  clear_has_size();
}
inline const ::Medusa::CoreProto::SizeU& Trigger::size() const {
  return size_ != NULL ? *size_ : *default_instance_->size_;
}
inline ::Medusa::CoreProto::SizeU* Trigger::mutable_size() {
  set_has_size();
  if (size_ == NULL) size_ = new ::Medusa::CoreProto::SizeU;
  return size_;
}
inline ::Medusa::CoreProto::SizeU* Trigger::release_size() {
  clear_has_size();
  ::Medusa::CoreProto::SizeU* temp = size_;
  size_ = NULL;
  return temp;
}
inline void Trigger::set_allocated_size(::Medusa::CoreProto::SizeU* size) {
  delete size_;
  size_ = size;
  if (size) {
    set_has_size();
  } else {
    clear_has_size();
  }
}

// optional .Medusa.CoreProto.PointF Position = 5;
inline bool Trigger::has_position() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Trigger::set_has_position() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Trigger::clear_has_position() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Trigger::clear_position() {
  if (position_ != NULL) position_->::Medusa::CoreProto::PointF::Clear();
  clear_has_position();
}
inline const ::Medusa::CoreProto::PointF& Trigger::position() const {
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::Medusa::CoreProto::PointF* Trigger::mutable_position() {
  set_has_position();
  if (position_ == NULL) position_ = new ::Medusa::CoreProto::PointF;
  return position_;
}
inline ::Medusa::CoreProto::PointF* Trigger::release_position() {
  clear_has_position();
  ::Medusa::CoreProto::PointF* temp = position_;
  position_ = NULL;
  return temp;
}
inline void Trigger::set_allocated_position(::Medusa::CoreProto::PointF* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
}

// optional bool IsProportionPoint = 6;
inline bool Trigger::has_isproportionpoint() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Trigger::set_has_isproportionpoint() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Trigger::clear_has_isproportionpoint() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Trigger::clear_isproportionpoint() {
  isproportionpoint_ = false;
  clear_has_isproportionpoint();
}
inline bool Trigger::isproportionpoint() const {
  return isproportionpoint_;
}
inline void Trigger::set_isproportionpoint(bool value) {
  set_has_isproportionpoint();
  isproportionpoint_ = value;
}

// optional float Parallax = 7;
inline bool Trigger::has_parallax() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Trigger::set_has_parallax() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Trigger::clear_has_parallax() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Trigger::clear_parallax() {
  parallax_ = 0;
  clear_has_parallax();
}
inline float Trigger::parallax() const {
  return parallax_;
}
inline void Trigger::set_parallax(float value) {
  set_has_parallax();
  parallax_ = value;
}

// optional int32 Tag = 51;
inline bool Trigger::has_tag() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Trigger::set_has_tag() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Trigger::clear_has_tag() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Trigger::clear_tag() {
  tag_ = 0;
  clear_has_tag();
}
inline ::google::protobuf::int32 Trigger::tag() const {
  return tag_;
}
inline void Trigger::set_tag(::google::protobuf::int32 value) {
  set_has_tag();
  tag_ = value;
}

// optional bool IsLock = 201;
inline bool Trigger::has_islock() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Trigger::set_has_islock() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Trigger::clear_has_islock() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Trigger::clear_islock() {
  islock_ = false;
  clear_has_islock();
}
inline bool Trigger::islock() const {
  return islock_;
}
inline void Trigger::set_islock(bool value) {
  set_has_islock();
  islock_ = value;
}

// optional bool IsHide = 202;
inline bool Trigger::has_ishide() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Trigger::set_has_ishide() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Trigger::clear_has_ishide() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Trigger::clear_ishide() {
  ishide_ = false;
  clear_has_ishide();
}
inline bool Trigger::ishide() const {
  return ishide_;
}
inline void Trigger::set_ishide(bool value) {
  set_has_ishide();
  ishide_ = value;
}

// -------------------------------------------------------------------

// TriggerRef

// required string ID = 1;
inline bool TriggerRef::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TriggerRef::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TriggerRef::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TriggerRef::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& TriggerRef::id() const {
  return *id_;
}
inline void TriggerRef::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void TriggerRef::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void TriggerRef::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TriggerRef::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* TriggerRef::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TriggerRef::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .Medusa.CoreProto.FileId ModelName = 2;
inline bool TriggerRef::has_modelname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TriggerRef::set_has_modelname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TriggerRef::clear_has_modelname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TriggerRef::clear_modelname() {
  if (modelname_ != NULL) modelname_->::Medusa::CoreProto::FileId::Clear();
  clear_has_modelname();
}
inline const ::Medusa::CoreProto::FileId& TriggerRef::modelname() const {
  return modelname_ != NULL ? *modelname_ : *default_instance_->modelname_;
}
inline ::Medusa::CoreProto::FileId* TriggerRef::mutable_modelname() {
  set_has_modelname();
  if (modelname_ == NULL) modelname_ = new ::Medusa::CoreProto::FileId;
  return modelname_;
}
inline ::Medusa::CoreProto::FileId* TriggerRef::release_modelname() {
  clear_has_modelname();
  ::Medusa::CoreProto::FileId* temp = modelname_;
  modelname_ = NULL;
  return temp;
}
inline void TriggerRef::set_allocated_modelname(::Medusa::CoreProto::FileId* modelname) {
  delete modelname_;
  modelname_ = modelname;
  if (modelname) {
    set_has_modelname();
  } else {
    clear_has_modelname();
  }
}

// optional .Medusa.CoreProto.SizeU Size = 3;
inline bool TriggerRef::has_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TriggerRef::set_has_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TriggerRef::clear_has_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TriggerRef::clear_size() {
  if (size_ != NULL) size_->::Medusa::CoreProto::SizeU::Clear();
  clear_has_size();
}
inline const ::Medusa::CoreProto::SizeU& TriggerRef::size() const {
  return size_ != NULL ? *size_ : *default_instance_->size_;
}
inline ::Medusa::CoreProto::SizeU* TriggerRef::mutable_size() {
  set_has_size();
  if (size_ == NULL) size_ = new ::Medusa::CoreProto::SizeU;
  return size_;
}
inline ::Medusa::CoreProto::SizeU* TriggerRef::release_size() {
  clear_has_size();
  ::Medusa::CoreProto::SizeU* temp = size_;
  size_ = NULL;
  return temp;
}
inline void TriggerRef::set_allocated_size(::Medusa::CoreProto::SizeU* size) {
  delete size_;
  size_ = size;
  if (size) {
    set_has_size();
  } else {
    clear_has_size();
  }
}

// optional .Medusa.CoreProto.PointF Position = 4;
inline bool TriggerRef::has_position() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TriggerRef::set_has_position() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TriggerRef::clear_has_position() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TriggerRef::clear_position() {
  if (position_ != NULL) position_->::Medusa::CoreProto::PointF::Clear();
  clear_has_position();
}
inline const ::Medusa::CoreProto::PointF& TriggerRef::position() const {
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::Medusa::CoreProto::PointF* TriggerRef::mutable_position() {
  set_has_position();
  if (position_ == NULL) position_ = new ::Medusa::CoreProto::PointF;
  return position_;
}
inline ::Medusa::CoreProto::PointF* TriggerRef::release_position() {
  clear_has_position();
  ::Medusa::CoreProto::PointF* temp = position_;
  position_ = NULL;
  return temp;
}
inline void TriggerRef::set_allocated_position(::Medusa::CoreProto::PointF* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
}

// optional bool IsProportionPoint = 5;
inline bool TriggerRef::has_isproportionpoint() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TriggerRef::set_has_isproportionpoint() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TriggerRef::clear_has_isproportionpoint() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TriggerRef::clear_isproportionpoint() {
  isproportionpoint_ = false;
  clear_has_isproportionpoint();
}
inline bool TriggerRef::isproportionpoint() const {
  return isproportionpoint_;
}
inline void TriggerRef::set_isproportionpoint(bool value) {
  set_has_isproportionpoint();
  isproportionpoint_ = value;
}

// optional float Parallax = 6;
inline bool TriggerRef::has_parallax() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TriggerRef::set_has_parallax() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TriggerRef::clear_has_parallax() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TriggerRef::clear_parallax() {
  parallax_ = 0;
  clear_has_parallax();
}
inline float TriggerRef::parallax() const {
  return parallax_;
}
inline void TriggerRef::set_parallax(float value) {
  set_has_parallax();
  parallax_ = value;
}

// optional int32 Tag = 51;
inline bool TriggerRef::has_tag() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TriggerRef::set_has_tag() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TriggerRef::clear_has_tag() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TriggerRef::clear_tag() {
  tag_ = 0;
  clear_has_tag();
}
inline ::google::protobuf::int32 TriggerRef::tag() const {
  return tag_;
}
inline void TriggerRef::set_tag(::google::protobuf::int32 value) {
  set_has_tag();
  tag_ = value;
}

// optional bool IsLock = 201;
inline bool TriggerRef::has_islock() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TriggerRef::set_has_islock() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TriggerRef::clear_has_islock() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TriggerRef::clear_islock() {
  islock_ = false;
  clear_has_islock();
}
inline bool TriggerRef::islock() const {
  return islock_;
}
inline void TriggerRef::set_islock(bool value) {
  set_has_islock();
  islock_ = value;
}

// optional bool IsHide = 202;
inline bool TriggerRef::has_ishide() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TriggerRef::set_has_ishide() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TriggerRef::clear_has_ishide() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TriggerRef::clear_ishide() {
  ishide_ = false;
  clear_has_ishide();
}
inline bool TriggerRef::ishide() const {
  return ishide_;
}
inline void TriggerRef::set_ishide(bool value) {
  set_has_ishide();
  ishide_ = value;
}

// -------------------------------------------------------------------

// LayerRef

// required string ID = 1;
inline bool LayerRef::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LayerRef::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LayerRef::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LayerRef::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& LayerRef::id() const {
  return *id_;
}
inline void LayerRef::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void LayerRef::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void LayerRef::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LayerRef::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* LayerRef::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LayerRef::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .Medusa.CoreProto.FileId ModelName = 2;
inline bool LayerRef::has_modelname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LayerRef::set_has_modelname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LayerRef::clear_has_modelname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LayerRef::clear_modelname() {
  if (modelname_ != NULL) modelname_->::Medusa::CoreProto::FileId::Clear();
  clear_has_modelname();
}
inline const ::Medusa::CoreProto::FileId& LayerRef::modelname() const {
  return modelname_ != NULL ? *modelname_ : *default_instance_->modelname_;
}
inline ::Medusa::CoreProto::FileId* LayerRef::mutable_modelname() {
  set_has_modelname();
  if (modelname_ == NULL) modelname_ = new ::Medusa::CoreProto::FileId;
  return modelname_;
}
inline ::Medusa::CoreProto::FileId* LayerRef::release_modelname() {
  clear_has_modelname();
  ::Medusa::CoreProto::FileId* temp = modelname_;
  modelname_ = NULL;
  return temp;
}
inline void LayerRef::set_allocated_modelname(::Medusa::CoreProto::FileId* modelname) {
  delete modelname_;
  modelname_ = modelname;
  if (modelname) {
    set_has_modelname();
  } else {
    clear_has_modelname();
  }
}

// required .Medusa.CoreProto.PointF Position = 3;
inline bool LayerRef::has_position() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LayerRef::set_has_position() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LayerRef::clear_has_position() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LayerRef::clear_position() {
  if (position_ != NULL) position_->::Medusa::CoreProto::PointF::Clear();
  clear_has_position();
}
inline const ::Medusa::CoreProto::PointF& LayerRef::position() const {
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::Medusa::CoreProto::PointF* LayerRef::mutable_position() {
  set_has_position();
  if (position_ == NULL) position_ = new ::Medusa::CoreProto::PointF;
  return position_;
}
inline ::Medusa::CoreProto::PointF* LayerRef::release_position() {
  clear_has_position();
  ::Medusa::CoreProto::PointF* temp = position_;
  position_ = NULL;
  return temp;
}
inline void LayerRef::set_allocated_position(::Medusa::CoreProto::PointF* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
}

// required bool IsProportionPoint = 4;
inline bool LayerRef::has_isproportionpoint() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LayerRef::set_has_isproportionpoint() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LayerRef::clear_has_isproportionpoint() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LayerRef::clear_isproportionpoint() {
  isproportionpoint_ = false;
  clear_has_isproportionpoint();
}
inline bool LayerRef::isproportionpoint() const {
  return isproportionpoint_;
}
inline void LayerRef::set_isproportionpoint(bool value) {
  set_has_isproportionpoint();
  isproportionpoint_ = value;
}

// required .Medusa.CoreProto.PointF Anchor = 5;
inline bool LayerRef::has_anchor() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LayerRef::set_has_anchor() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LayerRef::clear_has_anchor() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LayerRef::clear_anchor() {
  if (anchor_ != NULL) anchor_->::Medusa::CoreProto::PointF::Clear();
  clear_has_anchor();
}
inline const ::Medusa::CoreProto::PointF& LayerRef::anchor() const {
  return anchor_ != NULL ? *anchor_ : *default_instance_->anchor_;
}
inline ::Medusa::CoreProto::PointF* LayerRef::mutable_anchor() {
  set_has_anchor();
  if (anchor_ == NULL) anchor_ = new ::Medusa::CoreProto::PointF;
  return anchor_;
}
inline ::Medusa::CoreProto::PointF* LayerRef::release_anchor() {
  clear_has_anchor();
  ::Medusa::CoreProto::PointF* temp = anchor_;
  anchor_ = NULL;
  return temp;
}
inline void LayerRef::set_allocated_anchor(::Medusa::CoreProto::PointF* anchor) {
  delete anchor_;
  anchor_ = anchor;
  if (anchor) {
    set_has_anchor();
  } else {
    clear_has_anchor();
  }
}

// required int32 ZOrder = 6;
inline bool LayerRef::has_zorder() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LayerRef::set_has_zorder() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LayerRef::clear_has_zorder() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LayerRef::clear_zorder() {
  zorder_ = 0;
  clear_has_zorder();
}
inline ::google::protobuf::int32 LayerRef::zorder() const {
  return zorder_;
}
inline void LayerRef::set_zorder(::google::protobuf::int32 value) {
  set_has_zorder();
  zorder_ = value;
}

// optional float Rotation = 7;
inline bool LayerRef::has_rotation() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LayerRef::set_has_rotation() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LayerRef::clear_has_rotation() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LayerRef::clear_rotation() {
  rotation_ = 0;
  clear_has_rotation();
}
inline float LayerRef::rotation() const {
  return rotation_;
}
inline void LayerRef::set_rotation(float value) {
  set_has_rotation();
  rotation_ = value;
}

// optional .Medusa.CoreProto.ScaleF Scale = 8;
inline bool LayerRef::has_scale() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void LayerRef::set_has_scale() {
  _has_bits_[0] |= 0x00000080u;
}
inline void LayerRef::clear_has_scale() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void LayerRef::clear_scale() {
  if (scale_ != NULL) scale_->::Medusa::CoreProto::ScaleF::Clear();
  clear_has_scale();
}
inline const ::Medusa::CoreProto::ScaleF& LayerRef::scale() const {
  return scale_ != NULL ? *scale_ : *default_instance_->scale_;
}
inline ::Medusa::CoreProto::ScaleF* LayerRef::mutable_scale() {
  set_has_scale();
  if (scale_ == NULL) scale_ = new ::Medusa::CoreProto::ScaleF;
  return scale_;
}
inline ::Medusa::CoreProto::ScaleF* LayerRef::release_scale() {
  clear_has_scale();
  ::Medusa::CoreProto::ScaleF* temp = scale_;
  scale_ = NULL;
  return temp;
}
inline void LayerRef::set_allocated_scale(::Medusa::CoreProto::ScaleF* scale) {
  delete scale_;
  scale_ = scale;
  if (scale) {
    set_has_scale();
  } else {
    clear_has_scale();
  }
}

// optional bool IsFilpX = 9;
inline bool LayerRef::has_isfilpx() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void LayerRef::set_has_isfilpx() {
  _has_bits_[0] |= 0x00000100u;
}
inline void LayerRef::clear_has_isfilpx() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void LayerRef::clear_isfilpx() {
  isfilpx_ = false;
  clear_has_isfilpx();
}
inline bool LayerRef::isfilpx() const {
  return isfilpx_;
}
inline void LayerRef::set_isfilpx(bool value) {
  set_has_isfilpx();
  isfilpx_ = value;
}

// optional bool IsFilpY = 10;
inline bool LayerRef::has_isfilpy() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void LayerRef::set_has_isfilpy() {
  _has_bits_[0] |= 0x00000200u;
}
inline void LayerRef::clear_has_isfilpy() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void LayerRef::clear_isfilpy() {
  isfilpy_ = false;
  clear_has_isfilpy();
}
inline bool LayerRef::isfilpy() const {
  return isfilpy_;
}
inline void LayerRef::set_isfilpy(bool value) {
  set_has_isfilpy();
  isfilpy_ = value;
}

// required bool IsVisible = 11;
inline bool LayerRef::has_isvisible() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void LayerRef::set_has_isvisible() {
  _has_bits_[0] |= 0x00000400u;
}
inline void LayerRef::clear_has_isvisible() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void LayerRef::clear_isvisible() {
  isvisible_ = false;
  clear_has_isvisible();
}
inline bool LayerRef::isvisible() const {
  return isvisible_;
}
inline void LayerRef::set_isvisible(bool value) {
  set_has_isvisible();
  isvisible_ = value;
}

// required float Parallax = 12;
inline bool LayerRef::has_parallax() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void LayerRef::set_has_parallax() {
  _has_bits_[0] |= 0x00000800u;
}
inline void LayerRef::clear_has_parallax() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void LayerRef::clear_parallax() {
  parallax_ = 0;
  clear_has_parallax();
}
inline float LayerRef::parallax() const {
  return parallax_;
}
inline void LayerRef::set_parallax(float value) {
  set_has_parallax();
  parallax_ = value;
}

// optional int32 Tag = 51;
inline bool LayerRef::has_tag() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void LayerRef::set_has_tag() {
  _has_bits_[0] |= 0x00001000u;
}
inline void LayerRef::clear_has_tag() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void LayerRef::clear_tag() {
  tag_ = 0;
  clear_has_tag();
}
inline ::google::protobuf::int32 LayerRef::tag() const {
  return tag_;
}
inline void LayerRef::set_tag(::google::protobuf::int32 value) {
  set_has_tag();
  tag_ = value;
}

// optional bool IsLock = 201;
inline bool LayerRef::has_islock() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void LayerRef::set_has_islock() {
  _has_bits_[0] |= 0x00002000u;
}
inline void LayerRef::clear_has_islock() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void LayerRef::clear_islock() {
  islock_ = false;
  clear_has_islock();
}
inline bool LayerRef::islock() const {
  return islock_;
}
inline void LayerRef::set_islock(bool value) {
  set_has_islock();
  islock_ = value;
}

// optional bool IsHide = 202;
inline bool LayerRef::has_ishide() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void LayerRef::set_has_ishide() {
  _has_bits_[0] |= 0x00004000u;
}
inline void LayerRef::clear_has_ishide() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void LayerRef::clear_ishide() {
  ishide_ = false;
  clear_has_ishide();
}
inline bool LayerRef::ishide() const {
  return ishide_;
}
inline void LayerRef::set_ishide(bool value) {
  set_has_ishide();
  ishide_ = value;
}

// -------------------------------------------------------------------

// ListBox

// required string ID = 1;
inline bool ListBox::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ListBox::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ListBox::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ListBox::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& ListBox::id() const {
  return *id_;
}
inline void ListBox::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void ListBox::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void ListBox::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ListBox::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* ListBox::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ListBox::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .Medusa.CoreProto.FileId ItemFileID = 2;
inline bool ListBox::has_itemfileid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ListBox::set_has_itemfileid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ListBox::clear_has_itemfileid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ListBox::clear_itemfileid() {
  if (itemfileid_ != NULL) itemfileid_->::Medusa::CoreProto::FileId::Clear();
  clear_has_itemfileid();
}
inline const ::Medusa::CoreProto::FileId& ListBox::itemfileid() const {
  return itemfileid_ != NULL ? *itemfileid_ : *default_instance_->itemfileid_;
}
inline ::Medusa::CoreProto::FileId* ListBox::mutable_itemfileid() {
  set_has_itemfileid();
  if (itemfileid_ == NULL) itemfileid_ = new ::Medusa::CoreProto::FileId;
  return itemfileid_;
}
inline ::Medusa::CoreProto::FileId* ListBox::release_itemfileid() {
  clear_has_itemfileid();
  ::Medusa::CoreProto::FileId* temp = itemfileid_;
  itemfileid_ = NULL;
  return temp;
}
inline void ListBox::set_allocated_itemfileid(::Medusa::CoreProto::FileId* itemfileid) {
  delete itemfileid_;
  itemfileid_ = itemfileid;
  if (itemfileid) {
    set_has_itemfileid();
  } else {
    clear_has_itemfileid();
  }
}

// required .Medusa.CoreProto.SizeU Size = 3;
inline bool ListBox::has_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ListBox::set_has_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ListBox::clear_has_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ListBox::clear_size() {
  if (size_ != NULL) size_->::Medusa::CoreProto::SizeU::Clear();
  clear_has_size();
}
inline const ::Medusa::CoreProto::SizeU& ListBox::size() const {
  return size_ != NULL ? *size_ : *default_instance_->size_;
}
inline ::Medusa::CoreProto::SizeU* ListBox::mutable_size() {
  set_has_size();
  if (size_ == NULL) size_ = new ::Medusa::CoreProto::SizeU;
  return size_;
}
inline ::Medusa::CoreProto::SizeU* ListBox::release_size() {
  clear_has_size();
  ::Medusa::CoreProto::SizeU* temp = size_;
  size_ = NULL;
  return temp;
}
inline void ListBox::set_allocated_size(::Medusa::CoreProto::SizeU* size) {
  delete size_;
  size_ = size;
  if (size) {
    set_has_size();
  } else {
    clear_has_size();
  }
}

// required .Medusa.CoreProto.PointF Position = 4;
inline bool ListBox::has_position() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ListBox::set_has_position() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ListBox::clear_has_position() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ListBox::clear_position() {
  if (position_ != NULL) position_->::Medusa::CoreProto::PointF::Clear();
  clear_has_position();
}
inline const ::Medusa::CoreProto::PointF& ListBox::position() const {
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::Medusa::CoreProto::PointF* ListBox::mutable_position() {
  set_has_position();
  if (position_ == NULL) position_ = new ::Medusa::CoreProto::PointF;
  return position_;
}
inline ::Medusa::CoreProto::PointF* ListBox::release_position() {
  clear_has_position();
  ::Medusa::CoreProto::PointF* temp = position_;
  position_ = NULL;
  return temp;
}
inline void ListBox::set_allocated_position(::Medusa::CoreProto::PointF* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
}

// required bool IsProportionPoint = 5;
inline bool ListBox::has_isproportionpoint() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ListBox::set_has_isproportionpoint() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ListBox::clear_has_isproportionpoint() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ListBox::clear_isproportionpoint() {
  isproportionpoint_ = false;
  clear_has_isproportionpoint();
}
inline bool ListBox::isproportionpoint() const {
  return isproportionpoint_;
}
inline void ListBox::set_isproportionpoint(bool value) {
  set_has_isproportionpoint();
  isproportionpoint_ = value;
}

// required .Medusa.CoreProto.PointF Anchor = 6;
inline bool ListBox::has_anchor() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ListBox::set_has_anchor() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ListBox::clear_has_anchor() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ListBox::clear_anchor() {
  if (anchor_ != NULL) anchor_->::Medusa::CoreProto::PointF::Clear();
  clear_has_anchor();
}
inline const ::Medusa::CoreProto::PointF& ListBox::anchor() const {
  return anchor_ != NULL ? *anchor_ : *default_instance_->anchor_;
}
inline ::Medusa::CoreProto::PointF* ListBox::mutable_anchor() {
  set_has_anchor();
  if (anchor_ == NULL) anchor_ = new ::Medusa::CoreProto::PointF;
  return anchor_;
}
inline ::Medusa::CoreProto::PointF* ListBox::release_anchor() {
  clear_has_anchor();
  ::Medusa::CoreProto::PointF* temp = anchor_;
  anchor_ = NULL;
  return temp;
}
inline void ListBox::set_allocated_anchor(::Medusa::CoreProto::PointF* anchor) {
  delete anchor_;
  anchor_ = anchor;
  if (anchor) {
    set_has_anchor();
  } else {
    clear_has_anchor();
  }
}

// required int32 ZOrder = 7;
inline bool ListBox::has_zorder() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ListBox::set_has_zorder() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ListBox::clear_has_zorder() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ListBox::clear_zorder() {
  zorder_ = 0;
  clear_has_zorder();
}
inline ::google::protobuf::int32 ListBox::zorder() const {
  return zorder_;
}
inline void ListBox::set_zorder(::google::protobuf::int32 value) {
  set_has_zorder();
  zorder_ = value;
}

// optional float Rotation = 8;
inline bool ListBox::has_rotation() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ListBox::set_has_rotation() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ListBox::clear_has_rotation() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ListBox::clear_rotation() {
  rotation_ = 0;
  clear_has_rotation();
}
inline float ListBox::rotation() const {
  return rotation_;
}
inline void ListBox::set_rotation(float value) {
  set_has_rotation();
  rotation_ = value;
}

// optional .Medusa.CoreProto.ScaleF Scale = 9;
inline bool ListBox::has_scale() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ListBox::set_has_scale() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ListBox::clear_has_scale() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ListBox::clear_scale() {
  if (scale_ != NULL) scale_->::Medusa::CoreProto::ScaleF::Clear();
  clear_has_scale();
}
inline const ::Medusa::CoreProto::ScaleF& ListBox::scale() const {
  return scale_ != NULL ? *scale_ : *default_instance_->scale_;
}
inline ::Medusa::CoreProto::ScaleF* ListBox::mutable_scale() {
  set_has_scale();
  if (scale_ == NULL) scale_ = new ::Medusa::CoreProto::ScaleF;
  return scale_;
}
inline ::Medusa::CoreProto::ScaleF* ListBox::release_scale() {
  clear_has_scale();
  ::Medusa::CoreProto::ScaleF* temp = scale_;
  scale_ = NULL;
  return temp;
}
inline void ListBox::set_allocated_scale(::Medusa::CoreProto::ScaleF* scale) {
  delete scale_;
  scale_ = scale;
  if (scale) {
    set_has_scale();
  } else {
    clear_has_scale();
  }
}

// required bool IsVisible = 12;
inline bool ListBox::has_isvisible() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ListBox::set_has_isvisible() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ListBox::clear_has_isvisible() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ListBox::clear_isvisible() {
  isvisible_ = false;
  clear_has_isvisible();
}
inline bool ListBox::isvisible() const {
  return isvisible_;
}
inline void ListBox::set_isvisible(bool value) {
  set_has_isvisible();
  isvisible_ = value;
}

// required .Medusa.CoreProto.Editor.ListBox.ScorllDirection Direction = 13;
inline bool ListBox::has_direction() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ListBox::set_has_direction() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ListBox::clear_has_direction() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ListBox::clear_direction() {
  direction_ = -1;
  clear_has_direction();
}
inline ::Medusa::CoreProto::Editor::ListBox_ScorllDirection ListBox::direction() const {
  return static_cast< ::Medusa::CoreProto::Editor::ListBox_ScorllDirection >(direction_);
}
inline void ListBox::set_direction(::Medusa::CoreProto::Editor::ListBox_ScorllDirection value) {
  assert(::Medusa::CoreProto::Editor::ListBox_ScorllDirection_IsValid(value));
  set_has_direction();
  direction_ = value;
}

// optional .Medusa.CoreProto.Editor.ListBox.VerticalOrder OrderType = 14;
inline bool ListBox::has_ordertype() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ListBox::set_has_ordertype() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ListBox::clear_has_ordertype() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ListBox::clear_ordertype() {
  ordertype_ = 0;
  clear_has_ordertype();
}
inline ::Medusa::CoreProto::Editor::ListBox_VerticalOrder ListBox::ordertype() const {
  return static_cast< ::Medusa::CoreProto::Editor::ListBox_VerticalOrder >(ordertype_);
}
inline void ListBox::set_ordertype(::Medusa::CoreProto::Editor::ListBox_VerticalOrder value) {
  assert(::Medusa::CoreProto::Editor::ListBox_VerticalOrder_IsValid(value));
  set_has_ordertype();
  ordertype_ = value;
}

// optional string OnLoad = 15;
inline bool ListBox::has_onload() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ListBox::set_has_onload() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ListBox::clear_has_onload() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ListBox::clear_onload() {
  if (onload_ != &::google::protobuf::internal::kEmptyString) {
    onload_->clear();
  }
  clear_has_onload();
}
inline const ::std::string& ListBox::onload() const {
  return *onload_;
}
inline void ListBox::set_onload(const ::std::string& value) {
  set_has_onload();
  if (onload_ == &::google::protobuf::internal::kEmptyString) {
    onload_ = new ::std::string;
  }
  onload_->assign(value);
}
inline void ListBox::set_onload(const char* value) {
  set_has_onload();
  if (onload_ == &::google::protobuf::internal::kEmptyString) {
    onload_ = new ::std::string;
  }
  onload_->assign(value);
}
inline void ListBox::set_onload(const char* value, size_t size) {
  set_has_onload();
  if (onload_ == &::google::protobuf::internal::kEmptyString) {
    onload_ = new ::std::string;
  }
  onload_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ListBox::mutable_onload() {
  set_has_onload();
  if (onload_ == &::google::protobuf::internal::kEmptyString) {
    onload_ = new ::std::string;
  }
  return onload_;
}
inline ::std::string* ListBox::release_onload() {
  clear_has_onload();
  if (onload_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = onload_;
    onload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ListBox::set_allocated_onload(::std::string* onload) {
  if (onload_ != &::google::protobuf::internal::kEmptyString) {
    delete onload_;
  }
  if (onload) {
    set_has_onload();
    onload_ = onload;
  } else {
    clear_has_onload();
    onload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string OnShow = 16;
inline bool ListBox::has_onshow() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ListBox::set_has_onshow() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ListBox::clear_has_onshow() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ListBox::clear_onshow() {
  if (onshow_ != &::google::protobuf::internal::kEmptyString) {
    onshow_->clear();
  }
  clear_has_onshow();
}
inline const ::std::string& ListBox::onshow() const {
  return *onshow_;
}
inline void ListBox::set_onshow(const ::std::string& value) {
  set_has_onshow();
  if (onshow_ == &::google::protobuf::internal::kEmptyString) {
    onshow_ = new ::std::string;
  }
  onshow_->assign(value);
}
inline void ListBox::set_onshow(const char* value) {
  set_has_onshow();
  if (onshow_ == &::google::protobuf::internal::kEmptyString) {
    onshow_ = new ::std::string;
  }
  onshow_->assign(value);
}
inline void ListBox::set_onshow(const char* value, size_t size) {
  set_has_onshow();
  if (onshow_ == &::google::protobuf::internal::kEmptyString) {
    onshow_ = new ::std::string;
  }
  onshow_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ListBox::mutable_onshow() {
  set_has_onshow();
  if (onshow_ == &::google::protobuf::internal::kEmptyString) {
    onshow_ = new ::std::string;
  }
  return onshow_;
}
inline ::std::string* ListBox::release_onshow() {
  clear_has_onshow();
  if (onshow_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = onshow_;
    onshow_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ListBox::set_allocated_onshow(::std::string* onshow) {
  if (onshow_ != &::google::protobuf::internal::kEmptyString) {
    delete onshow_;
  }
  if (onshow) {
    set_has_onshow();
    onshow_ = onshow;
  } else {
    clear_has_onshow();
    onshow_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string OnHide = 17;
inline bool ListBox::has_onhide() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void ListBox::set_has_onhide() {
  _has_bits_[0] |= 0x00004000u;
}
inline void ListBox::clear_has_onhide() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void ListBox::clear_onhide() {
  if (onhide_ != &::google::protobuf::internal::kEmptyString) {
    onhide_->clear();
  }
  clear_has_onhide();
}
inline const ::std::string& ListBox::onhide() const {
  return *onhide_;
}
inline void ListBox::set_onhide(const ::std::string& value) {
  set_has_onhide();
  if (onhide_ == &::google::protobuf::internal::kEmptyString) {
    onhide_ = new ::std::string;
  }
  onhide_->assign(value);
}
inline void ListBox::set_onhide(const char* value) {
  set_has_onhide();
  if (onhide_ == &::google::protobuf::internal::kEmptyString) {
    onhide_ = new ::std::string;
  }
  onhide_->assign(value);
}
inline void ListBox::set_onhide(const char* value, size_t size) {
  set_has_onhide();
  if (onhide_ == &::google::protobuf::internal::kEmptyString) {
    onhide_ = new ::std::string;
  }
  onhide_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ListBox::mutable_onhide() {
  set_has_onhide();
  if (onhide_ == &::google::protobuf::internal::kEmptyString) {
    onhide_ = new ::std::string;
  }
  return onhide_;
}
inline ::std::string* ListBox::release_onhide() {
  clear_has_onhide();
  if (onhide_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = onhide_;
    onhide_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ListBox::set_allocated_onhide(::std::string* onhide) {
  if (onhide_ != &::google::protobuf::internal::kEmptyString) {
    delete onhide_;
  }
  if (onhide) {
    set_has_onhide();
    onhide_ = onhide;
  } else {
    clear_has_onhide();
    onhide_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string OnClosed = 18;
inline bool ListBox::has_onclosed() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void ListBox::set_has_onclosed() {
  _has_bits_[0] |= 0x00008000u;
}
inline void ListBox::clear_has_onclosed() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void ListBox::clear_onclosed() {
  if (onclosed_ != &::google::protobuf::internal::kEmptyString) {
    onclosed_->clear();
  }
  clear_has_onclosed();
}
inline const ::std::string& ListBox::onclosed() const {
  return *onclosed_;
}
inline void ListBox::set_onclosed(const ::std::string& value) {
  set_has_onclosed();
  if (onclosed_ == &::google::protobuf::internal::kEmptyString) {
    onclosed_ = new ::std::string;
  }
  onclosed_->assign(value);
}
inline void ListBox::set_onclosed(const char* value) {
  set_has_onclosed();
  if (onclosed_ == &::google::protobuf::internal::kEmptyString) {
    onclosed_ = new ::std::string;
  }
  onclosed_->assign(value);
}
inline void ListBox::set_onclosed(const char* value, size_t size) {
  set_has_onclosed();
  if (onclosed_ == &::google::protobuf::internal::kEmptyString) {
    onclosed_ = new ::std::string;
  }
  onclosed_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ListBox::mutable_onclosed() {
  set_has_onclosed();
  if (onclosed_ == &::google::protobuf::internal::kEmptyString) {
    onclosed_ = new ::std::string;
  }
  return onclosed_;
}
inline ::std::string* ListBox::release_onclosed() {
  clear_has_onclosed();
  if (onclosed_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = onclosed_;
    onclosed_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ListBox::set_allocated_onclosed(::std::string* onclosed) {
  if (onclosed_ != &::google::protobuf::internal::kEmptyString) {
    delete onclosed_;
  }
  if (onclosed) {
    set_has_onclosed();
    onclosed_ = onclosed;
  } else {
    clear_has_onclosed();
    onclosed_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string OnUpdate = 19;
inline bool ListBox::has_onupdate() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void ListBox::set_has_onupdate() {
  _has_bits_[0] |= 0x00010000u;
}
inline void ListBox::clear_has_onupdate() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void ListBox::clear_onupdate() {
  if (onupdate_ != &::google::protobuf::internal::kEmptyString) {
    onupdate_->clear();
  }
  clear_has_onupdate();
}
inline const ::std::string& ListBox::onupdate() const {
  return *onupdate_;
}
inline void ListBox::set_onupdate(const ::std::string& value) {
  set_has_onupdate();
  if (onupdate_ == &::google::protobuf::internal::kEmptyString) {
    onupdate_ = new ::std::string;
  }
  onupdate_->assign(value);
}
inline void ListBox::set_onupdate(const char* value) {
  set_has_onupdate();
  if (onupdate_ == &::google::protobuf::internal::kEmptyString) {
    onupdate_ = new ::std::string;
  }
  onupdate_->assign(value);
}
inline void ListBox::set_onupdate(const char* value, size_t size) {
  set_has_onupdate();
  if (onupdate_ == &::google::protobuf::internal::kEmptyString) {
    onupdate_ = new ::std::string;
  }
  onupdate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ListBox::mutable_onupdate() {
  set_has_onupdate();
  if (onupdate_ == &::google::protobuf::internal::kEmptyString) {
    onupdate_ = new ::std::string;
  }
  return onupdate_;
}
inline ::std::string* ListBox::release_onupdate() {
  clear_has_onupdate();
  if (onupdate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = onupdate_;
    onupdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ListBox::set_allocated_onupdate(::std::string* onupdate) {
  if (onupdate_ != &::google::protobuf::internal::kEmptyString) {
    delete onupdate_;
  }
  if (onupdate) {
    set_has_onupdate();
    onupdate_ = onupdate;
  } else {
    clear_has_onupdate();
    onupdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string OnEvent = 20;
inline bool ListBox::has_onevent() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void ListBox::set_has_onevent() {
  _has_bits_[0] |= 0x00020000u;
}
inline void ListBox::clear_has_onevent() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void ListBox::clear_onevent() {
  if (onevent_ != &::google::protobuf::internal::kEmptyString) {
    onevent_->clear();
  }
  clear_has_onevent();
}
inline const ::std::string& ListBox::onevent() const {
  return *onevent_;
}
inline void ListBox::set_onevent(const ::std::string& value) {
  set_has_onevent();
  if (onevent_ == &::google::protobuf::internal::kEmptyString) {
    onevent_ = new ::std::string;
  }
  onevent_->assign(value);
}
inline void ListBox::set_onevent(const char* value) {
  set_has_onevent();
  if (onevent_ == &::google::protobuf::internal::kEmptyString) {
    onevent_ = new ::std::string;
  }
  onevent_->assign(value);
}
inline void ListBox::set_onevent(const char* value, size_t size) {
  set_has_onevent();
  if (onevent_ == &::google::protobuf::internal::kEmptyString) {
    onevent_ = new ::std::string;
  }
  onevent_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ListBox::mutable_onevent() {
  set_has_onevent();
  if (onevent_ == &::google::protobuf::internal::kEmptyString) {
    onevent_ = new ::std::string;
  }
  return onevent_;
}
inline ::std::string* ListBox::release_onevent() {
  clear_has_onevent();
  if (onevent_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = onevent_;
    onevent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ListBox::set_allocated_onevent(::std::string* onevent) {
  if (onevent_ != &::google::protobuf::internal::kEmptyString) {
    delete onevent_;
  }
  if (onevent) {
    set_has_onevent();
    onevent_ = onevent;
  } else {
    clear_has_onevent();
    onevent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .Medusa.CoreProto.RectF ScissorBox = 21;
inline bool ListBox::has_scissorbox() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void ListBox::set_has_scissorbox() {
  _has_bits_[0] |= 0x00040000u;
}
inline void ListBox::clear_has_scissorbox() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void ListBox::clear_scissorbox() {
  if (scissorbox_ != NULL) scissorbox_->::Medusa::CoreProto::RectF::Clear();
  clear_has_scissorbox();
}
inline const ::Medusa::CoreProto::RectF& ListBox::scissorbox() const {
  return scissorbox_ != NULL ? *scissorbox_ : *default_instance_->scissorbox_;
}
inline ::Medusa::CoreProto::RectF* ListBox::mutable_scissorbox() {
  set_has_scissorbox();
  if (scissorbox_ == NULL) scissorbox_ = new ::Medusa::CoreProto::RectF;
  return scissorbox_;
}
inline ::Medusa::CoreProto::RectF* ListBox::release_scissorbox() {
  clear_has_scissorbox();
  ::Medusa::CoreProto::RectF* temp = scissorbox_;
  scissorbox_ = NULL;
  return temp;
}
inline void ListBox::set_allocated_scissorbox(::Medusa::CoreProto::RectF* scissorbox) {
  delete scissorbox_;
  scissorbox_ = scissorbox;
  if (scissorbox) {
    set_has_scissorbox();
  } else {
    clear_has_scissorbox();
  }
}

// optional int32 Tag = 51;
inline bool ListBox::has_tag() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void ListBox::set_has_tag() {
  _has_bits_[0] |= 0x00080000u;
}
inline void ListBox::clear_has_tag() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void ListBox::clear_tag() {
  tag_ = 0;
  clear_has_tag();
}
inline ::google::protobuf::int32 ListBox::tag() const {
  return tag_;
}
inline void ListBox::set_tag(::google::protobuf::int32 value) {
  set_has_tag();
  tag_ = value;
}

// optional bool IsLock = 201;
inline bool ListBox::has_islock() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void ListBox::set_has_islock() {
  _has_bits_[0] |= 0x00100000u;
}
inline void ListBox::clear_has_islock() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void ListBox::clear_islock() {
  islock_ = false;
  clear_has_islock();
}
inline bool ListBox::islock() const {
  return islock_;
}
inline void ListBox::set_islock(bool value) {
  set_has_islock();
  islock_ = value;
}

// optional bool IsHide = 202;
inline bool ListBox::has_ishide() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void ListBox::set_has_ishide() {
  _has_bits_[0] |= 0x00200000u;
}
inline void ListBox::clear_has_ishide() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void ListBox::clear_ishide() {
  ishide_ = false;
  clear_has_ishide();
}
inline bool ListBox::ishide() const {
  return ishide_;
}
inline void ListBox::set_ishide(bool value) {
  set_has_ishide();
  ishide_ = value;
}

// -------------------------------------------------------------------

// Layer

// required string ID = 1;
inline bool Layer::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Layer::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Layer::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Layer::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& Layer::id() const {
  return *id_;
}
inline void Layer::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void Layer::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void Layer::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Layer::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* Layer::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Layer::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .Medusa.CoreProto.SizeU Size = 2;
inline bool Layer::has_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Layer::set_has_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Layer::clear_has_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Layer::clear_size() {
  if (size_ != NULL) size_->::Medusa::CoreProto::SizeU::Clear();
  clear_has_size();
}
inline const ::Medusa::CoreProto::SizeU& Layer::size() const {
  return size_ != NULL ? *size_ : *default_instance_->size_;
}
inline ::Medusa::CoreProto::SizeU* Layer::mutable_size() {
  set_has_size();
  if (size_ == NULL) size_ = new ::Medusa::CoreProto::SizeU;
  return size_;
}
inline ::Medusa::CoreProto::SizeU* Layer::release_size() {
  clear_has_size();
  ::Medusa::CoreProto::SizeU* temp = size_;
  size_ = NULL;
  return temp;
}
inline void Layer::set_allocated_size(::Medusa::CoreProto::SizeU* size) {
  delete size_;
  size_ = size;
  if (size) {
    set_has_size();
  } else {
    clear_has_size();
  }
}

// repeated .Medusa.CoreProto.Editor.Image Images = 3;
inline int Layer::images_size() const {
  return images_.size();
}
inline void Layer::clear_images() {
  images_.Clear();
}
inline const ::Medusa::CoreProto::Editor::Image& Layer::images(int index) const {
  return images_.Get(index);
}
inline ::Medusa::CoreProto::Editor::Image* Layer::mutable_images(int index) {
  return images_.Mutable(index);
}
inline ::Medusa::CoreProto::Editor::Image* Layer::add_images() {
  return images_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Medusa::CoreProto::Editor::Image >&
Layer::images() const {
  return images_;
}
inline ::google::protobuf::RepeatedPtrField< ::Medusa::CoreProto::Editor::Image >*
Layer::mutable_images() {
  return &images_;
}

// repeated .Medusa.CoreProto.Editor.Button Buttons = 4;
inline int Layer::buttons_size() const {
  return buttons_.size();
}
inline void Layer::clear_buttons() {
  buttons_.Clear();
}
inline const ::Medusa::CoreProto::Editor::Button& Layer::buttons(int index) const {
  return buttons_.Get(index);
}
inline ::Medusa::CoreProto::Editor::Button* Layer::mutable_buttons(int index) {
  return buttons_.Mutable(index);
}
inline ::Medusa::CoreProto::Editor::Button* Layer::add_buttons() {
  return buttons_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Medusa::CoreProto::Editor::Button >&
Layer::buttons() const {
  return buttons_;
}
inline ::google::protobuf::RepeatedPtrField< ::Medusa::CoreProto::Editor::Button >*
Layer::mutable_buttons() {
  return &buttons_;
}

// repeated .Medusa.CoreProto.Editor.Frame Frames = 5;
inline int Layer::frames_size() const {
  return frames_.size();
}
inline void Layer::clear_frames() {
  frames_.Clear();
}
inline const ::Medusa::CoreProto::Editor::Frame& Layer::frames(int index) const {
  return frames_.Get(index);
}
inline ::Medusa::CoreProto::Editor::Frame* Layer::mutable_frames(int index) {
  return frames_.Mutable(index);
}
inline ::Medusa::CoreProto::Editor::Frame* Layer::add_frames() {
  return frames_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Medusa::CoreProto::Editor::Frame >&
Layer::frames() const {
  return frames_;
}
inline ::google::protobuf::RepeatedPtrField< ::Medusa::CoreProto::Editor::Frame >*
Layer::mutable_frames() {
  return &frames_;
}

// repeated .Medusa.CoreProto.Editor.Label Labels = 6;
inline int Layer::labels_size() const {
  return labels_.size();
}
inline void Layer::clear_labels() {
  labels_.Clear();
}
inline const ::Medusa::CoreProto::Editor::Label& Layer::labels(int index) const {
  return labels_.Get(index);
}
inline ::Medusa::CoreProto::Editor::Label* Layer::mutable_labels(int index) {
  return labels_.Mutable(index);
}
inline ::Medusa::CoreProto::Editor::Label* Layer::add_labels() {
  return labels_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Medusa::CoreProto::Editor::Label >&
Layer::labels() const {
  return labels_;
}
inline ::google::protobuf::RepeatedPtrField< ::Medusa::CoreProto::Editor::Label >*
Layer::mutable_labels() {
  return &labels_;
}

// repeated .Medusa.CoreProto.Editor.EditBox EditBoxs = 7;
inline int Layer::editboxs_size() const {
  return editboxs_.size();
}
inline void Layer::clear_editboxs() {
  editboxs_.Clear();
}
inline const ::Medusa::CoreProto::Editor::EditBox& Layer::editboxs(int index) const {
  return editboxs_.Get(index);
}
inline ::Medusa::CoreProto::Editor::EditBox* Layer::mutable_editboxs(int index) {
  return editboxs_.Mutable(index);
}
inline ::Medusa::CoreProto::Editor::EditBox* Layer::add_editboxs() {
  return editboxs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Medusa::CoreProto::Editor::EditBox >&
Layer::editboxs() const {
  return editboxs_;
}
inline ::google::protobuf::RepeatedPtrField< ::Medusa::CoreProto::Editor::EditBox >*
Layer::mutable_editboxs() {
  return &editboxs_;
}

// repeated .Medusa.CoreProto.Editor.ProgressBar ProgressBars = 9;
inline int Layer::progressbars_size() const {
  return progressbars_.size();
}
inline void Layer::clear_progressbars() {
  progressbars_.Clear();
}
inline const ::Medusa::CoreProto::Editor::ProgressBar& Layer::progressbars(int index) const {
  return progressbars_.Get(index);
}
inline ::Medusa::CoreProto::Editor::ProgressBar* Layer::mutable_progressbars(int index) {
  return progressbars_.Mutable(index);
}
inline ::Medusa::CoreProto::Editor::ProgressBar* Layer::add_progressbars() {
  return progressbars_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Medusa::CoreProto::Editor::ProgressBar >&
Layer::progressbars() const {
  return progressbars_;
}
inline ::google::protobuf::RepeatedPtrField< ::Medusa::CoreProto::Editor::ProgressBar >*
Layer::mutable_progressbars() {
  return &progressbars_;
}

// repeated .Medusa.CoreProto.Editor.Trigger Triggers = 10;
inline int Layer::triggers_size() const {
  return triggers_.size();
}
inline void Layer::clear_triggers() {
  triggers_.Clear();
}
inline const ::Medusa::CoreProto::Editor::Trigger& Layer::triggers(int index) const {
  return triggers_.Get(index);
}
inline ::Medusa::CoreProto::Editor::Trigger* Layer::mutable_triggers(int index) {
  return triggers_.Mutable(index);
}
inline ::Medusa::CoreProto::Editor::Trigger* Layer::add_triggers() {
  return triggers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Medusa::CoreProto::Editor::Trigger >&
Layer::triggers() const {
  return triggers_;
}
inline ::google::protobuf::RepeatedPtrField< ::Medusa::CoreProto::Editor::Trigger >*
Layer::mutable_triggers() {
  return &triggers_;
}

// repeated .Medusa.CoreProto.Editor.TriggerRef TriggerRefs = 11;
inline int Layer::triggerrefs_size() const {
  return triggerrefs_.size();
}
inline void Layer::clear_triggerrefs() {
  triggerrefs_.Clear();
}
inline const ::Medusa::CoreProto::Editor::TriggerRef& Layer::triggerrefs(int index) const {
  return triggerrefs_.Get(index);
}
inline ::Medusa::CoreProto::Editor::TriggerRef* Layer::mutable_triggerrefs(int index) {
  return triggerrefs_.Mutable(index);
}
inline ::Medusa::CoreProto::Editor::TriggerRef* Layer::add_triggerrefs() {
  return triggerrefs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Medusa::CoreProto::Editor::TriggerRef >&
Layer::triggerrefs() const {
  return triggerrefs_;
}
inline ::google::protobuf::RepeatedPtrField< ::Medusa::CoreProto::Editor::TriggerRef >*
Layer::mutable_triggerrefs() {
  return &triggerrefs_;
}

// repeated .Medusa.CoreProto.Editor.LayerRef LayerRefs = 12;
inline int Layer::layerrefs_size() const {
  return layerrefs_.size();
}
inline void Layer::clear_layerrefs() {
  layerrefs_.Clear();
}
inline const ::Medusa::CoreProto::Editor::LayerRef& Layer::layerrefs(int index) const {
  return layerrefs_.Get(index);
}
inline ::Medusa::CoreProto::Editor::LayerRef* Layer::mutable_layerrefs(int index) {
  return layerrefs_.Mutable(index);
}
inline ::Medusa::CoreProto::Editor::LayerRef* Layer::add_layerrefs() {
  return layerrefs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Medusa::CoreProto::Editor::LayerRef >&
Layer::layerrefs() const {
  return layerrefs_;
}
inline ::google::protobuf::RepeatedPtrField< ::Medusa::CoreProto::Editor::LayerRef >*
Layer::mutable_layerrefs() {
  return &layerrefs_;
}

// optional string OnLoad = 13;
inline bool Layer::has_onload() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Layer::set_has_onload() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Layer::clear_has_onload() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Layer::clear_onload() {
  if (onload_ != &::google::protobuf::internal::kEmptyString) {
    onload_->clear();
  }
  clear_has_onload();
}
inline const ::std::string& Layer::onload() const {
  return *onload_;
}
inline void Layer::set_onload(const ::std::string& value) {
  set_has_onload();
  if (onload_ == &::google::protobuf::internal::kEmptyString) {
    onload_ = new ::std::string;
  }
  onload_->assign(value);
}
inline void Layer::set_onload(const char* value) {
  set_has_onload();
  if (onload_ == &::google::protobuf::internal::kEmptyString) {
    onload_ = new ::std::string;
  }
  onload_->assign(value);
}
inline void Layer::set_onload(const char* value, size_t size) {
  set_has_onload();
  if (onload_ == &::google::protobuf::internal::kEmptyString) {
    onload_ = new ::std::string;
  }
  onload_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Layer::mutable_onload() {
  set_has_onload();
  if (onload_ == &::google::protobuf::internal::kEmptyString) {
    onload_ = new ::std::string;
  }
  return onload_;
}
inline ::std::string* Layer::release_onload() {
  clear_has_onload();
  if (onload_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = onload_;
    onload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Layer::set_allocated_onload(::std::string* onload) {
  if (onload_ != &::google::protobuf::internal::kEmptyString) {
    delete onload_;
  }
  if (onload) {
    set_has_onload();
    onload_ = onload;
  } else {
    clear_has_onload();
    onload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string OnShow = 14;
inline bool Layer::has_onshow() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Layer::set_has_onshow() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Layer::clear_has_onshow() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Layer::clear_onshow() {
  if (onshow_ != &::google::protobuf::internal::kEmptyString) {
    onshow_->clear();
  }
  clear_has_onshow();
}
inline const ::std::string& Layer::onshow() const {
  return *onshow_;
}
inline void Layer::set_onshow(const ::std::string& value) {
  set_has_onshow();
  if (onshow_ == &::google::protobuf::internal::kEmptyString) {
    onshow_ = new ::std::string;
  }
  onshow_->assign(value);
}
inline void Layer::set_onshow(const char* value) {
  set_has_onshow();
  if (onshow_ == &::google::protobuf::internal::kEmptyString) {
    onshow_ = new ::std::string;
  }
  onshow_->assign(value);
}
inline void Layer::set_onshow(const char* value, size_t size) {
  set_has_onshow();
  if (onshow_ == &::google::protobuf::internal::kEmptyString) {
    onshow_ = new ::std::string;
  }
  onshow_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Layer::mutable_onshow() {
  set_has_onshow();
  if (onshow_ == &::google::protobuf::internal::kEmptyString) {
    onshow_ = new ::std::string;
  }
  return onshow_;
}
inline ::std::string* Layer::release_onshow() {
  clear_has_onshow();
  if (onshow_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = onshow_;
    onshow_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Layer::set_allocated_onshow(::std::string* onshow) {
  if (onshow_ != &::google::protobuf::internal::kEmptyString) {
    delete onshow_;
  }
  if (onshow) {
    set_has_onshow();
    onshow_ = onshow;
  } else {
    clear_has_onshow();
    onshow_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string OnHide = 15;
inline bool Layer::has_onhide() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Layer::set_has_onhide() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Layer::clear_has_onhide() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Layer::clear_onhide() {
  if (onhide_ != &::google::protobuf::internal::kEmptyString) {
    onhide_->clear();
  }
  clear_has_onhide();
}
inline const ::std::string& Layer::onhide() const {
  return *onhide_;
}
inline void Layer::set_onhide(const ::std::string& value) {
  set_has_onhide();
  if (onhide_ == &::google::protobuf::internal::kEmptyString) {
    onhide_ = new ::std::string;
  }
  onhide_->assign(value);
}
inline void Layer::set_onhide(const char* value) {
  set_has_onhide();
  if (onhide_ == &::google::protobuf::internal::kEmptyString) {
    onhide_ = new ::std::string;
  }
  onhide_->assign(value);
}
inline void Layer::set_onhide(const char* value, size_t size) {
  set_has_onhide();
  if (onhide_ == &::google::protobuf::internal::kEmptyString) {
    onhide_ = new ::std::string;
  }
  onhide_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Layer::mutable_onhide() {
  set_has_onhide();
  if (onhide_ == &::google::protobuf::internal::kEmptyString) {
    onhide_ = new ::std::string;
  }
  return onhide_;
}
inline ::std::string* Layer::release_onhide() {
  clear_has_onhide();
  if (onhide_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = onhide_;
    onhide_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Layer::set_allocated_onhide(::std::string* onhide) {
  if (onhide_ != &::google::protobuf::internal::kEmptyString) {
    delete onhide_;
  }
  if (onhide) {
    set_has_onhide();
    onhide_ = onhide;
  } else {
    clear_has_onhide();
    onhide_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string OnClosed = 16;
inline bool Layer::has_onclosed() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Layer::set_has_onclosed() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Layer::clear_has_onclosed() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Layer::clear_onclosed() {
  if (onclosed_ != &::google::protobuf::internal::kEmptyString) {
    onclosed_->clear();
  }
  clear_has_onclosed();
}
inline const ::std::string& Layer::onclosed() const {
  return *onclosed_;
}
inline void Layer::set_onclosed(const ::std::string& value) {
  set_has_onclosed();
  if (onclosed_ == &::google::protobuf::internal::kEmptyString) {
    onclosed_ = new ::std::string;
  }
  onclosed_->assign(value);
}
inline void Layer::set_onclosed(const char* value) {
  set_has_onclosed();
  if (onclosed_ == &::google::protobuf::internal::kEmptyString) {
    onclosed_ = new ::std::string;
  }
  onclosed_->assign(value);
}
inline void Layer::set_onclosed(const char* value, size_t size) {
  set_has_onclosed();
  if (onclosed_ == &::google::protobuf::internal::kEmptyString) {
    onclosed_ = new ::std::string;
  }
  onclosed_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Layer::mutable_onclosed() {
  set_has_onclosed();
  if (onclosed_ == &::google::protobuf::internal::kEmptyString) {
    onclosed_ = new ::std::string;
  }
  return onclosed_;
}
inline ::std::string* Layer::release_onclosed() {
  clear_has_onclosed();
  if (onclosed_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = onclosed_;
    onclosed_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Layer::set_allocated_onclosed(::std::string* onclosed) {
  if (onclosed_ != &::google::protobuf::internal::kEmptyString) {
    delete onclosed_;
  }
  if (onclosed) {
    set_has_onclosed();
    onclosed_ = onclosed;
  } else {
    clear_has_onclosed();
    onclosed_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string OnUpdate = 17;
inline bool Layer::has_onupdate() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Layer::set_has_onupdate() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Layer::clear_has_onupdate() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Layer::clear_onupdate() {
  if (onupdate_ != &::google::protobuf::internal::kEmptyString) {
    onupdate_->clear();
  }
  clear_has_onupdate();
}
inline const ::std::string& Layer::onupdate() const {
  return *onupdate_;
}
inline void Layer::set_onupdate(const ::std::string& value) {
  set_has_onupdate();
  if (onupdate_ == &::google::protobuf::internal::kEmptyString) {
    onupdate_ = new ::std::string;
  }
  onupdate_->assign(value);
}
inline void Layer::set_onupdate(const char* value) {
  set_has_onupdate();
  if (onupdate_ == &::google::protobuf::internal::kEmptyString) {
    onupdate_ = new ::std::string;
  }
  onupdate_->assign(value);
}
inline void Layer::set_onupdate(const char* value, size_t size) {
  set_has_onupdate();
  if (onupdate_ == &::google::protobuf::internal::kEmptyString) {
    onupdate_ = new ::std::string;
  }
  onupdate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Layer::mutable_onupdate() {
  set_has_onupdate();
  if (onupdate_ == &::google::protobuf::internal::kEmptyString) {
    onupdate_ = new ::std::string;
  }
  return onupdate_;
}
inline ::std::string* Layer::release_onupdate() {
  clear_has_onupdate();
  if (onupdate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = onupdate_;
    onupdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Layer::set_allocated_onupdate(::std::string* onupdate) {
  if (onupdate_ != &::google::protobuf::internal::kEmptyString) {
    delete onupdate_;
  }
  if (onupdate) {
    set_has_onupdate();
    onupdate_ = onupdate;
  } else {
    clear_has_onupdate();
    onupdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string OnTouchBegan = 18;
inline bool Layer::has_ontouchbegan() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Layer::set_has_ontouchbegan() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Layer::clear_has_ontouchbegan() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Layer::clear_ontouchbegan() {
  if (ontouchbegan_ != &::google::protobuf::internal::kEmptyString) {
    ontouchbegan_->clear();
  }
  clear_has_ontouchbegan();
}
inline const ::std::string& Layer::ontouchbegan() const {
  return *ontouchbegan_;
}
inline void Layer::set_ontouchbegan(const ::std::string& value) {
  set_has_ontouchbegan();
  if (ontouchbegan_ == &::google::protobuf::internal::kEmptyString) {
    ontouchbegan_ = new ::std::string;
  }
  ontouchbegan_->assign(value);
}
inline void Layer::set_ontouchbegan(const char* value) {
  set_has_ontouchbegan();
  if (ontouchbegan_ == &::google::protobuf::internal::kEmptyString) {
    ontouchbegan_ = new ::std::string;
  }
  ontouchbegan_->assign(value);
}
inline void Layer::set_ontouchbegan(const char* value, size_t size) {
  set_has_ontouchbegan();
  if (ontouchbegan_ == &::google::protobuf::internal::kEmptyString) {
    ontouchbegan_ = new ::std::string;
  }
  ontouchbegan_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Layer::mutable_ontouchbegan() {
  set_has_ontouchbegan();
  if (ontouchbegan_ == &::google::protobuf::internal::kEmptyString) {
    ontouchbegan_ = new ::std::string;
  }
  return ontouchbegan_;
}
inline ::std::string* Layer::release_ontouchbegan() {
  clear_has_ontouchbegan();
  if (ontouchbegan_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ontouchbegan_;
    ontouchbegan_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Layer::set_allocated_ontouchbegan(::std::string* ontouchbegan) {
  if (ontouchbegan_ != &::google::protobuf::internal::kEmptyString) {
    delete ontouchbegan_;
  }
  if (ontouchbegan) {
    set_has_ontouchbegan();
    ontouchbegan_ = ontouchbegan;
  } else {
    clear_has_ontouchbegan();
    ontouchbegan_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string OnTouchMoved = 19;
inline bool Layer::has_ontouchmoved() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Layer::set_has_ontouchmoved() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Layer::clear_has_ontouchmoved() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Layer::clear_ontouchmoved() {
  if (ontouchmoved_ != &::google::protobuf::internal::kEmptyString) {
    ontouchmoved_->clear();
  }
  clear_has_ontouchmoved();
}
inline const ::std::string& Layer::ontouchmoved() const {
  return *ontouchmoved_;
}
inline void Layer::set_ontouchmoved(const ::std::string& value) {
  set_has_ontouchmoved();
  if (ontouchmoved_ == &::google::protobuf::internal::kEmptyString) {
    ontouchmoved_ = new ::std::string;
  }
  ontouchmoved_->assign(value);
}
inline void Layer::set_ontouchmoved(const char* value) {
  set_has_ontouchmoved();
  if (ontouchmoved_ == &::google::protobuf::internal::kEmptyString) {
    ontouchmoved_ = new ::std::string;
  }
  ontouchmoved_->assign(value);
}
inline void Layer::set_ontouchmoved(const char* value, size_t size) {
  set_has_ontouchmoved();
  if (ontouchmoved_ == &::google::protobuf::internal::kEmptyString) {
    ontouchmoved_ = new ::std::string;
  }
  ontouchmoved_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Layer::mutable_ontouchmoved() {
  set_has_ontouchmoved();
  if (ontouchmoved_ == &::google::protobuf::internal::kEmptyString) {
    ontouchmoved_ = new ::std::string;
  }
  return ontouchmoved_;
}
inline ::std::string* Layer::release_ontouchmoved() {
  clear_has_ontouchmoved();
  if (ontouchmoved_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ontouchmoved_;
    ontouchmoved_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Layer::set_allocated_ontouchmoved(::std::string* ontouchmoved) {
  if (ontouchmoved_ != &::google::protobuf::internal::kEmptyString) {
    delete ontouchmoved_;
  }
  if (ontouchmoved) {
    set_has_ontouchmoved();
    ontouchmoved_ = ontouchmoved;
  } else {
    clear_has_ontouchmoved();
    ontouchmoved_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string OnTouchEnd = 20;
inline bool Layer::has_ontouchend() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Layer::set_has_ontouchend() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Layer::clear_has_ontouchend() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Layer::clear_ontouchend() {
  if (ontouchend_ != &::google::protobuf::internal::kEmptyString) {
    ontouchend_->clear();
  }
  clear_has_ontouchend();
}
inline const ::std::string& Layer::ontouchend() const {
  return *ontouchend_;
}
inline void Layer::set_ontouchend(const ::std::string& value) {
  set_has_ontouchend();
  if (ontouchend_ == &::google::protobuf::internal::kEmptyString) {
    ontouchend_ = new ::std::string;
  }
  ontouchend_->assign(value);
}
inline void Layer::set_ontouchend(const char* value) {
  set_has_ontouchend();
  if (ontouchend_ == &::google::protobuf::internal::kEmptyString) {
    ontouchend_ = new ::std::string;
  }
  ontouchend_->assign(value);
}
inline void Layer::set_ontouchend(const char* value, size_t size) {
  set_has_ontouchend();
  if (ontouchend_ == &::google::protobuf::internal::kEmptyString) {
    ontouchend_ = new ::std::string;
  }
  ontouchend_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Layer::mutable_ontouchend() {
  set_has_ontouchend();
  if (ontouchend_ == &::google::protobuf::internal::kEmptyString) {
    ontouchend_ = new ::std::string;
  }
  return ontouchend_;
}
inline ::std::string* Layer::release_ontouchend() {
  clear_has_ontouchend();
  if (ontouchend_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ontouchend_;
    ontouchend_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Layer::set_allocated_ontouchend(::std::string* ontouchend) {
  if (ontouchend_ != &::google::protobuf::internal::kEmptyString) {
    delete ontouchend_;
  }
  if (ontouchend) {
    set_has_ontouchend();
    ontouchend_ = ontouchend;
  } else {
    clear_has_ontouchend();
    ontouchend_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .Medusa.CoreProto.Editor.ListBox Lists = 21;
inline int Layer::lists_size() const {
  return lists_.size();
}
inline void Layer::clear_lists() {
  lists_.Clear();
}
inline const ::Medusa::CoreProto::Editor::ListBox& Layer::lists(int index) const {
  return lists_.Get(index);
}
inline ::Medusa::CoreProto::Editor::ListBox* Layer::mutable_lists(int index) {
  return lists_.Mutable(index);
}
inline ::Medusa::CoreProto::Editor::ListBox* Layer::add_lists() {
  return lists_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Medusa::CoreProto::Editor::ListBox >&
Layer::lists() const {
  return lists_;
}
inline ::google::protobuf::RepeatedPtrField< ::Medusa::CoreProto::Editor::ListBox >*
Layer::mutable_lists() {
  return &lists_;
}

// optional .Medusa.CoreProto.RectF ScissorBox = 22;
inline bool Layer::has_scissorbox() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void Layer::set_has_scissorbox() {
  _has_bits_[0] |= 0x00100000u;
}
inline void Layer::clear_has_scissorbox() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void Layer::clear_scissorbox() {
  if (scissorbox_ != NULL) scissorbox_->::Medusa::CoreProto::RectF::Clear();
  clear_has_scissorbox();
}
inline const ::Medusa::CoreProto::RectF& Layer::scissorbox() const {
  return scissorbox_ != NULL ? *scissorbox_ : *default_instance_->scissorbox_;
}
inline ::Medusa::CoreProto::RectF* Layer::mutable_scissorbox() {
  set_has_scissorbox();
  if (scissorbox_ == NULL) scissorbox_ = new ::Medusa::CoreProto::RectF;
  return scissorbox_;
}
inline ::Medusa::CoreProto::RectF* Layer::release_scissorbox() {
  clear_has_scissorbox();
  ::Medusa::CoreProto::RectF* temp = scissorbox_;
  scissorbox_ = NULL;
  return temp;
}
inline void Layer::set_allocated_scissorbox(::Medusa::CoreProto::RectF* scissorbox) {
  delete scissorbox_;
  scissorbox_ = scissorbox;
  if (scissorbox) {
    set_has_scissorbox();
  } else {
    clear_has_scissorbox();
  }
}

// optional int32 Tag = 51;
inline bool Layer::has_tag() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void Layer::set_has_tag() {
  _has_bits_[0] |= 0x00200000u;
}
inline void Layer::clear_has_tag() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void Layer::clear_tag() {
  tag_ = 0;
  clear_has_tag();
}
inline ::google::protobuf::int32 Layer::tag() const {
  return tag_;
}
inline void Layer::set_tag(::google::protobuf::int32 value) {
  set_has_tag();
  tag_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Editor
}  // namespace CoreProto
}  // namespace Medusa

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Medusa::CoreProto::Editor::EditBox_EditBoxKeyboardReturnType>() {
  return ::Medusa::CoreProto::Editor::EditBox_EditBoxKeyboardReturnType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Medusa::CoreProto::Editor::EditBox_EditBoxInputMode>() {
  return ::Medusa::CoreProto::Editor::EditBox_EditBoxInputMode_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Medusa::CoreProto::Editor::EditBox_EditBoxInputFlag>() {
  return ::Medusa::CoreProto::Editor::EditBox_EditBoxInputFlag_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Medusa::CoreProto::Editor::ProgressBar_ProgressBarType>() {
  return ::Medusa::CoreProto::Editor::ProgressBar_ProgressBarType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Medusa::CoreProto::Editor::ListBox_ScorllDirection>() {
  return ::Medusa::CoreProto::Editor::ListBox_ScorllDirection_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Medusa::CoreProto::Editor::ListBox_VerticalOrder>() {
  return ::Medusa::CoreProto::Editor::ListBox_VerticalOrder_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Medusa::CoreProto::Editor::TextAlignmentType>() {
  return ::Medusa::CoreProto::Editor::TextAlignmentType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_LayerEditor_2eproto__INCLUDED
